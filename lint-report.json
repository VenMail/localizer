[{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\askAICommand.ts","messages":[{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":203,"column":25,"nodeType":"BlockStatement","messageId":"unexpected","endLine":204,"endColumn":18,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[8254,8272],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":210,"column":21,"nodeType":"BlockStatement","messageId":"unexpected","endLine":211,"endColumn":14,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[8466,8480],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":245,"column":21,"nodeType":"BlockStatement","messageId":"unexpected","endLine":246,"endColumn":14,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[9916,9930],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\r\n\r\n/**\r\n * Command to ask AI for help\r\n */\r\nexport class AskAICommand {\r\n    constructor(private context: vscode.ExtensionContext) {}\r\n\r\n    private async isEnabled(): Promise<boolean> {\r\n        try {\r\n            const cfg = vscode.workspace.getConfiguration('ai-localizer');\r\n            const autoTranslate = cfg.get<boolean>('i18n.autoTranslate') ?? false;\r\n            const secret = (await this.context.secrets.get('openaiApiKey'))?.trim() || '';\r\n            const fromConfig = (cfg.get<string>('openaiApiKey') || '').trim();\r\n            const hasKey = !!(secret || fromConfig);\r\n            return !(autoTranslate && hasKey);\r\n        } catch {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    private async pickRequest(hasSelection: boolean): Promise<string | null> {\r\n        const templates: Array<{ label: string; description: string; value: string }> = [\r\n            {\r\n                label: hasSelection ? 'Explain this selection' : 'Explain this file',\r\n                description: 'High-level explanation + key details',\r\n                value: hasSelection\r\n                    ? 'Explain what this selected code does. Summarize behavior, data flow, and key risks.'\r\n                    : 'Explain what this file does. Summarize responsibilities, data flow, and key risks.',\r\n            },\r\n            {\r\n                label: hasSelection ? 'Find bugs in selection' : 'Find bugs in file',\r\n                description: 'Potential bugs + edge cases',\r\n                value: hasSelection\r\n                    ? 'Review this selected code for bugs, edge cases, and incorrect assumptions. Propose minimal fixes.'\r\n                    : 'Review this file for bugs, edge cases, and incorrect assumptions. Propose minimal fixes.',\r\n            },\r\n            {\r\n                label: hasSelection ? 'Refactor selection' : 'Refactor file',\r\n                description: 'Make it clearer/simpler without changing behavior',\r\n                value: hasSelection\r\n                    ? 'Refactor this selected code to be simpler and clearer without changing behavior. Provide a minimal diff.'\r\n                    : 'Refactor this file to be simpler and clearer without changing behavior. Provide a minimal diff.',\r\n            },\r\n            {\r\n                label: hasSelection ? 'Write tests for selection' : 'Write tests for file',\r\n                description: 'Suggested test cases + example tests',\r\n                value: hasSelection\r\n                    ? 'Write tests for this selected behavior. Suggest test cases and provide example test code.'\r\n                    : 'Write tests for this file. Suggest test cases and provide example test code.',\r\n            },\r\n            {\r\n                label: 'Custom request…',\r\n                description: 'Type your own question/request',\r\n                value: '__custom__',\r\n            },\r\n        ];\r\n\r\n        const picked = await vscode.window.showQuickPick(templates, {\r\n            placeHolder: 'Ask AI: choose what you want help with',\r\n        });\r\n        if (!picked) {\r\n            return null;\r\n        }\r\n\r\n        if (picked.value !== '__custom__') {\r\n            return picked.value;\r\n        }\r\n\r\n        const userInput = await vscode.window.showInputBox({\r\n            placeHolder: 'Describe what you want the AI to do…',\r\n            prompt: 'Ask AI for code suggestions or explanations',\r\n        });\r\n        return userInput?.trim() ? userInput.trim() : null;\r\n    }\r\n\r\n    private buildPrompt(args: {\r\n        userInput: string;\r\n        selectionText: string;\r\n        contextSnippet: string;\r\n        uri?: string;\r\n        languageId?: string;\r\n    }): string {\r\n        const parts: string[] = [];\r\n        parts.push('You are a senior software engineer helping me in my IDE.');\r\n        parts.push('');\r\n        parts.push('## Task');\r\n        parts.push(args.userInput.trim());\r\n        parts.push('');\r\n\r\n        if (args.uri) {\r\n            parts.push('## File');\r\n            parts.push(args.uri);\r\n            parts.push('');\r\n        }\r\n        if (args.languageId) {\r\n            parts.push('## Language');\r\n            parts.push(args.languageId);\r\n            parts.push('');\r\n        }\r\n\r\n        if (args.selectionText) {\r\n            parts.push('## Selected code/text');\r\n            parts.push('```');\r\n            parts.push(args.selectionText);\r\n            parts.push('```');\r\n            parts.push('');\r\n        }\r\n\r\n        if (args.contextSnippet && args.contextSnippet !== args.selectionText) {\r\n            parts.push('## Additional context (truncated)');\r\n            parts.push('```');\r\n            parts.push(args.contextSnippet);\r\n            parts.push('```');\r\n            parts.push('');\r\n        }\r\n\r\n        parts.push('## Constraints');\r\n        parts.push('- Be concise but complete.');\r\n        parts.push('- If you propose code changes, provide the minimal diff and explain why.');\r\n        parts.push('- If something is ambiguous, ask clarifying questions.');\r\n\r\n        return parts.join('\\n');\r\n    }\r\n\r\n    private async openPromptDocument(prompt: string): Promise<void> {\r\n        const doc = await vscode.workspace.openTextDocument({\r\n            language: 'markdown',\r\n            content: prompt,\r\n        });\r\n        await vscode.window.showTextDocument(doc, { preview: false });\r\n    }\r\n\r\n    private async showFallbackModal(prompt: string): Promise<void> {\r\n        const choice = await vscode.window.showInformationMessage(\r\n            'AI Localizer: Could not inject the prompt into an AI chat window. The prompt can be copied or opened for manual paste.',\r\n            { modal: true },\r\n            'Copy prompt',\r\n            'Open prompt',\r\n            'Cancel',\r\n        );\r\n\r\n        if (choice === 'Copy prompt') {\r\n            await vscode.env.clipboard.writeText(prompt);\r\n            vscode.window.showInformationMessage('AI Localizer: Prompt copied to clipboard.');\r\n            return;\r\n        }\r\n\r\n        if (choice === 'Open prompt') {\r\n            await this.openPromptDocument(prompt);\r\n        }\r\n    }\r\n\r\n    async execute(): Promise<void> {\r\n        const enabled = await this.isEnabled();\r\n        if (!enabled) {\r\n            vscode.window.showInformationMessage(\r\n                'AI Localizer: Ask AI is disabled because OpenAI translations are enabled. Disable ai-localizer.i18n.autoTranslate or remove the OpenAI API key to use Ask AI prompt injection.',\r\n            );\r\n            return;\r\n        }\r\n\r\n        const active = vscode.window.activeTextEditor;\r\n        const selectionText =\r\n            active && !active.selection.isEmpty\r\n                ? active.document.getText(active.selection).trim()\r\n                : '';\r\n\r\n        const userInput = await this.pickRequest(!!selectionText);\r\n        if (!userInput) return;\r\n\r\n        let contextSnippet = '';\r\n        if (selectionText) {\r\n            contextSnippet = selectionText.slice(0, 4000);\r\n        } else if (active) {\r\n            const document = active.document;\r\n            const totalText = document.getText();\r\n            contextSnippet = totalText.slice(0, 8000);\r\n        }\r\n\r\n        // Try to forward to host AI chat\r\n        const config = vscode.workspace.getConfiguration('ai-localizer');\r\n        const forwardCommand = (config.get<string>('askAI.forwardToCommand') || '').trim();\r\n        const uri = active ? active.document.uri.toString() : undefined;\r\n        const languageId = active ? active.document.languageId : undefined;\r\n        const prompt = this.buildPrompt({ userInput, selectionText, contextSnippet, uri, languageId });\r\n\r\n        if (forwardCommand) {\r\n            try {\r\n                await vscode.commands.executeCommand(forwardCommand, prompt);\r\n                return;\r\n            } catch {\r\n                try {\r\n                    await vscode.commands.executeCommand(forwardCommand, {\r\n                        prompt,\r\n                        question: userInput,\r\n                        selection: selectionText,\r\n                        context: contextSnippet,\r\n                        uri,\r\n                        languageId,\r\n                    });\r\n                    return;\r\n                } catch {\r\n                }\r\n            }\r\n        } else {\r\n            try {\r\n                await vscode.commands.executeCommand('workbench.action.chat.open', prompt);\r\n                return;\r\n            } catch {\r\n            }\r\n\r\n            try {\r\n                const all = await vscode.commands.getCommands(true);\r\n                const candidates = all\r\n                    .filter((c) => {\r\n                        const lower = c.toLowerCase();\r\n                        if (!lower.includes('chat') && !lower.includes('ask')) {\r\n                            return false;\r\n                        }\r\n                        return (\r\n                            lower.includes('windsurf') ||\r\n                            lower.includes('codeium') ||\r\n                            lower.includes('cursor') ||\r\n                            lower.includes('copilot') ||\r\n                            lower.includes('composer')\r\n                        );\r\n                    })\r\n                    .slice(0, 20);\r\n\r\n                if (candidates.length === 1) {\r\n                    await vscode.commands.executeCommand(candidates[0], prompt);\r\n                    return;\r\n                }\r\n\r\n                if (candidates.length > 1) {\r\n                    const picked = await vscode.window.showQuickPick(candidates, {\r\n                        placeHolder: 'Select a chat command to inject the generated prompt into',\r\n                    });\r\n                    if (picked) {\r\n                        await vscode.commands.executeCommand(picked, prompt);\r\n                        return;\r\n                    }\r\n                }\r\n            } catch {\r\n            }\r\n        }\r\n\r\n        await this.showFallbackModal(prompt);\r\n    }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\commandRegistry.ts","messages":[{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":71,"column":25,"nodeType":"BlockStatement","messageId":"unexpected","endLine":72,"endColumn":18,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[3080,3097],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":106,"column":25,"nodeType":"BlockStatement","messageId":"unexpected","endLine":107,"endColumn":18,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[4420,4437],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":388,"column":62,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":388,"endColumn":91}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\nimport { I18nIndex } from '../core/i18nIndex';\nimport { TranslationService } from '../services/translationService';\nimport { ProjectConfigService } from '../services/projectConfigService';\nimport { FileSystemService } from '../services/fileSystemService';\nimport { I18nStatusBar } from '../core/statusBar';\nimport { DiagnosticAnalyzer, getDiagnosticConfig } from '../services/diagnosticAnalyzer';\n\n// Static imports for command handlers (avoids runtime require() overhead)\nimport { ConfigureProjectCommand } from './configureProjectCommand';\nimport { ConvertSelectionCommand } from './convertSelectionCommand';\nimport { ExtractSelectionCommand } from './extractSelectionCommand';\nimport { StatusCommand } from './statusCommand';\nimport { ScriptCommands } from './scriptCommands';\nimport { UntranslatedCommands } from './untranslatedCommands';\nimport { ComponentCommands } from './componentCommands';\nimport { ScaffoldMessagesCommand } from './scaffoldMessagesCommand';\nimport { ProjectFixCommand } from './projectFixCommand';\nimport { UninstallProjectI18nCommand } from './uninstallProjectI18nCommand';\nimport { AskAICommand } from './askAICommand';\nimport { operationLock } from './untranslated/utils/operationLock';\nimport { ReviewGeneratedService } from '../services/reviewGeneratedService';\nimport * as path from 'path';\n\n/**\n * Registry for all extension commands\n */\nexport class CommandRegistry {\n    private diagnosticAnalyzer: DiagnosticAnalyzer;\n    private refreshAllDiagnosticsPromise: Promise<void> | null = null;\n    private localeDiagnosticsDebounce = new Map<string, NodeJS.Timeout>();\n    private static readonly LOCALE_DIAG_DEBOUNCE_MS = 1200;\n\n    constructor(\n        private context: vscode.ExtensionContext,\n        private i18nIndex: I18nIndex,\n        private translationService: TranslationService,\n        private projectConfigService: ProjectConfigService,\n        private fileSystemService: FileSystemService,\n        private statusBar: I18nStatusBar,\n        private log: vscode.OutputChannel,\n    ) {\n        this.diagnosticAnalyzer = new DiagnosticAnalyzer(\n            i18nIndex,\n            projectConfigService,\n            log,\n        );\n    }\n\n    private async clearI18nReports(): Promise<void> {\n        const folders = vscode.workspace.workspaceFolders || [];\n        if (!folders.length) {\n            return;\n        }\n\n        const reportFiles = [\n            '.i18n-untranslated-report.json',\n            '.i18n-untranslated-untranslated.json',\n            '.i18n-untranslated-compact.json',\n            '.i18n-unused-report.json',\n            '.i18n-invalid-report.json',\n            '.i18n-review-generated.json',\n        ];\n\n        for (const folder of folders) {\n            const scriptsDir = vscode.Uri.joinPath(folder.uri, 'scripts');\n            for (const name of reportFiles) {\n                const uri = vscode.Uri.joinPath(scriptsDir, name);\n                try {\n                    await vscode.workspace.fs.delete(uri, { recursive: false, useTrash: false });\n                } catch {\n                }\n            }\n        }\n    }\n\n    private clearLocaleDebounceTimers(): void {\n        for (const timer of this.localeDiagnosticsDebounce.values()) {\n            clearTimeout(timer);\n        }\n        this.localeDiagnosticsDebounce.clear();\n    }\n\n    /**\n     * Register all commands\n     */\n    registerAll(): vscode.Disposable[] {\n        const disposables: vscode.Disposable[] = [];\n\n        try {\n            this.log.appendLine('[CommandRegistry] Registering commands and diagnostics listeners...');\n\n            const updateAskAiContext = async (): Promise<void> => {\n                try {\n                    const cfg = vscode.workspace.getConfiguration('ai-localizer');\n                    const autoTranslate = cfg.get<boolean>('i18n.autoTranslate') ?? false;\n                    const secret = (await this.context.secrets.get('openaiApiKey'))?.trim() || '';\n                    const fromConfig = (cfg.get<string>('openaiApiKey') || '').trim();\n                    const hasKey = !!(secret || fromConfig);\n                    const askAiEnabled = !(autoTranslate && hasKey);\n                    await vscode.commands.executeCommand(\n                        'setContext',\n                        'aiLocalizer.askAIEnabled',\n                        askAiEnabled,\n                    );\n                } catch {\n                }\n            };\n\n            void updateAskAiContext();\n            disposables.push(\n                vscode.workspace.onDidChangeConfiguration((e) => {\n                    if (\n                        e.affectsConfiguration('ai-localizer.openaiApiKey') ||\n                        e.affectsConfiguration('ai-localizer.i18n.autoTranslate')\n                    ) {\n                        void updateAskAiContext();\n                    }\n                }),\n            );\n            disposables.push(\n                this.context.secrets.onDidChange(() => {\n                    void updateAskAiContext();\n                }),\n            );\n\n            const untranslatedDiagnostics = vscode.languages.createDiagnosticCollection('ai-i18n-untranslated');\n            disposables.push(untranslatedDiagnostics);\n            const sourceFileDiagnostics = vscode.languages.createDiagnosticCollection('ai-i18n-missing-refs');\n            disposables.push(sourceFileDiagnostics);\n            const reviewDiagnostics = vscode.languages.createDiagnosticCollection('ai-i18n-review');\n            disposables.push(reviewDiagnostics);\n            const reviewService = new ReviewGeneratedService(this.i18nIndex, this.log);\n            const reviewDocumentSelector: vscode.DocumentSelector = [\n                { scheme: 'file', pattern: '**/scripts/.i18n-review-generated.json' },\n            ];\n            let refreshAllSourceDiagnosticsPromise: Promise<void> | null = null;\n\n            // Ensure debounce timers are cleared on dispose\n            disposables.push({\n                dispose: () => {\n                    this.clearLocaleDebounceTimers();\n                },\n            });\n\n        // Ask AI command (prompt injection)\n        const askAiCmd = new AskAICommand(this.context);\n        disposables.push(\n            vscode.commands.registerCommand('ai-localizer.askAI', () => askAiCmd.execute()),\n        );\n\n        // Rescan command\n        disposables.push(\n            vscode.commands.registerCommand('ai-localizer.i18n.rescan', async () => {\n                await this.i18nIndex.ensureInitialized(true);\n                const count = this.i18nIndex.getAllKeys().length;\n\n                const foldersForState = vscode.workspace.workspaceFolders || [];\n                const folderKey =\n                    foldersForState.length > 0\n                        ? foldersForState.map((f) => f.uri.fsPath).join('|')\n                        : 'no-workspace';\n                const rewriteOfferedKey = `ai-i18n:firstRewriteOffered:${folderKey}`;\n                const languageSwitcherOfferedKey = `ai-i18n:languageSwitcherOffered:${folderKey}`;\n                const rewriteOffered = this.context.workspaceState.get<boolean>(\n                    rewriteOfferedKey,\n                );\n                const languageSwitcherOffered = this.context.workspaceState.get<boolean>(\n                    languageSwitcherOfferedKey,\n                );\n\n                if (count === 0) {\n                    const choice = await vscode.window.showInformationMessage(\n                        'AI Localizer: No translation keys were found. Run the first-time setup now to configure scripts, extract keys, sync locales, rewrite code, and (optionally) auto-translate missing entries?',\n                        'Run first-time setup',\n                        'Cancel',\n                    );\n                    if (choice === 'Run first-time setup') {\n                        await vscode.commands.executeCommand('ai-localizer.i18n.firstTimeSetup');\n                    }\n                } else {\n                    if (!rewriteOffered) {\n                        const localesAfterBootstrap = this.i18nIndex.getAllLocales();\n                        const rewriteChoice = await vscode.window.showInformationMessage(\n                            `AI Localizer: Indexed ${count} translation key(s)` +\n                                (localesAfterBootstrap.length\n                                    ? ` across ${localesAfterBootstrap.length} locale(s): ${localesAfterBootstrap.join(', ')}`\n                                    : ''\n                                ) +\n                                '. Run the rewrite step now to replace inline strings with t() calls?',\n                            'Run rewrite now',\n                            'Skip for now',\n                        );\n\n                        if (rewriteChoice === 'Run rewrite now') {\n                            await vscode.commands.executeCommand('ai-localizer.i18n.runRewriteScript');\n                        }\n\n                        await this.context.workspaceState.update(rewriteOfferedKey, true);\n                    }\n\n                    if (!languageSwitcherOffered) {\n                        const lsChoice = await vscode.window.showInformationMessage(\n                            'AI Localizer: Install a LanguageSwitcher component into your app now?',\n                            'Install LanguageSwitcher',\n                            'Skip for now',\n                        );\n\n                        if (lsChoice === 'Install LanguageSwitcher') {\n                            await vscode.commands.executeCommand('ai-localizer.i18n.copyLanguageSwitcher');\n                        }\n\n                        await this.context.workspaceState.update(languageSwitcherOfferedKey, true);\n                    } else if (rewriteOffered) {\n                        vscode.window.showInformationMessage(\n                            `AI Localizer: Indexed ${count} translation keys.`,\n                        );\n                    }\n                }\n\n                await this.refreshAllDiagnostics(untranslatedDiagnostics);\n                await refreshAllSourceDiagnostics();\n            }),\n        );\n\n        // Configure project command\n        const configureCmd = new ConfigureProjectCommand(\n            this.context,\n            this.projectConfigService,\n            this.fileSystemService,\n        );\n        disposables.push(\n            vscode.commands.registerCommand('ai-localizer.i18n.configureProject', () =>\n                configureCmd.execute(),\n            ),\n        );\n\n        // Convert selection command\n        const convertCmd = new ConvertSelectionCommand(\n            this.context,\n            this.i18nIndex,\n            this.translationService,\n            this.projectConfigService,\n            untranslatedDiagnostics,\n        );\n        disposables.push(\n            vscode.commands.registerCommand('ai-localizer.i18n.convertSelectionToKey', () =>\n                convertCmd.execute(),\n            ),\n        );\n\n        // Extract selection command\n        const extractCmd = new ExtractSelectionCommand();\n        disposables.push(\n            vscode.commands.registerCommand('ai-localizer.i18n.extractSelection', () =>\n                extractCmd.execute(),\n            ),\n        );\n\n        // Status command\n        const statusCmd = new StatusCommand(this.statusBar, this.projectConfigService);\n        disposables.push(\n            vscode.commands.registerCommand('ai-localizer.i18n.showStatus', () =>\n                statusCmd.execute(),\n            ),\n        );\n\n        // Project-wide fix command\n        const projectFixCmd = new ProjectFixCommand(\n            this.i18nIndex,\n            this.translationService,\n            this.projectConfigService,\n            this.diagnosticAnalyzer,\n        );\n        disposables.push(\n            vscode.commands.registerCommand('ai-localizer.i18n.fixAllIssuesInProject', () =>\n                projectFixCmd.execute(),\n            ),\n        );\n\n        // Uninstall i18n command\n        const uninstallCmd = new UninstallProjectI18nCommand(\n            this.i18nIndex,\n            this.context,\n            this.log,\n        );\n        disposables.push(\n            vscode.commands.registerCommand('ai-localizer.i18n.uninstallProjectI18n', () =>\n                uninstallCmd.execute(),\n            ),\n        );\n\n        // Script commands\n        const scriptCmds = new ScriptCommands(this.context);\n        disposables.push(\n            vscode.commands.registerCommand('ai-localizer.i18n.runExtractScript', () =>\n                scriptCmds.runExtract(),\n            ),\n            vscode.commands.registerCommand('ai-localizer.i18n.runRewriteScript', () =>\n                scriptCmds.runRewrite(),\n            ),\n            vscode.commands.registerCommand('ai-localizer.i18n.runSyncScript', async () => {\n                await scriptCmds.runSync();\n\n                const apiKey = (await this.translationService.getApiKey())?.trim();\n                if (apiKey) {\n                    await scriptCmds.runFixUntranslated();\n                    await vscode.commands.executeCommand('ai-localizer.i18n.applyUntranslatedAiFixes');\n                }\n            }),\n            // Lightweight sync: only runs i18n:sync without triggering fix-untranslated cascade\n            // Used by single-key quick fixes to avoid regenerating reports mid-translation\n            vscode.commands.registerCommand('ai-localizer.i18n.runSyncScriptOnly', () =>\n                scriptCmds.runSync(),\n            ),\n            // Granular sync: sync only specific keys (most efficient for quick fixes)\n            vscode.commands.registerCommand(\n                'ai-localizer.i18n.syncKeys',\n                async (keys: string[], folder?: vscode.WorkspaceFolder) =>\n                    scriptCmds.syncKeys(keys, folder),\n            ),\n            // Granular sync: sync all keys from a specific file\n            vscode.commands.registerCommand(\n                'ai-localizer.i18n.syncFile',\n                async (fileUri: vscode.Uri, folder?: vscode.WorkspaceFolder) =>\n                    scriptCmds.syncFile(fileUri, folder),\n            ),\n            // Ensure keys exist in all locales (create if missing)\n            vscode.commands.registerCommand(\n                'ai-localizer.i18n.ensureKeys',\n                async (keys: string[], values?: Record<string, string>, folder?: vscode.WorkspaceFolder) =>\n                    scriptCmds.ensureKeys(keys, values ?? {}, folder),\n            ),\n            vscode.commands.registerCommand('ai-localizer.i18n.runFixUntranslatedScript', async () => {\n                await scriptCmds.runFixUntranslated();\n\n                const apiKey = (await this.translationService.getApiKey())?.trim();\n                if (apiKey) {\n                    await vscode.commands.executeCommand('ai-localizer.i18n.applyUntranslatedAiFixes');\n                }\n            }),\n            vscode.commands.registerCommand('ai-localizer.i18n.runRewriteBladeScript', () =>\n                scriptCmds.runRewriteBlade(),\n            ),\n            vscode.commands.registerCommand('ai-localizer.i18n.runCleanupUnusedScript', () =>\n                scriptCmds.runCleanupUnused(),\n            ),\n            vscode.commands.registerCommand('ai-localizer.i18n.runRestoreInvalidScript', () =>\n                scriptCmds.runRestoreInvalid(),\n            ),\n            vscode.commands.registerCommand('ai-localizer.i18n.firstTimeSetup', async () => {\n                await vscode.window.withProgress(\n                    {\n                        location: vscode.ProgressLocation.Notification,\n                        title: 'AI Localizer: First-time project setup',\n                        cancellable: false,\n                    },\n                    async (progress) => {\n                        try {\n                            progress.report({ message: 'Cleaning existing i18n reports (unused/invalid/untranslated)...' });\n                            await this.clearI18nReports();\n\n                            progress.report({ message: 'Configuring project i18n (scripts, locales, srcRoot)...' });\n                            await configureCmd.execute();\n\n                            progress.report({ message: 'Running initial extract (i18n:extract)...' });\n                            await scriptCmds.runExtract();\n\n                            progress.report({ message: 'Syncing locales (i18n:sync)...' });\n                            await scriptCmds.runSync();\n\n                            const apiKey = (await this.translationService.getApiKey())?.trim();\n                            let ranAiFixes = false;\n                            if (apiKey) {\n                                progress.report({ message: 'Filling missing translations with AI (i18n:fix-untranslated)...' });\n                                await scriptCmds.runFixUntranslated();\n                                await vscode.commands.executeCommand('ai-localizer.i18n.applyUntranslatedAiFixes');\n                                ranAiFixes = true;\n                            }\n\n                            progress.report({ message: 'Rewriting source code to use t() calls (i18n:rewrite)...' });\n                            await scriptCmds.runRewrite();\n\n                            try {\n                                const foldersForEnv = vscode.workspace.workspaceFolders || [];\n                                const primaryFolder = foldersForEnv[0];\n                                if (primaryFolder) {\n                                    const projectEnvModule = require('../core/projectEnv') as typeof import('../core/projectEnv');\n                                    const env = await projectEnvModule.getProjectEnv(primaryFolder);\n                                    if (env.bundler === 'vite') {\n                                        progress.report({ message: 'Scaffolding Vite messages loader (auto/**/*.json)...' });\n                                        await vscode.commands.executeCommand('ai-localizer.i18n.scaffoldMessagesLoader');\n                                    }\n                                }\n                            } catch (scaffoldErr) {\n                                const msg = scaffoldErr instanceof Error ? scaffoldErr.message : String(scaffoldErr);\n                                this.log.appendLine(`[FirstTimeSetup] Failed to scaffold messages loader: ${msg}`);\n                            }\n\n                            progress.report({ message: 'Building translation index and diagnostics...' });\n                            await this.i18nIndex.ensureInitialized(true);\n                            const keyCount = this.i18nIndex.getAllKeys().length;\n                            const locales = this.i18nIndex.getAllLocales();\n\n                            await this.refreshAllDiagnostics(untranslatedDiagnostics);\n\n                            const foldersForState = vscode.workspace.workspaceFolders || [];\n                            const folderKey =\n                                foldersForState.length > 0\n                                    ? foldersForState.map((f) => f.uri.fsPath).join('|')\n                                    : 'no-workspace';\n                            const languageSwitcherOfferedKey = `ai-i18n:languageSwitcherOffered:${folderKey}`;\n                            const languageSwitcherOffered = this.context.workspaceState.get<boolean>(\n                                languageSwitcherOfferedKey,\n                            );\n\n                            if (!languageSwitcherOffered) {\n                                const lsChoice = await vscode.window.showInformationMessage(\n                                    'AI Localizer: Install a LanguageSwitcher component into your app now?',\n                                    'Install LanguageSwitcher',\n                                    'Skip for now',\n                                );\n\n                                if (lsChoice === 'Install LanguageSwitcher') {\n                                    await vscode.commands.executeCommand('ai-localizer.i18n.copyLanguageSwitcher');\n                                }\n\n                                await this.context.workspaceState.update(languageSwitcherOfferedKey, true);\n                            }\n\n                            const parts: string[] = [];\n                            parts.push(`AI i18n setup complete: ${keyCount} key(s)`);\n                            if (locales.length) {\n                                parts.push(`across ${locales.length} locale(s): ${locales.join(', ')}`);\n                            }\n                            if (!apiKey) {\n                                parts.push('No OpenAI API key configured; you can add one later to enable automatic translations.');\n                            } else if (ranAiFixes) {\n                                parts.push('AI attempted to fill missing translations; review locale files as needed.');\n                            }\n\n                            vscode.window.showInformationMessage(parts.join(' '));\n                        } catch (error) {\n                            const msg = error instanceof Error ? error.message : String(error);\n                            this.log.appendLine(`[FirstTimeSetup] Failed: ${msg}`);\n                            vscode.window.showErrorMessage(`AI Localizer: First-time setup failed. ${msg}`);\n                        }\n                    },\n                );\n            }),\n        );\n\n        // Untranslated commands\n        const untranslatedCmds = new UntranslatedCommands(\n            this.i18nIndex,\n            this.translationService,\n            this.projectConfigService,\n            this.context,\n            this.log,\n        );\n        // Register cleanup for UntranslatedCommands\n        disposables.push({ dispose: () => untranslatedCmds.dispose() });\n        disposables.push(\n            vscode.commands.registerCommand('ai-localizer.i18n.openUntranslatedReport', () =>\n                untranslatedCmds.openReport(),\n            ),\n            vscode.commands.registerCommand(\n                'ai-localizer.i18n.refreshFileDiagnostics',\n                async (uri: vscode.Uri, extraKeys?: string[]) => {\n                    if (!uri) return;\n                    await this.refreshFileDiagnostics(untranslatedDiagnostics, uri, extraKeys);\n                },\n            ),\n            vscode.commands.registerCommand(\n                'ai-localizer.i18n.invalidateReportKeys',\n                (keys: string[]) => {\n                    if (keys && keys.length > 0) {\n                        this.diagnosticAnalyzer.invalidateUntranslatedReportKeys(keys);\n                    }\n                },\n            ),\n            vscode.commands.registerCommand('ai-localizer.i18n.applyUntranslatedAiFixes', () =>\n                untranslatedCmds.applyAiFixes(),\n            ),\n            vscode.commands.registerCommand('ai-localizer.reviewGenerated.refresh', async () => {\n                const folder = vscode.workspace.workspaceFolders?.[0];\n                if (!folder) return;\n                await reviewService.refreshDiagnostics(folder, reviewDiagnostics);\n            }),\n            vscode.commands.registerCommand('ai-localizer.reviewGenerated.apply', async () => {\n                const folder = vscode.workspace.workspaceFolders?.[0];\n                const editor = vscode.window.activeTextEditor;\n                if (!folder || !editor) return;\n                await reviewService.applyReviewFile(folder, editor.document);\n                await reviewService.refreshDiagnostics(folder, reviewDiagnostics);\n            }),\n            vscode.commands.registerCommand('ai-localizer.reviewGenerated.showHistory', async () => {\n                const folder = vscode.workspace.workspaceFolders?.[0];\n                const editor = vscode.window.activeTextEditor;\n                if (!folder || !editor) return;\n                await reviewService.showGitHistoryForCursor(folder, editor.document, editor.selection.active);\n            }),\n            vscode.commands.registerCommand(\n                'ai-localizer.i18n.applyUntranslatedQuickFix',\n                (documentUri: vscode.Uri, key: string, locales: string[]) =>\n                    untranslatedCmds.applyQuickFix(documentUri, key, locales),\n            ),\n            vscode.commands.registerCommand('ai-localizer.i18n.reviewSelection', () =>\n                untranslatedCmds.reviewSelection(),\n            ),\n            vscode.commands.registerCommand('ai-localizer.i18n.generateAutoIgnore', () =>\n                untranslatedCmds.generateAutoIgnore(),\n            ),\n            vscode.commands.registerCommand('ai-localizer.i18n.showHealthReport', () =>\n                untranslatedCmds.showHealthReport(),\n            ),\n            vscode.commands.registerCommand(\n                'ai-localizer.i18n.applyStyleSuggestionQuickFix',\n                (documentUri: vscode.Uri, key: string, locale: string, suggested: string) =>\n                    untranslatedCmds.applyStyleSuggestionQuickFix(documentUri, key, locale, suggested),\n            ),\n            vscode.commands.registerCommand(\n                'ai-localizer.i18n.applyAllStyleSuggestionsInFile',\n                (documentUri?: vscode.Uri) => untranslatedCmds.applyAllStyleSuggestionsInFile(documentUri),\n            ),\n            vscode.commands.registerCommand(\n                'ai-localizer.i18n.fixAllIssuesInFile',\n                (documentUri?: vscode.Uri) => untranslatedCmds.fixAllIssuesInFile(documentUri),\n            ),\n            vscode.commands.registerCommand(\n                'ai-localizer.i18n.cleanupUnusedKeysInFile',\n                (documentUri?: vscode.Uri) => untranslatedCmds.cleanupUnusedInFile(documentUri),\n            ),\n            vscode.commands.registerCommand(\n                'ai-localizer.i18n.restoreInvalidKeysInFile',\n                (documentUri?: vscode.Uri) => untranslatedCmds.restoreInvalidInFile(documentUri),\n            ),\n            vscode.commands.registerCommand(\n                'ai-localizer.i18n.bulkFixMissingKeyReferences',\n                async (documentUri?: vscode.Uri) => {\n                    const uri = documentUri || vscode.window.activeTextEditor?.document.uri;\n                    if (!uri) {\n                        vscode.window.showWarningMessage('AI Localizer: No document available.');\n                        return;\n                    }\n                    try {\n                        await untranslatedCmds.bulkFixMissingKeyReferences(uri);\n                    } catch (err) {\n                        const msg = err instanceof Error ? err.message : String(err);\n                        console.error('AI Localizer: Failed to bulk fix missing key references:', err);\n                        vscode.window.showErrorMessage(`AI Localizer: Failed to fix missing references. ${msg}`);\n                    }\n                },\n            ),\n            vscode.commands.registerCommand(\n                'ai-localizer.i18n.translateAllUntranslatedInFile',\n                (documentUri?: vscode.Uri) => untranslatedCmds.translateAllUntranslatedInFile(documentUri),\n            ),\n            vscode.commands.registerCommand(\n                'ai-localizer.i18n.translateAllUntranslatedInProject',\n                () => untranslatedCmds.translateAllUntranslatedInProject(),\n            ),\n            vscode.commands.registerCommand(\n                'ai-localizer.i18n.removeUnusedKeyInFile',\n                (documentUri: vscode.Uri, keyPath: string) =>\n                    untranslatedCmds.removeUnusedKeyInFile(documentUri, keyPath),\n            ),\n            vscode.commands.registerCommand(\n                'ai-localizer.i18n.removeInvalidKeyInFile',\n                (documentUri: vscode.Uri, keyPath: string) =>\n                    untranslatedCmds.removeInvalidKeyInFile(documentUri, keyPath),\n            ),\n            vscode.commands.registerCommand(\n                'ai-localizer.i18n.restoreInvalidKeyInCode',\n                (documentUri: vscode.Uri, position: { line: number; character: number }, key: string) =>\n                    untranslatedCmds.restoreInvalidKeyInCode(documentUri, position, key),\n            ),\n            vscode.commands.registerCommand(\n                'ai-localizer.i18n.fixMissingKeyReference',\n                (documentUri: vscode.Uri, position: { line: number; character: number }, key: string) =>\n                    untranslatedCmds.fixMissingKeyReference(documentUri, position, key),\n            ),\n            vscode.commands.registerCommand(\n                'ai-localizer.i18n.addKeyToIgnoreList',\n                (folderUri: vscode.Uri, key: string) =>\n                    untranslatedCmds.addKeyToIgnoreList(folderUri, key),\n            ),\n            vscode.commands.registerCommand(\n                'ai-localizer.i18n.fixPlaceholderMismatch',\n                (documentUri: vscode.Uri, key: string, locale: string) =>\n                    untranslatedCmds.fixPlaceholderMismatch(documentUri, key, locale),\n            ),\n            vscode.commands.registerCommand(\n                'ai-localizer.i18n.gotoTranslationFromHover',\n                async (args: { uri: string; position: { line: number; character: number } }) => {\n                    try {\n                        if (!args || !args.uri || !args.position) {\n                            return;\n                        }\n                        const uri = vscode.Uri.parse(args.uri);\n                        const position = new vscode.Position(\n                            args.position.line,\n                            args.position.character,\n                        );\n                        const locations =\n                            (await vscode.commands.executeCommand(\n                                'vscode.executeDefinitionProvider',\n                                uri,\n                                position,\n                            )) || [];\n                        const first = Array.isArray(locations) && locations.length > 0\n                            ? (locations[0] as vscode.Location)\n                            : undefined;\n                        if (!first) {\n                            return;\n                        }\n                        const doc = await vscode.workspace.openTextDocument(first.uri);\n                        const editor = await vscode.window.showTextDocument(doc, {\n                            preview: false,\n                        });\n                        editor.selection = new vscode.Selection(first.range.start, first.range.start);\n                        editor.revealRange(\n                            first.range,\n                            vscode.TextEditorRevealType.InCenterIfOutsideViewport,\n                        );\n                    } catch (err) {\n                        console.error('AI Localizer: Failed to go to translation from hover:', err);\n                    }\n                },\n            ),\n        );\n\n        // Component commands\n        const componentCmds = new ComponentCommands(this.context, this.fileSystemService);\n        const scaffoldMessagesCmd = new ScaffoldMessagesCommand(this.context);\n        disposables.push(\n            vscode.commands.registerCommand('ai-localizer.i18n.openRootApp', () =>\n                componentCmds.openRootApp(),\n            ),\n            vscode.commands.registerCommand('ai-localizer.i18n.copyLanguageSwitcher', () =>\n                componentCmds.copyLanguageSwitcher(),\n            ),\n            vscode.commands.registerCommand('ai-localizer.i18n.scaffoldMessagesLoader', () =>\n                scaffoldMessagesCmd.execute(),\n            ),\n        );\n\n        // API Key command\n        disposables.push(\n            vscode.commands.registerCommand('ai-localizer.setOpenAiApiKeySecret', async () => {\n                const existing = (await this.context.secrets.get('openaiApiKey')) || '';\n                const input = await vscode.window.showInputBox({\n                    prompt: 'Enter your OpenAI API key to store securely',\n                    ignoreFocusOut: true,\n                    value: existing,\n                    password: true,\n                });\n                if (!input) {\n                    return;\n                }\n                await this.translationService.setApiKey(input);\n                vscode.window.showInformationMessage('AI Localizer: OpenAI API key stored securely.');\n            }),\n        );\n\n        const folders = vscode.workspace.workspaceFolders || [];\n        const globalCfg = vscode.workspace.getConfiguration('ai-localizer');\n        const localeGlobs =\n            globalCfg.get<string[]>('i18n.localeGlobs') || [\n                'resources/js/i18n/auto/**/*.json',\n                'src/i18n/**/*.json',\n                'src/locales/**/*.json',\n                'locales/**/*.json',\n                '**/locales/**/*.json',\n                'i18n/**/*.json',\n                'lang/**/*.php',\n                'resources/lang/**/*.php',\n                '**/Resources/**/*.resx',\n                '**/locale/*/LC_MESSAGES/*.po',\n                '**/locales/*/LC_MESSAGES/*.po',\n                '**/translations/*/LC_MESSAGES/*.po',\n            ];\n\n        const sourceIncludeGlobs =\n            globalCfg.get<string[]>('i18n.sourceGlobs') || [\n                '**/*.{ts,tsx,js,jsx,vue,php,cs,py,go}',\n                '**/*.blade.php',\n                '**/*.{cshtml,razor}',\n            ];\n        const sourceExcludeGlobs =\n            globalCfg.get<string[]>('i18n.sourceExcludeGlobs') || [\n                '**/node_modules/**',\n                '**/.git/**',\n                '**/dist/**',\n                '**/build/**',\n                '**/.next/**',\n                '**/.nuxt/**',\n                '**/.vite/**',\n                '**/coverage/**',\n                '**/out/**',\n                '**/.turbo/**',\n                '**/vendor/**',\n            ];\n\n        const collectSourceFileUris = async (): Promise<vscode.Uri[]> => {\n            const diagConfig = getDiagnosticConfig();\n            const verbose = diagConfig.verboseLogging === true;\n            const exclude =\n                sourceExcludeGlobs.length > 0 ? `{${sourceExcludeGlobs.join(',')}}` : undefined;\n\n            const seen = new Set<string>();\n            const uris: vscode.Uri[] = [];\n\n            const includes = sourceIncludeGlobs.length > 0 ? sourceIncludeGlobs : [];\n\n            for (const include of includes) {\n                try {\n                    const found = await vscode.workspace.findFiles(include, exclude);\n                    for (const uri of found) {\n                        const key = uri.toString();\n                        if (!seen.has(key)) {\n                            seen.add(key);\n                            uris.push(uri);\n                        }\n                    }\n                } catch {\n                    // Ignore glob errors for individual patterns\n                }\n            }\n\n            if (verbose) {\n                this.log.appendLine(\n                    `[Diagnostics] Collected ${uris.length} source file(s) for missing reference scan.`,\n                );\n            }\n            return uris;\n        };\n\n        const handleLocaleChange = async (uri: vscode.Uri) => {\n            const currentOp = operationLock.getCurrentOperation();\n            const isBulkOp =\n                currentOp &&\n                ['key-management', 'translation-project', 'translation-file', 'cleanup-unused', 'cleanup-invalid', 'style-fix'].includes(\n                    currentOp.type,\n                );\n\n            if (isBulkOp) {\n                // Skip locale change handling while bulk ops are running\n                return;\n            }\n            const diagConfig = getDiagnosticConfig();\n            const verbose = diagConfig.verboseLogging === true;\n            if (verbose) {\n                this.log.appendLine(`[Watch] Locale file change detected: ${uri.fsPath}`);\n            }\n\n            const beforeInfo = this.i18nIndex.getKeysForFile(uri);\n            const beforeKeys = beforeInfo?.keys || [];\n\n            await this.i18nIndex.updateFile(uri);\n\n            const afterInfo = this.i18nIndex.getKeysForFile(uri);\n            const afterKeys = afterInfo?.keys || [];\n\n            const changedKeySet = new Set<string>();\n            for (const k of beforeKeys) changedKeySet.add(k);\n            for (const k of afterKeys) changedKeySet.add(k);\n\n            if (verbose) {\n                this.log.appendLine(\n                    `[Watch] Keys changed in ${uri.fsPath}: ` +\n                    `Before: ${beforeKeys.length}, After: ${afterKeys.length}, Changed set: ${changedKeySet.size}`\n                );\n            }\n\n            // Always include the changed file itself so its diagnostics are cleared/updated.\n            const impactedUriStrings = new Set<string>([uri.toString()]);\n\n            // For each changed key, re-analyze all locale files that contain that key.\n            for (const key of changedKeySet) {\n                const record = this.i18nIndex.getRecord(key);\n                if (!record) {\n                    if (verbose) {\n                        this.log.appendLine(`[Watch] Key ${key} not found in index (deleted from all locales)`);\n                    }\n                    continue;\n                }\n                \n                // Always include default locale file for this key\n                const defaultLocale = record.defaultLocale;\n                const defaultLoc = record.locations.find(l => l.locale === defaultLocale);\n                if (defaultLoc) {\n                    impactedUriStrings.add(defaultLoc.uri.toString());\n                }\n                \n                // Include all other locales where this key appears\n                for (const loc of record.locations) {\n                    impactedUriStrings.add(loc.uri.toString());\n                }\n                \n                if (verbose) {\n                    this.log.appendLine(\n                        `[Watch] Key '${key}' impacts ${record.locations.length} locale file(s)`\n                    );\n                }\n            }\n\n            const impactedUris = Array.from(impactedUriStrings).map((s) => vscode.Uri.parse(s));\n            if (verbose) {\n                this.log.appendLine(\n                    `[Watch] Recomputing diagnostics for ${impactedUris.length} locale file(s) ` +\n                        `due to change in ${uri.fsPath}.`,\n                );\n            }\n\n            const extraKeys = Array.from(changedKeySet);\n            for (const targetUri of impactedUris) {\n                if (verbose) {\n                    this.log.appendLine(`[Watch] Analyzing impacted file: ${targetUri.fsPath}`);\n                }\n                await this.refreshFileDiagnostics(untranslatedDiagnostics, targetUri, extraKeys);\n            }\n        };\n\n        const isSourceFile = (languageId: string): boolean => {\n            return [\n                'typescript',\n                'typescriptreact',\n                'javascript',\n                'javascriptreact',\n                'vue',\n                'php',\n                'blade',\n                'csharp',\n                'razor',\n                'python',\n            ].includes(languageId);\n        };\n\n        // Debounce map for source file analysis\n        const sourceFileDebounceTimers = new Map<string, NodeJS.Timeout>();\n        const SOURCE_FILE_DEBOUNCE_MS = 500;\n\n        const refreshSourceFileDiagnostics = async (document: vscode.TextDocument, immediate = false) => {\n            const currentOp = operationLock.getCurrentOperation();\n            if (currentOp?.type === 'key-management') {\n                // Skip source diagnostics refresh while bulk key management is running\n                return;\n            }\n            if (!isSourceFile(document.languageId)) {\n                return;\n            }\n\n            const config = getDiagnosticConfig();\n            if (!config.enabled || !config.missingReferenceEnabled) {\n                sourceFileDiagnostics.delete(document.uri);\n                return;\n            }\n\n            const uriKey = document.uri.toString();\n\n            // Clear existing timer\n            const existingTimer = sourceFileDebounceTimers.get(uriKey);\n            if (existingTimer) {\n                clearTimeout(existingTimer);\n            }\n\n            const doAnalysis = async () => {\n                sourceFileDebounceTimers.delete(uriKey);\n                const diagnostics = await this.diagnosticAnalyzer.analyzeSourceFile(document.uri, config);\n                sourceFileDiagnostics.set(document.uri, diagnostics);\n            };\n\n            if (immediate) {\n                await doAnalysis();\n            } else {\n                // Debounce to avoid analyzing on every keystroke\n                const timer = setTimeout(() => {\n                    void doAnalysis();\n                }, SOURCE_FILE_DEBOUNCE_MS);\n                sourceFileDebounceTimers.set(uriKey, timer);\n            }\n        };\n\n        // Enhanced locale change handler that also refreshes source file diagnostics\n        const enhancedHandleLocaleChange = async (uri: vscode.Uri) => {\n            await handleLocaleChange(uri);\n            // After locale files change, refresh diagnostics for all open source files\n            for (const editor of vscode.window.visibleTextEditors) {\n                if (isSourceFile(editor.document.languageId)) {\n                    await refreshSourceFileDiagnostics(editor.document);\n                }\n            }\n        };\n\n        const refreshAllSourceDiagnostics = async (): Promise<void> => {\n            if (refreshAllSourceDiagnosticsPromise) {\n                await refreshAllSourceDiagnosticsPromise;\n                return;\n            }\n\n            refreshAllSourceDiagnosticsPromise = (async () => {\n                const config = getDiagnosticConfig();\n                if (!config.enabled || !config.missingReferenceEnabled) {\n                    sourceFileDiagnostics.clear();\n                    return;\n                }\n                const verbose = config.verboseLogging === true;\n\n                await this.i18nIndex.ensureInitialized();\n                const uris = await collectSourceFileUris();\n                if (verbose) {\n                    this.log.appendLine(\n                    `[Diagnostics] Scanning ${uris.length} source file(s) for missing translation key references...`,\n                    );\n                }\n\n                const results: { uri: vscode.Uri; diagnostics: vscode.Diagnostic[] }[] = new Array(uris.length);\n\n                const concurrency = Math.max(\n                    1,\n                    Number(process.env.AI_I18N_SOURCE_DIAG_CONCURRENCY || 8),\n                );\n                let index = 0;\n\n                const worker = async () => {\n                    while (true) {\n                        const current = index;\n                        index += 1;\n                        if (current >= uris.length) {\n                            break;\n                        }\n                        const uri = uris[current];\n                        const diagnostics = await this.diagnosticAnalyzer.analyzeSourceFile(uri, config);\n                        results[current] = { uri, diagnostics };\n                    }\n                };\n\n                const workerCount = Math.min(concurrency, uris.length);\n                const workers: Promise<void>[] = [];\n                for (let i = 0; i < workerCount; i += 1) {\n                    workers.push(worker());\n                }\n                await Promise.all(workers);\n\n                sourceFileDiagnostics.clear();\n                for (const result of results) {\n                    if (!result) continue;\n                    sourceFileDiagnostics.set(result.uri, result.diagnostics);\n                }\n            })();\n\n            try {\n                await refreshAllSourceDiagnosticsPromise;\n            } finally {\n                refreshAllSourceDiagnosticsPromise = null;\n            }\n        };\n\n        // Review file IntelliSense (Ctrl+Click navigation)\n        disposables.push(\n            vscode.languages.registerDefinitionProvider(reviewDocumentSelector, {\n                provideDefinition: (document, position) => reviewService.provideDefinition(document, position),\n            }),\n            vscode.languages.registerDocumentLinkProvider(reviewDocumentSelector, {\n                provideDocumentLinks: (document, token) => reviewService.provideDocumentLinks(document, token),\n            }),\n        );\n\n        // Register watchers ONCE with the enhanced handler (avoids duplicate registrations)\n        for (const folder of folders) {\n            for (const glob of localeGlobs) {\n                const pattern = new vscode.RelativePattern(folder, glob);\n                const watcher = vscode.workspace.createFileSystemWatcher(pattern);\n                watcher.onDidChange(enhancedHandleLocaleChange, undefined, disposables);\n                watcher.onDidCreate(enhancedHandleLocaleChange, undefined, disposables);\n                watcher.onDidDelete(enhancedHandleLocaleChange, undefined, disposables);\n                disposables.push(watcher);\n            }\n\n            // Watch review-generated file\n            const reviewWatcher = vscode.workspace.createFileSystemWatcher(\n                new vscode.RelativePattern(folder, 'scripts/.i18n-review-generated.json'),\n            );\n            const refreshReview = async () => {\n                await reviewService.refreshDiagnostics(folder, reviewDiagnostics);\n            };\n            reviewWatcher.onDidChange(refreshReview, undefined, disposables);\n            reviewWatcher.onDidCreate(refreshReview, undefined, disposables);\n            reviewWatcher.onDidDelete(() => reviewDiagnostics.clear(), undefined, disposables);\n            disposables.push(reviewWatcher);\n        }\n\n        void this.refreshAllDiagnostics(untranslatedDiagnostics);\n        void refreshAllSourceDiagnostics();\n        \n        // Cleanup debounce timers on dispose\n        disposables.push({\n            dispose: () => {\n                for (const timer of sourceFileDebounceTimers.values()) {\n                    clearTimeout(timer);\n                }\n                sourceFileDebounceTimers.clear();\n            },\n        });\n\n        // Refresh diagnostics when source files are opened (immediate)\n        disposables.push(\n            vscode.workspace.onDidOpenTextDocument(async (document) => {\n                await refreshSourceFileDiagnostics(document, true);\n            }),\n        );\n\n        // Refresh diagnostics when source files are changed (debounced)\n        disposables.push(\n            vscode.workspace.onDidChangeTextDocument(async (event) => {\n                await refreshSourceFileDiagnostics(event.document, false);\n            }),\n        );\n\n        // Refresh diagnostics when source files are saved (immediate)\n        disposables.push(\n            vscode.workspace.onDidSaveTextDocument(async (document) => {\n                // If review file saved, apply changes and refresh diagnostics\n                if (document.uri.fsPath.endsWith(`${path.sep}scripts${path.sep}.i18n-review-generated.json`)) {\n                    const folder = vscode.workspace.getWorkspaceFolder(document.uri);\n                    if (folder) {\n                        await reviewService.applyReviewFile(folder, document);\n                        await reviewService.refreshDiagnostics(folder, reviewDiagnostics);\n                    }\n                    return;\n                }\n                await refreshSourceFileDiagnostics(document, true);\n            }),\n        );\n\n        // Clear diagnostics when source files are closed\n        disposables.push(\n            vscode.workspace.onDidCloseTextDocument((document) => {\n                if (isSourceFile(document.languageId)) {\n                    sourceFileDiagnostics.delete(document.uri);\n                }\n            }),\n        );\n\n        // Register command to manually refresh source file diagnostics\n        disposables.push(\n            vscode.commands.registerCommand('ai-localizer.i18n.refreshSourceFileDiagnostics', async () => {\n                for (const editor of vscode.window.visibleTextEditors) {\n                    await refreshSourceFileDiagnostics(editor.document);\n                }\n            }),\n        );\n\n        // Analyze currently open source files (immediate)\n        for (const editor of vscode.window.visibleTextEditors) {\n            if (isSourceFile(editor.document.languageId)) {\n                void refreshSourceFileDiagnostics(editor.document, true);\n            }\n        }\n\n        } catch (error) {\n            console.error('Failed to register commands:', error);\n            const details =\n                error instanceof Error ? error.stack || error.message : String(error);\n            this.log.appendLine(`[CommandRegistry] Failed to register commands: ${details}`);\n            vscode.window.showErrorMessage(`AI Localizer: Failed to register commands. ${error}`);\n            throw error;\n        }\n\n        return disposables;\n    }\n\n    /**\n     * Refresh diagnostics for a single file (incremental update).\n     */\n    private async refreshFileDiagnostics(\n        collection: vscode.DiagnosticCollection,\n        uri: vscode.Uri,\n        extraKeys?: string[],\n        options?: { force?: boolean },\n    ): Promise<void> {\n        const currentOp = operationLock.getCurrentOperation();\n        const shouldDebounce =\n            currentOp &&\n            !options?.force &&\n            ['key-management', 'translation-project', 'translation-file', 'cleanup-unused', 'cleanup-invalid', 'style-fix'].includes(\n                currentOp.type,\n            );\n\n        const uriKey = uri.toString();\n\n        if (shouldDebounce) {\n            const existing = this.localeDiagnosticsDebounce.get(uriKey);\n            if (existing) {\n                clearTimeout(existing);\n            }\n            const timer = setTimeout(() => {\n                this.localeDiagnosticsDebounce.delete(uriKey);\n                void this.refreshFileDiagnostics(collection, uri, extraKeys, { force: true });\n            }, CommandRegistry.LOCALE_DIAG_DEBOUNCE_MS);\n            this.localeDiagnosticsDebounce.set(uriKey, timer);\n            return;\n        }\n\n        const config = getDiagnosticConfig();\n        if (!config.enabled) {\n            collection.delete(uri);\n            return;\n        }\n\n        const folders = vscode.workspace.workspaceFolders || [];\n        await this.diagnosticAnalyzer.loadStyleReport(folders);\n        await this.diagnosticAnalyzer.loadIgnorePatterns(folders);\n\n        // Invalidate stale untranslated report entries for changed keys\n        // This ensures that manually edited translations are re-evaluated\n        // against the actual values rather than stale report data\n        if (extraKeys && extraKeys.length > 0) {\n            this.diagnosticAnalyzer.invalidateUntranslatedReportKeys(extraKeys);\n        }\n\n        const diagnostics = await this.diagnosticAnalyzer.analyzeFile(uri, config, extraKeys);\n        // Deduplicate diagnostics (sometimes multiple analyzers report the same issue)\n        const seen = new Set<string>();\n        const deduped = diagnostics.filter((d) => {\n            const key = `${d.range.start.line}:${d.range.start.character}:${d.message}`;\n            if (seen.has(key)) return false;\n            seen.add(key);\n            return true;\n        });\n        collection.set(uri, deduped);\n    }\n\n    /**\n     * Refresh diagnostics for all locale files (full refresh).\n     */\n    private async refreshAllDiagnostics(\n        collection: vscode.DiagnosticCollection,\n        options?: { force?: boolean },\n    ): Promise<void> {\n        const currentOp = operationLock.getCurrentOperation();\n        if (currentOp?.type === 'key-management' && !options?.force) {\n            // Skip full diagnostics refresh while bulk key management runs\n            return;\n        }\n        if (this.refreshAllDiagnosticsPromise) {\n            await this.refreshAllDiagnosticsPromise;\n            return;\n        }\n\n        this.refreshAllDiagnosticsPromise = (async () => {\n        this.diagnosticAnalyzer.resetCaches();\n        await this.i18nIndex.ensureInitialized();\n\n        const config = getDiagnosticConfig();\n        if (!config.enabled) {\n            collection.clear();\n            this.log.appendLine('[Diagnostics] Diagnostics disabled; clearing.');\n            return;\n        }\n\n        const allKeys = this.i18nIndex.getAllKeys();\n        if (!allKeys.length) {\n            collection.clear();\n            this.log.appendLine(\n                '[Diagnostics] No translation keys found in index; clearing diagnostics.',\n            );\n            return;\n        }\n\n        this.log.appendLine(\n            `[Diagnostics] Found ${allKeys.length} translation key(s) in index.`,\n        );\n\n        const folders = vscode.workspace.workspaceFolders || [];\n        await this.diagnosticAnalyzer.loadStyleReport(folders, true);\n        await this.diagnosticAnalyzer.loadIgnorePatterns(folders, true);\n        await this.diagnosticAnalyzer.loadUntranslatedReport(folders, true);\n\n        const diagnosticMap = await this.diagnosticAnalyzer.analyzeAll(config);\n\n        collection.clear();\n        for (const [uriString, diagnostics] of diagnosticMap) {\n            collection.set(vscode.Uri.parse(uriString), diagnostics);\n        }\n\n        this.log.appendLine(\n            `[Diagnostics] Updated diagnostics for ${diagnosticMap.size} locale file(s).`,\n        );\n        })();\n\n        try {\n            await this.refreshAllDiagnosticsPromise;\n        } finally {\n            this.refreshAllDiagnosticsPromise = null;\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\componentCommands.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isReact' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":109,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":109,"endColumn":20},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":194,"column":32,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":194,"endColumn":39,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[7295,7296],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":231,"column":32,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":231,"endColumn":39,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[9344,9345],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\r\nimport * as path from 'path';\r\nimport { FileSystemService } from '../services/fileSystemService';\r\nimport { pickWorkspaceFolder, workspaceLooksTypeScript } from '../core/workspace';\r\nimport { ensureReactI18nRuntime } from '../core/reactRuntime';\r\nimport { ensureVueI18nRuntime } from '../core/vueRuntime';\r\nimport { detectFrameworkProfile } from '../frameworks/detection';\r\n\r\n/**\r\n * Commands for managing i18n components\r\n */\r\nexport class ComponentCommands {\r\n    constructor(\r\n        private context: vscode.ExtensionContext,\r\n        private fileSystemService: FileSystemService,\r\n    ) {}\r\n\r\n    async openRootApp(): Promise<void> {\r\n        const active = vscode.window.activeTextEditor;\r\n        let folder = active\r\n            ? vscode.workspace.getWorkspaceFolder(active.document.uri) ?? undefined\r\n            : undefined;\r\n        \r\n        if (!folder) {\r\n            folder = await pickWorkspaceFolder();\r\n        }\r\n\r\n        if (!folder) {\r\n            vscode.window.showInformationMessage('AI Localizer: No workspace folder available.');\r\n            return;\r\n        }\r\n\r\n        const profile = await detectFrameworkProfile(folder);\r\n        const patterns = profile?.entryPatterns || [\r\n            'resources/js/app.tsx',\r\n            'resources/js/app.jsx',\r\n            'src/main.tsx',\r\n            'src/main.jsx',\r\n            'src/index.tsx',\r\n            'src/index.jsx',\r\n        ];\r\n\r\n        const found: vscode.Uri[] = [];\r\n        for (const rel of patterns) {\r\n            const matches = await this.fileSystemService.findFiles(folder, rel, undefined, 1);\r\n            if (matches.length > 0) {\r\n                found.push(matches[0]);\r\n            }\r\n        }\r\n\r\n        if (found.length === 0) {\r\n            vscode.window.showInformationMessage(\r\n                'AI Localizer: Could not find an entry file in this workspace.',\r\n            );\r\n            return;\r\n        }\r\n\r\n        let target = found[0];\r\n        if (found.length > 1) {\r\n            const ws = folder as vscode.WorkspaceFolder;\r\n            const items = found.map((uri) => ({\r\n                label: path.relative(ws.uri.fsPath, uri.fsPath),\r\n                uri,\r\n            }));\r\n            const selection = await vscode.window.showQuickPick(items, {\r\n                placeHolder: 'Select the root entry file to open',\r\n            });\r\n            if (!selection) {\r\n                return;\r\n            }\r\n            target = selection.uri;\r\n        }\r\n\r\n        const doc = await vscode.workspace.openTextDocument(target);\r\n        await vscode.window.showTextDocument(doc, { preview: false });\r\n    }\r\n\r\n    async copyLanguageSwitcher(): Promise<void> {\r\n        const active = vscode.window.activeTextEditor;\r\n        let folder = active\r\n            ? vscode.workspace.getWorkspaceFolder(active.document.uri) ?? undefined\r\n            : undefined;\r\n        \r\n        if (!folder) {\r\n            folder = await pickWorkspaceFolder();\r\n        }\r\n\r\n        if (!folder) {\r\n            vscode.window.showInformationMessage('AI Localizer: No workspace folder available.');\r\n            return;\r\n        }\r\n\r\n        const looksTs = await workspaceLooksTypeScript(folder);\r\n        const profile = await detectFrameworkProfile(folder);\r\n\r\n        let isVue = profile?.kind === 'vue' || profile?.kind === 'nuxt';\r\n        let isReact = profile?.kind === 'react' || (!isVue && profile?.kind !== 'laravel');\r\n\r\n        if (profile?.kind === 'laravel') {\r\n            const pick = await vscode.window.showQuickPick(\r\n                [\r\n                    { label: 'React', description: 'Inertia React or React SPA' },\r\n                    { label: 'Vue', description: 'Inertia Vue or Vue SPA' },\r\n                ],\r\n                { placeHolder: 'Laravel detected. Generate a React or Vue LanguageSwitcher?' },\r\n            );\r\n            if (!pick) return;\r\n            isVue = pick.label === 'Vue';\r\n            isReact = pick.label === 'React';\r\n        }\r\n\r\n        const targetFileName = isVue ? 'LanguageSwitcher.vue' : `LanguageSwitcher.${looksTs ? 'tsx' : 'jsx'}`;\r\n        const preferredDirs = isVue && profile?.kind === 'nuxt'\r\n            ? ['components', 'src/components']\r\n            : ['resources/js/components', 'src/components'];\r\n        const suggestions = await this.fileSystemService.suggestFilePaths(\r\n            folder,\r\n            targetFileName,\r\n            preferredDirs,\r\n            3,\r\n        );\r\n\r\n        let relativePathInput: string | undefined;\r\n\r\n        if (suggestions.length === 1) {\r\n            const input = await vscode.window.showInputBox({\r\n                value: suggestions[0],\r\n                prompt: 'Enter relative path for the LanguageSwitcher component',\r\n            });\r\n            if (!input) {\r\n                return;\r\n            }\r\n            relativePathInput = input;\r\n        } else {\r\n            const items = suggestions.map((p) => ({\r\n                label: p,\r\n                description: 'Suggested location',\r\n                value: p,\r\n            } as vscode.QuickPickItem & { value: string }));\r\n            items.push({\r\n                label: 'Custom location...',\r\n                description: 'Enter a custom component path',\r\n                value: '',\r\n            } as vscode.QuickPickItem & { value: string });\r\n\r\n            const pick = await vscode.window.showQuickPick(items, {\r\n                placeHolder: 'Select target path for the LanguageSwitcher component',\r\n            });\r\n            if (!pick) {\r\n                return;\r\n            }\r\n            if ((pick as any).value) {\r\n                relativePathInput = (pick as any).value as string;\r\n            } else {\r\n                const input = await vscode.window.showInputBox({\r\n                    value: suggestions[0],\r\n                    prompt: 'Enter relative path for the LanguageSwitcher component',\r\n                });\r\n                if (!input) {\r\n                    return;\r\n                }\r\n                relativePathInput = input;\r\n            }\r\n        }\r\n\r\n        const relativePath = relativePathInput.replace(/^[\\\\/]+/, '');\r\n        const targetUri = vscode.Uri.file(path.join(folder.uri.fsPath, relativePath));\r\n        \r\n        const exists = await this.fileSystemService.fileExists(targetUri);\r\n        if (exists) {\r\n            const choice = await vscode.window.showQuickPick(\r\n                [\r\n                    { label: 'Overwrite', description: `Replace existing ${relativePath}` },\r\n                    { label: 'Cancel', description: 'Keep existing file' },\r\n                ],\r\n                { placeHolder: `File ${relativePath} already exists` },\r\n            );\r\n            if (!choice || choice.label !== 'Overwrite') {\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (isVue) {\r\n            const templateFileName = 'LanguageSwitcher.vue';\r\n            const src = vscode.Uri.joinPath(\r\n                this.context.extensionUri,\r\n                'src',\r\n                'i18n',\r\n                'components',\r\n                'vue',\r\n                templateFileName,\r\n            );\r\n            await this.fileSystemService.copyFileWithTransform(src, targetUri, (text) => {\r\n                const wsRoot = folder!.uri.fsPath;\r\n                const compDirAbs = path.dirname(targetUri.fsPath);\r\n                // Determine base root for Vue projects\r\n                let vueBaseRoot: string;\r\n                if (profile?.kind === 'laravel') {\r\n                    vueBaseRoot = path.join(wsRoot, 'resources', 'js');\r\n                } else if (profile?.kind === 'nuxt') {\r\n                    // Nuxt composables are typically at project root\r\n                    vueBaseRoot = wsRoot;\r\n                } else {\r\n                    vueBaseRoot = path.join(wsRoot, (profile?.rootDir || 'src'));\r\n                }\r\n                const relI18n = path.relative(compDirAbs, path.join(vueBaseRoot, 'i18n')).replace(/\\\\/g, '/');\r\n                const relComposable = path.relative(compDirAbs, path.join(vueBaseRoot, 'composables', 'useTranslation')).replace(/\\\\/g, '/');\r\n                return text\r\n                    .replace(/'@\\/i18n'/g, `'${relI18n}'`)\r\n                    .replace(/\"@\\/i18n\"/g, `\"${relI18n}\"`)\r\n                    .replace(/'@\\/composables\\/useTranslation'/g, `'${relComposable}'`)\r\n                    .replace(/\"@\\/composables\\/useTranslation\"/g, `\"${relComposable}\"`);\r\n            });\r\n\r\n            const doc = await vscode.workspace.openTextDocument(targetUri);\r\n            await vscode.window.showTextDocument(doc, { preview: false });\r\n\r\n            await ensureVueI18nRuntime(this.context, folder);\r\n        } else {\r\n            const useTsx = relativePath.toLowerCase().endsWith('.tsx') || (!relativePath.toLowerCase().endsWith('.jsx') && looksTs);\r\n            const templateFileName = useTsx ? 'LanguageSwitcher.tsx' : 'LanguageSwitcher.jsx';\r\n            const src = vscode.Uri.joinPath(\r\n                this.context.extensionUri,\r\n                'src',\r\n                'i18n',\r\n                'components',\r\n                'react',\r\n                templateFileName,\r\n            );\r\n            await this.fileSystemService.copyFileWithTransform(src, targetUri, (text) => {\r\n                const wsRoot = folder!.uri.fsPath;\r\n                const compDirAbs = path.dirname(targetUri.fsPath);\r\n                let reactBaseRoot: string;\r\n                if (profile?.kind === 'react' && profile?.flavor === 'inertia-react') {\r\n                    reactBaseRoot = path.join(wsRoot, 'resources', 'js');\r\n                } else if (profile?.kind === 'laravel') {\r\n                    // User chose React in a Laravel app\r\n                    reactBaseRoot = path.join(wsRoot, 'resources', 'js');\r\n                } else {\r\n                    reactBaseRoot = path.join(wsRoot, (profile?.rootDir || 'src'));\r\n                }\r\n                const relI18n = path.relative(compDirAbs, path.join(reactBaseRoot, 'i18n')).replace(/\\\\/g, '/');\r\n                const relHook = path.relative(compDirAbs, path.join(reactBaseRoot, 'hooks', 'useTranslation')).replace(/\\\\/g, '/');\r\n                return text\r\n                    .replace(/'@\\/i18n'/g, `'${relI18n}'`)\r\n                    .replace(/\"@\\/i18n\"/g, `\"${relI18n}\"`)\r\n                    .replace(/'@\\/hooks\\/useTranslation'/g, `'${relHook}'`)\r\n                    .replace(/\"@\\/hooks\\/useTranslation\"/g, `\"${relHook}\"`);\r\n            });\r\n\r\n            const doc = await vscode.workspace.openTextDocument(targetUri);\r\n            await vscode.window.showTextDocument(doc, { preview: false });\r\n\r\n            await ensureReactI18nRuntime(this.context, folder);\r\n        }\r\n\r\n        vscode.window.showInformationMessage(\r\n            `AI Localizer: LanguageSwitcher component created at ${relativePath}.`,\r\n        );\r\n    }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\configureProjectCommand.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'path' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\r\nimport * as path from 'path';\r\nimport { ProjectConfigService } from '../services/projectConfigService';\r\nimport { FileSystemService } from '../services/fileSystemService';\r\nimport { pickWorkspaceFolder } from '../core/workspace';\r\n\r\n/**\r\n * Command to configure project i18n settings\r\n */\r\nexport class ConfigureProjectCommand {\r\n    constructor(\r\n        private context: vscode.ExtensionContext,\r\n        private projectConfigService: ProjectConfigService,\r\n        private fileSystemService: FileSystemService,\r\n    ) {}\r\n\r\n    async execute(): Promise<void> {\r\n        // Get workspace folder\r\n        const active = vscode.window.activeTextEditor;\r\n        let folder = active\r\n            ? vscode.workspace.getWorkspaceFolder(active.document.uri) ?? undefined\r\n            : undefined;\r\n        \r\n        if (!folder) {\r\n            folder = await pickWorkspaceFolder();\r\n        }\r\n\r\n        if (!folder) {\r\n            vscode.window.showInformationMessage('AI Localizer: No workspace folder available to configure.');\r\n            return;\r\n        }\r\n\r\n        try {\r\n            // Configure scripts\r\n            await this.projectConfigService.configureDefaultScripts(folder);\r\n\r\n            // Prompt for locales\r\n            const locales = await this.projectConfigService.promptForLocales();\r\n            if (locales) {\r\n                await this.projectConfigService.updateConfig(folder, { locales });\r\n            }\r\n\r\n            // Prompt for source root\r\n            const config = await this.projectConfigService.readConfig(folder);\r\n            const srcRootAlreadySet = config?.srcRoot && config.srcRoot.length > 0;\r\n\r\n            if (!srcRootAlreadySet) {\r\n                const srcRoot = await this.projectConfigService.promptForSrcRoot(folder);\r\n                if (srcRoot) {\r\n                    await this.projectConfigService.updateConfig(folder, { srcRoot });\r\n                }\r\n            }\r\n\r\n            // Prompt for postbuild script\r\n            const currentConfig = await this.projectConfigService.readConfig(folder);\r\n            if (currentConfig && !currentConfig.scripts.postbuild) {\r\n                const choice = await vscode.window.showQuickPick(\r\n                    [\r\n                        { label: 'Yes', description: 'Run i18n sync after build' },\r\n                        { label: 'No', description: 'Leave postbuild unchanged' },\r\n                    ],\r\n                    { placeHolder: 'Wire AI i18n scripts into postbuild?' },\r\n                );\r\n\r\n                if (choice && choice.label === 'Yes') {\r\n                    await this.projectConfigService.updateConfig(folder, {\r\n                        scripts: {\r\n                            postbuild: 'npm run i18n:sync',\r\n                        },\r\n                    });\r\n                }\r\n            }\r\n\r\n            // Copy scripts to project\r\n            await this.fileSystemService.copyScriptsToProject(\r\n                this.context,\r\n                folder.uri.fsPath,\r\n            );\r\n\r\n            // Prompt for OpenAI API key if not already configured so automatic\r\n            // AI translations can work out of the box.\r\n            const existingSecret = (await this.context.secrets.get('openaiApiKey')) || '';\r\n            const cfg = vscode.workspace.getConfiguration('ai-localizer');\r\n            const existingCfgKey = (cfg.get<string>('openaiApiKey') || '').trim();\r\n            if (!existingSecret && !existingCfgKey) {\r\n                const choice = await vscode.window.showInformationMessage(\r\n                    'AI Localizer: To enable automatic AI translations, configure an OpenAI API key. You can obtain a key from https://platform.openai.com/api-keys.',\r\n                    'Enter API key',\r\n                    'Open signup page',\r\n                    'Skip',\r\n                );\r\n\r\n                if (choice === 'Enter API key') {\r\n                    await vscode.commands.executeCommand('ai-localizer.setOpenAiApiKeySecret');\r\n                } else if (choice === 'Open signup page') {\r\n                    await vscode.env.openExternal(\r\n                        vscode.Uri.parse('https://platform.openai.com/api-keys'),\r\n                    );\r\n                }\r\n            }\r\n\r\n            vscode.window.showInformationMessage(\r\n                'AI Localizer: Project i18n scripts and configuration have been set up.',\r\n            );\r\n        } catch (err) {\r\n            console.error('Failed to configure project:', err);\r\n            vscode.window.showErrorMessage(`AI Localizer: Configuration failed. ${err}`);\r\n        }\r\n    }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\convertSelectionCommand.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TemplateLiteralProcessor' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":34},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":165,"column":29,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":165,"endColumn":59},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":167,"column":29,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":167,"endColumn":54},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":306,"column":29,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":306,"endColumn":59},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":308,"column":29,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":308,"endColumn":54},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'reject' is defined but never used. Allowed unused args must match /^_/u.","line":403,"column":51,"nodeType":"Identifier","messageId":"unusedVar","endLine":403,"endColumn":57}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\r\nimport { exec } from 'child_process';\r\nimport { I18nIndex } from '../core/i18nIndex';\r\nimport { TranslationService } from '../services/translationService';\r\nimport { ProjectConfigService } from '../services/projectConfigService';\r\nimport { deriveNamespaceFromFile, deriveRootFromFile, upsertTranslationKey } from '../core/i18nFs';\r\nimport { pickWorkspaceFolder } from '../core/workspace';\r\nimport { SelectionStringDetector } from './untranslated/utils/SelectionStringDetector';\r\nimport { TranslationKeyGenerator } from './untranslated/utils/TranslationKeyGenerator';\r\nimport { FrameworkCodeGenerator } from './untranslated/utils/FrameworkCodeGenerator';\r\nimport { TemplateLiteralProcessor, TemplateInfo } from './untranslated/utils/TemplateLiteralProcessor';\r\n\r\n/**\r\n * Command to convert selected text to translation key\r\n */\r\nexport class ConvertSelectionCommand {\r\n    constructor(\r\n        private context: vscode.ExtensionContext,\r\n        private i18nIndex: I18nIndex,\r\n        private translationService: TranslationService,\r\n        private projectConfigService: ProjectConfigService,\r\n        private untranslatedDiagnostics: vscode.DiagnosticCollection,\r\n    ) {}\r\n\r\n    async execute(): Promise<void> {\r\n        const editor = vscode.window.activeTextEditor;\r\n        if (!editor) {\r\n            vscode.window.showInformationMessage('AI Localizer: No active editor.');\r\n            return;\r\n        }\r\n\r\n        const document = editor.document;\r\n        const langId = document.languageId;\r\n\r\n        // Check if language is supported\r\n        const isJsLike = ['javascript', 'typescript', 'javascriptreact', 'typescriptreact'].includes(langId);\r\n        const isVueLike = langId === 'vue';\r\n        const isBladeLike = langId === 'blade' || langId === 'php';\r\n        const isJsSource = isJsLike && !isVueLike && !isBladeLike;\r\n\r\n        if (!isJsLike && !isVueLike && !isBladeLike) {\r\n            vscode.window.showInformationMessage(\r\n                'AI Localizer: Selection to key is only supported in JavaScript/TypeScript, Vue, and Blade/PHP files.',\r\n            );\r\n            return;\r\n        }\r\n\r\n        // Get selection\r\n        const selection = editor.selection;\r\n        if (selection.isEmpty) {\r\n            vscode.window.showInformationMessage(\r\n                'AI Localizer: Please select the text you want to convert to a translation key.',\r\n            );\r\n            return;\r\n        }\r\n\r\n        const selectedText = document.getText(selection).trim();\r\n        if (!selectedText) {\r\n            vscode.window.showInformationMessage('AI Localizer: Selected text is empty.');\r\n            return;\r\n        }\r\n\r\n        // Detect one or more candidate string segments inside the selection\r\n        const detector = new SelectionStringDetector(document, selection);\r\n        const candidates = detector.findCandidates();\r\n        if (!candidates.length) {\r\n            vscode.window.showInformationMessage(\r\n                'AI Localizer: No translatable strings detected in the current selection.',\r\n            );\r\n            return;\r\n        }\r\n        const hasMultipleCandidates = candidates.length > 1;\r\n\r\n        // Get workspace folder\r\n        const folder =\r\n            vscode.workspace.getWorkspaceFolder(document.uri) || (await pickWorkspaceFolder());\r\n        if (!folder) {\r\n            vscode.window.showInformationMessage('AI Localizer: No workspace folder available.');\r\n            return;\r\n        }\r\n\r\n        const rootName = deriveRootFromFile(folder, document.uri);\r\n\r\n        // Get locales\r\n        const config = vscode.workspace.getConfiguration('ai-localizer');\r\n        const defaultLocale = config.get<string>('i18n.defaultLocale') || 'en';\r\n        \r\n        const projectConfig = await this.projectConfigService.readConfig(folder);\r\n        let locales = projectConfig?.locales || [defaultLocale];\r\n        \r\n        if (!locales.includes(defaultLocale)) {\r\n            locales.unshift(defaultLocale);\r\n        }\r\n\r\n        // Prompt for kind (applies to all selected segments)\r\n        const namespace = deriveNamespaceFromFile(folder, document.uri);\r\n        const kindPick = await vscode.window.showQuickPick(\r\n            TranslationKeyGenerator.getTextKinds(),\r\n            { placeHolder: 'Select the kind of text you are converting to an i18n key' },\r\n        );\r\n\r\n        if (!kindPick) {\r\n            return;\r\n        }\r\n\r\n        const kind = kindPick.label;\r\n\r\n        // Ensure index is warmed so we can reuse known translations\r\n        await this.i18nIndex.ensureInitialized();\r\n        // Single-candidate flow: preserve existing behavior with key confirmation\r\n        if (!hasMultipleCandidates) {\r\n            const single = candidates[0];\r\n\r\n            // For JS source files, support advanced template literal handling\r\n            let sourceText = single.text;\r\n            let templateInfo: TemplateInfo | null = null;\r\n\r\n            if (isJsSource) {\r\n                templateInfo = FrameworkCodeGenerator.analyzeTemplateLiteral(document, single.range);\r\n                if (templateInfo && templateInfo.baseText.trim().length > 0) {\r\n                    sourceText = templateInfo.baseText;\r\n                }\r\n            }\r\n\r\n            const defaultKey = TranslationKeyGenerator.generateKey({\r\n                kind,\r\n                namespace,\r\n                sourceText\r\n            });\r\n\r\n            const finalKey = await vscode.window.showInputBox({\r\n                value: defaultKey,\r\n                prompt: 'Confirm or edit the i18n key',\r\n            });\r\n\r\n            if (!finalKey) {\r\n                return;\r\n            }\r\n\r\n            // Get AI translations\r\n            const targetLocales = locales.filter((l) => l !== defaultLocale);\r\n\r\n            // Reuse known translations for the same base text where possible\r\n            const reuseTranslations = this.i18nIndex.findTranslationsForBaseText(\r\n                sourceText,\r\n                defaultLocale,\r\n            );\r\n            const localesNeedingAi = targetLocales.filter((l) => !reuseTranslations.has(l));\r\n\r\n            const translations = localesNeedingAi.length\r\n                ? await this.translationService.translateToLocales(\r\n                      sourceText,\r\n                      defaultLocale,\r\n                      localesNeedingAi,\r\n                      kind,\r\n                  )\r\n                : new Map<string, string>();\r\n\r\n            const missingLocalesSingle: string[] = [];\r\n            for (const locale of locales) {\r\n                let value: string;\r\n                if (locale === defaultLocale) {\r\n                    value = sourceText;\r\n                } else if (reuseTranslations.has(locale)) {\r\n                    value = reuseTranslations.get(locale)!;\r\n                } else if (translations.has(locale)) {\r\n                    value = translations.get(locale)!;\r\n                } else {\r\n                    value = sourceText;\r\n                    missingLocalesSingle.push(locale);\r\n                }\r\n                await upsertTranslationKey(folder, locale, finalKey, value, { rootName });\r\n            }\r\n\r\n            if (missingLocalesSingle.length) {\r\n                this.reportUntranslatedLocales(document, single.range, finalKey, missingLocalesSingle);\r\n            }\r\n\r\n            // Locale file writes trigger watchers which update index + diagnostics incrementally\r\n\r\n            const edit = new vscode.WorkspaceEdit();\r\n\r\n            if (isBladeLike) {\r\n                const replacement = FrameworkCodeGenerator.generateReplacement({\r\n                    document,\r\n                    range: single.range,\r\n                    key: finalKey\r\n                });\r\n                edit.replace(document.uri, single.range, replacement);\r\n                await vscode.workspace.applyEdit(edit);\r\n                vscode.window.showInformationMessage(\r\n                    `AI Localizer: Created key ${finalKey} for selection.`,\r\n                );\r\n                await this.runSyncIfConfigured(folder);\r\n                return;\r\n            }\r\n\r\n            if (isVueLike) {\r\n                const replacement = FrameworkCodeGenerator.generateReplacement({\r\n                    document,\r\n                    range: single.range,\r\n                    key: finalKey\r\n                });\r\n                edit.replace(document.uri, single.range, replacement);\r\n                await vscode.workspace.applyEdit(edit);\r\n                vscode.window.showInformationMessage(\r\n                    `AI Localizer: Created key ${finalKey} for selection.`,\r\n                );\r\n                await this.runSyncIfConfigured(folder);\r\n                return;\r\n            }\r\n\r\n            // JavaScript/TypeScript - add import if needed and replace\r\n            const tImportPath = FrameworkCodeGenerator.getImportPath(document);\r\n            FrameworkCodeGenerator.addImportIfNeeded(document, edit, tImportPath);\r\n\r\n            const replacement = FrameworkCodeGenerator.generateReplacement({\r\n                document,\r\n                range: single.range,\r\n                key: finalKey,\r\n                templateInfo,\r\n                isJsSource\r\n            });\r\n\r\n            edit.replace(document.uri, single.range, replacement);\r\n            await vscode.workspace.applyEdit(edit);\r\n            vscode.window.showInformationMessage(\r\n                `AI Localizer: Created key ${finalKey} for selection.`,\r\n            );\r\n            await this.runSyncIfConfigured(folder);\r\n            return;\r\n        }\r\n\r\n        // Multi-candidate flow: offer preconfigured suggestions and apply translations in one action\r\n        const multiItems = candidates.map((c, index) => {\r\n            const preview = c.text.length > 80 ? `${c.text.slice(0, 77)}…` : c.text;\r\n            return {\r\n                label: preview || `(text ${index + 1})`,\r\n                description: `Line ${c.range.start.line + 1}`,\r\n                segment: c,\r\n            } as vscode.QuickPickItem & {\r\n                segment: { range: vscode.Range; text: string };\r\n            };\r\n        });\r\n\r\n        const picked = await vscode.window.showQuickPick(multiItems, {\r\n            canPickMany: true,\r\n            placeHolder: 'Select text segments to apply translations to',\r\n        });\r\n\r\n        if (!picked || picked.length === 0) {\r\n            return;\r\n        }\r\n\r\n        const segments = picked.map((p) => (p as any).segment as { range: vscode.Range; text: string });\r\n\r\n        const edit = new vscode.WorkspaceEdit();\r\n\r\n        // JavaScript/TypeScript - ensure import once for all segments\r\n        if (isJsLike && !isVueLike && !isBladeLike) {\r\n            const tImportPath = FrameworkCodeGenerator.getImportPath(document);\r\n            FrameworkCodeGenerator.addImportIfNeeded(document, edit, tImportPath);\r\n        }\r\n\r\n        for (const segment of segments) {\r\n            let sourceText = segment.text;\r\n            let templateInfo: TemplateInfo | null = null;\r\n\r\n            if (isJsSource) {\r\n                templateInfo = FrameworkCodeGenerator.analyzeTemplateLiteral(document, segment.range);\r\n                if (templateInfo && templateInfo.baseText.trim().length > 0) {\r\n                    sourceText = templateInfo.baseText;\r\n                }\r\n            }\r\n\r\n            const key = TranslationKeyGenerator.generateKey({\r\n                kind,\r\n                namespace,\r\n                sourceText\r\n            });\r\n\r\n            const targetLocales = locales.filter((l) => l !== defaultLocale);\r\n\r\n            // Reuse known translations for this segment text where possible\r\n            const reuseTranslations = this.i18nIndex.findTranslationsForBaseText(\r\n                sourceText,\r\n                defaultLocale,\r\n            );\r\n            const localesNeedingAi = targetLocales.filter((l) => !reuseTranslations.has(l));\r\n\r\n            const translations = localesNeedingAi.length\r\n                ? await this.translationService.translateToLocales(\r\n                      sourceText,\r\n                      defaultLocale,\r\n                      localesNeedingAi,\r\n                      kind,\r\n                  )\r\n                : new Map<string, string>();\r\n\r\n            const missingLocalesMulti: string[] = [];\r\n            for (const locale of locales) {\r\n                let value: string;\r\n                if (locale === defaultLocale) {\r\n                    value = sourceText;\r\n                } else if (reuseTranslations.has(locale)) {\r\n                    value = reuseTranslations.get(locale)!;\r\n                } else if (translations.has(locale)) {\r\n                    value = translations.get(locale)!;\r\n                } else {\r\n                    value = sourceText;\r\n                    missingLocalesMulti.push(locale);\r\n                }\r\n                await upsertTranslationKey(folder, locale, key, value, { rootName });\r\n            }\r\n\r\n            if (missingLocalesMulti.length) {\r\n                this.reportUntranslatedLocales(document, segment.range, key, missingLocalesMulti);\r\n            }\r\n\r\n            if (isBladeLike) {\r\n                const replacement = FrameworkCodeGenerator.generateReplacement({\r\n                    document,\r\n                    range: segment.range,\r\n                    key\r\n                });\r\n                edit.replace(document.uri, segment.range, replacement);\r\n            } else if (isVueLike) {\r\n                const replacement = FrameworkCodeGenerator.generateReplacement({\r\n                    document,\r\n                    range: segment.range,\r\n                    key\r\n                });\r\n                edit.replace(document.uri, segment.range, replacement);\r\n            } else {\r\n                const replacement = FrameworkCodeGenerator.generateReplacement({\r\n                    document,\r\n                    range: segment.range,\r\n                    key,\r\n                    templateInfo,\r\n                    isJsSource\r\n                });\r\n                edit.replace(document.uri, segment.range, replacement);\r\n            }\r\n        }\r\n\r\n        // Locale file writes trigger watchers which update index + diagnostics incrementally\r\n        await vscode.workspace.applyEdit(edit);\r\n        vscode.window.showInformationMessage(\r\n            `AI Localizer: Applied translations to ${segments.length} selected text segment(s).`,\r\n        );\r\n        await this.runSyncIfConfigured(folder);\r\n    }\r\n\r\n    private reportUntranslatedLocales(\r\n        document: vscode.TextDocument,\r\n        range: vscode.Range,\r\n        key: string,\r\n        missingLocales: string[],\r\n    ): void {\r\n        if (!missingLocales.length) {\r\n            return;\r\n        }\r\n\r\n        const existing = this.untranslatedDiagnostics.get(document.uri) || [];\r\n        const message = `AI Localizer: Missing translations for ${key} in locales: ${missingLocales.join(\", \")}`;\r\n\r\n        const cfg = vscode.workspace.getConfiguration('ai-localizer');\r\n        const setting = cfg.get<string>('i18n.diagnostics.missingLocaleSeverity') || 'warning';\r\n        const severity = this.mapSeverityFromSetting(setting);\r\n\r\n        const diagnostic = new vscode.Diagnostic(\r\n            range,\r\n            message,\r\n            severity,\r\n        );\r\n        diagnostic.code = 'ai-i18n.untranslated';\r\n        this.untranslatedDiagnostics.set(document.uri, existing.concat(diagnostic));\r\n    }\r\n\r\n    private mapSeverityFromSetting(value: string | undefined): vscode.DiagnosticSeverity {\r\n        switch ((value || '').toLowerCase()) {\r\n            case 'error':\r\n                return vscode.DiagnosticSeverity.Error;\r\n            case 'info':\r\n                return vscode.DiagnosticSeverity.Information;\r\n            case 'hint':\r\n                return vscode.DiagnosticSeverity.Hint;\r\n            case 'warning':\r\n            default:\r\n                return vscode.DiagnosticSeverity.Warning;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Optionally run the i18n sync script after applying translations so\r\n     * non-default locales are kept in sync and can reuse known translations.\r\n     */\r\n    private async runSyncIfConfigured(folder: vscode.WorkspaceFolder): Promise<void> {\r\n        const config = vscode.workspace.getConfiguration('ai-localizer');\r\n        const syncScript = config.get<string>('i18n.syncScript');\r\n        if (syncScript) {\r\n            try {\r\n                await new Promise<void>((resolve, reject) => {\r\n                    exec(syncScript, { cwd: folder.uri.fsPath }, (error: any) => {\r\n                        if (error) {\r\n                            console.warn('Sync script failed:', error);\r\n                            resolve(); // Don't reject, just log warning\r\n                        } else {\r\n                            resolve();\r\n                        }\r\n                    });\r\n                });\r\n            } catch (error) {\r\n                console.warn('Failed to run sync script:', error);\r\n            }\r\n        }\r\n    }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\extractSelectionCommand.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'message' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":63,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":63,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\r\nimport { getParserForFile, ExtractedItem } from '../i18n/lib/parsers';\r\nimport { FRAMEWORK_PREPROCESSORS } from './untranslated/utils/StringPatterns';\r\n\r\nexport class ExtractSelectionCommand {\r\n    async execute(): Promise<void> {\r\n        const editor = vscode.window.activeTextEditor;\r\n        if (!editor) {\r\n            vscode.window.showInformationMessage('AI Localizer: No active editor found.');\r\n            return;\r\n        }\r\n\r\n        const selection = editor.selection;\r\n        if (selection.isEmpty) {\r\n            vscode.window.showInformationMessage('AI Localizer: Please select text to extract translatable strings from.');\r\n            return;\r\n        }\r\n\r\n        const document = editor.document;\r\n        const selectedText = document.getText(selection);\r\n        \r\n        if (!selectedText.trim()) {\r\n            vscode.window.showInformationMessage('AI Localizer: Selected text is empty.');\r\n            return;\r\n        }\r\n\r\n        try {\r\n            await vscode.window.withProgress(\r\n                {\r\n                    location: vscode.ProgressLocation.Notification,\r\n                    title: 'AI Localizer: Extracting translatable strings from selection',\r\n                    cancellable: false,\r\n                },\r\n                async (progress) => {\r\n                    progress.report({ message: 'Analyzing selected text...' });\r\n                    \r\n                    // Get the appropriate parser for the file type\r\n                    const parser = getParserForFile(document.fileName);\r\n                    if (!parser) {\r\n                        vscode.window.showErrorMessage(`AI Localizer: No parser available for ${document.fileName}`);\r\n                        return;\r\n                    }\r\n\r\n                    progress.report({ message: 'Extracting strings...' });\r\n                    \r\n                    // Parse the selected text with framework-aware preprocessing\r\n                    const frameworkKey = normalizeFrameworkName((parser as any).constructor?.getName?.());\r\n                    const preprocessor = FRAMEWORK_PREPROCESSORS[frameworkKey as keyof typeof FRAMEWORK_PREPROCESSORS] || FRAMEWORK_PREPROCESSORS.generic;\r\n                    const parseText = preprocessor(selectedText);\r\n                    \r\n                    const results = parser.parse(parseText);\r\n                    \r\n                    if (results.stats.extracted === 0) {\r\n                        vscode.window.showInformationMessage('AI Localizer: No translatable strings found in selection.');\r\n                        return;\r\n                    }\r\n\r\n                    // Show the extracted strings to the user\r\n                    const extractedStrings = results.items\r\n                        .filter((item: ExtractedItem) => item.type === 'text' || item.type === 'string')\r\n                        .map((item: ExtractedItem) => item.text);\r\n\r\n                    const message = `Found ${results.stats.extracted} translatable string(s) in selection:\\n\\n${extractedStrings.map((s: string, i: number) => `${i + 1}. \"${s}\"`).join('\\n')}`;\r\n                    \r\n                    const choice = await vscode.window.showInformationMessage(\r\n                        `AI Localizer: Extracted ${results.stats.extracted} translatable string(s) from selection.`,\r\n                        'View Results',\r\n                        'Copy to Clipboard',\r\n                        'OK'\r\n                    );\r\n\r\n                    if (choice === 'View Results') {\r\n                        // Create a new document to show the results\r\n                        const resultDocument = await vscode.workspace.openTextDocument({\r\n                            content: `# Extracted Translatable Strings\\n\\n${extractedStrings.map((s: string, i: number) => `${i + 1}. \"${s}\"`).join('\\n')}`,\r\n                            language: 'markdown'\r\n                        });\r\n                        await vscode.window.showTextDocument(resultDocument);\r\n                    } else if (choice === 'Copy to Clipboard') {\r\n                        await vscode.env.clipboard.writeText(extractedStrings.join('\\n'));\r\n                        vscode.window.showInformationMessage('AI Localizer: Extracted strings copied to clipboard.');\r\n                    }\r\n                }\r\n            );\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : String(error);\r\n            vscode.window.showErrorMessage(`AI Localizer: Failed to extract from selection. ${message}`);\r\n        }\r\n    }\r\n}\r\n\r\nfunction normalizeFrameworkName(rawName: string | undefined): string {\r\n    if (!rawName) return 'generic';\r\n    const name = rawName.toLowerCase();\r\n    if (name.includes('vue')) return 'vue';\r\n    if (name.includes('jsx') || name.includes('tsx') || name.includes('react')) return 'jsx';\r\n    if (name.includes('blade') || name.includes('laravel')) return 'blade';\r\n    if (name.includes('svelte')) return 'svelte';\r\n    return 'generic';\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\projectFixCommand.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'path' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":17},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":524,"column":95,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":524,"endColumn":96,"suggestions":[{"messageId":"removeEscape","fix":{"range":[25111,25112],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[25111,25111],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":526,"column":53,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":526,"endColumn":54,"suggestions":[{"messageId":"removeEscape","fix":{"range":[25268,25269],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[25268,25268],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":527,"column":56,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":527,"endColumn":57,"suggestions":[{"messageId":"removeEscape","fix":{"range":[25363,25364],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[25363,25363],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":528,"column":54,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":528,"endColumn":55,"suggestions":[{"messageId":"removeEscape","fix":{"range":[25456,25457],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[25456,25456],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":531,"column":62,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":531,"endColumn":63,"suggestions":[{"messageId":"removeEscape","fix":{"range":[25648,25649],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[25648,25648],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\-.","line":533,"column":53,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":533,"endColumn":54,"suggestions":[{"messageId":"removeEscape","fix":{"range":[25751,25752],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[25751,25751],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":533,"column":61,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":533,"endColumn":62,"suggestions":[{"messageId":"removeEscape","fix":{"range":[25759,25760],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[25759,25759],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\-.","line":533,"column":76,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":533,"endColumn":77,"suggestions":[{"messageId":"removeEscape","fix":{"range":[25774,25775],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[25774,25774],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\nimport * as path from 'path';\nimport { TextEncoder, TextDecoder } from 'util';\nimport { I18nIndex } from '../core/i18nIndex';\nimport { TranslationService } from '../services/translationService';\nimport { ProjectConfigService } from '../services/projectConfigService';\nimport { DiagnosticAnalyzer, getDiagnosticConfig } from '../services/diagnosticAnalyzer';\nimport { pickWorkspaceFolder, runI18nScript } from '../core/workspace';\nimport { getGitStatus, createSnapshotCommit } from '../core/gitMonitor';\nimport { findCommentRanges, isPositionInComment } from './untranslated/utils/commentParser';\n\nconst sharedDecoder = new TextDecoder('utf-8');\nconst sharedEncoder = new TextEncoder();\n\ninterface FileBucket {\n    uri: vscode.Uri;\n    json: Record<string, unknown>;\n    changed: boolean;\n    deletedKeys: string[];\n}\n\ninterface ReportCleanupResult {\n    filesChanged: number;\n    keysRemoved: number;\n}\n\ninterface UnusedReport {\n    generatedAt?: string;\n    baseLocale: string;\n    autoDir: string;\n    unused: Array<{ keyPath: string; baseFileRel: string }>;\n}\n\ninterface InvalidReport {\n    generatedAt?: string;\n    baseLocale: string;\n    autoDir: string;\n    invalid: Array<{ keyPath: string; baseFileRel: string }>;\n}\n\nexport class ProjectFixCommand {\n    constructor(\n        private i18nIndex: I18nIndex,\n        private translationService: TranslationService,\n        private projectConfigService: ProjectConfigService,\n        private diagnosticAnalyzer: DiagnosticAnalyzer,\n    ) {}\n\n    async execute(): Promise<void> {\n        try {\n            const folder = await pickWorkspaceFolder();\n            if (!folder) {\n                vscode.window.showInformationMessage('AI Localizer: No workspace folder available.');\n                return;\n            }\n\n            const hasScripts = await this.projectConfigService.hasI18nScripts(folder);\n            if (!hasScripts) {\n                const setupChoice = await vscode.window.showQuickPick(\n                    [\n                        {\n                            label: 'Configure project i18n and continue',\n                            description: 'Copy scripts into this project and update package.json scripts.',\n                        },\n                        {\n                            label: 'Cancel',\n                            description: 'Do not run project-wide fixes right now.',\n                        },\n                    ],\n                    {\n                        placeHolder:\n                            'AI Localizer: Project i18n scripts are not configured for this workspace. Configure them now?',\n                    },\n                );\n\n                if (!setupChoice || setupChoice.label !== 'Configure project i18n and continue') {\n                    return;\n                }\n\n                await vscode.commands.executeCommand('ai-localizer.i18n.configureProject');\n            }\n\n            const status = await getGitStatus(folder);\n            if (!status.hasGit) {\n                const choice = await vscode.window.showQuickPick(\n                    [\n                        {\n                            label: 'Continue without git snapshot',\n                            description: 'Run project-wide fixes without creating a git commit.',\n                        },\n                        {\n                            label: 'Cancel',\n                            description: 'Do not run project-wide fixes right now.',\n                        },\n                    ],\n                    {\n                        placeHolder:\n                            'AI Localizer: No git repository detected for this workspace. Continue without a snapshot commit?',\n                    },\n                );\n\n                if (!choice || choice.label !== 'Continue without git snapshot') {\n                    return;\n                }\n            } else if (status.isDirty) {\n                const choice = await vscode.window.showQuickPick(\n                    [\n                        {\n                            label: 'Create snapshot commit and continue',\n                            description:\n                                'Stage tracked changes, create a git commit, and then run project-wide i18n fixes.',\n                        },\n                        {\n                            label: 'Continue without snapshot (not recommended)',\n                            description:\n                                'Run project-wide i18n fixes without taking a snapshot git commit first.',\n                        },\n                        {\n                            label: 'Cancel',\n                            description: 'Do not run project-wide fixes right now.',\n                        },\n                    ],\n                    {\n                        placeHolder:\n                            'AI Localizer: Workspace has uncommitted changes. Create a snapshot git commit before running project-wide i18n fixes?',\n                    },\n                );\n\n                if (!choice || choice.label === 'Cancel') {\n                    return;\n                }\n\n                if (choice.label === 'Create snapshot commit and continue') {\n                    const snapshot = await createSnapshotCommit(\n                        folder,\n                        'chore: i18n pre-cleanup snapshot',\n                    );\n                    if (!snapshot.success) {\n                        const message = snapshot.error\n                            ? `AI Localizer: Failed to create git snapshot commit. ${snapshot.error}`\n                            : 'AI Localizer: Failed to create git snapshot commit.';\n                        vscode.window.showErrorMessage(message);\n                        return;\n                    }\n                }\n            }\n\n            const confirm = await vscode.window.showQuickPick(\n                [\n                    {\n                        label: 'Run full project-wide i18n cleanup',\n                        description:\n                            'Run extract, rewrite, sync, cleanup, fix missing references, and AI translation.',\n                    },\n                    {\n                        label: 'Cancel',\n                        description: 'Do not run project-wide fixes right now.',\n                    },\n                ],\n                {\n                    placeHolder:\n                        'AI Localizer: Fix all i18n issues in this project (one-time cleanup)?',\n                },\n            );\n\n            if (!confirm || confirm.label !== 'Run full project-wide i18n cleanup') {\n                return;\n            }\n\n            await vscode.window.withProgress(\n                {\n                    location: vscode.ProgressLocation.Notification,\n                    title: 'AI Localizer: Fixing all i18n issues in project...',\n                    cancellable: true,\n                },\n                async (progress, token) => {\n                    if (token.isCancellationRequested) return;\n\n                    // ═══════════════════════════════════════════════════════════════\n                    // PHASE 1: Extract and rewrite source files\n                    // ═══════════════════════════════════════════════════════════════\n                    progress.report({ message: 'Extracting translatable strings (i18n:extract)...' });\n                    await vscode.commands.executeCommand('ai-localizer.i18n.runExtractScript');\n                    if (token.isCancellationRequested) return;\n\n                    progress.report({ message: 'Rewriting source to use t() calls (i18n:rewrite)...' });\n                    await vscode.commands.executeCommand('ai-localizer.i18n.runRewriteScript');\n                    if (token.isCancellationRequested) return;\n\n                    progress.report({ message: 'Rewriting Blade templates (i18n:rewrite-blade)...' });\n                    await vscode.commands.executeCommand('ai-localizer.i18n.runRewriteBladeScript');\n                    if (token.isCancellationRequested) return;\n\n                    // ═══════════════════════════════════════════════════════════════\n                    // PHASE 2: Initial sync to populate all locales (ONLY sync needed)\n                    // CRITICAL: Use merge-only mode to preserve existing translations\n                    // ═══════════════════════════════════════════════════════════════\n                    progress.report({ message: 'Syncing locales (i18n:sync --merge-only)...' });\n                    // Use merge-only mode to preserve existing translations in other locales\n                    // This prevents deletion of translations when keys are renamed or removed\n                    await runI18nScript('i18n:sync', { folder, extraArgs: ['--merge-only'] });\n                    if (token.isCancellationRequested) return;\n\n                    // ═══════════════════════════════════════════════════════════════\n                    // PHASE 3: Build index and fix missing refs BEFORE cleanup\n                    // This ensures cleanup sees accurate key usage from source files\n                    // ═══════════════════════════════════════════════════════════════\n                    progress.report({ message: 'Building index...' });\n                    await this.i18nIndex.ensureInitialized(true);\n                    if (token.isCancellationRequested) return;\n\n                    progress.report({ message: 'Fixing missing key references (before cleanup)...' });\n                    await this.bulkFixMissingReferences(folder, token, progress);\n                    if (token.isCancellationRequested) return;\n\n                    // Rebuild index after fixing refs so cleanup sees correct usage\n                    await this.i18nIndex.ensureInitialized(true);\n                    if (token.isCancellationRequested) return;\n\n                    // ═══════════════════════════════════════════════════════════════\n                    // PHASE 4: Cleanup unused keys (now sees correct usage)\n                    // ═══════════════════════════════════════════════════════════════\n                    progress.report({ message: 'Scanning for unused translation keys...' });\n                    await runI18nScript('i18n:cleanup-unused', { folder });\n                    if (token.isCancellationRequested) return;\n\n                    progress.report({ message: 'Automatically removing unused keys from all locale files...' });\n                    const unusedResult = await this.applyUnusedReportAcrossLocales(folder, token);\n                    if (unusedResult.keysRemoved > 0) {\n                        console.log(`[ProjectFixCommand] Removed ${unusedResult.keysRemoved} unused key(s) from ${unusedResult.filesChanged} locale file(s)`);\n                    }\n                    if (token.isCancellationRequested) return;\n\n                    // ═══════════════════════════════════════════════════════════════\n                    // PHASE 5: Cleanup invalid/non-translatable keys\n                    // ═══════════════════════════════════════════════════════════════\n                    progress.report({ message: 'Scanning for invalid/non-translatable keys...' });\n                    await runI18nScript('i18n:restore-invalid', { folder });\n                    if (token.isCancellationRequested) return;\n\n                    progress.report({ message: 'Automatically restoring inline strings and removing invalid keys...' });\n                    const invalidResult = await this.applyInvalidReportAcrossLocales(folder, token);\n                    if (invalidResult.keysRemoved > 0) {\n                        console.log(`[ProjectFixCommand] Restored inline strings and removed ${invalidResult.keysRemoved} invalid key(s) from ${invalidResult.filesChanged} locale file(s)`);\n                    }\n                    if (token.isCancellationRequested) return;\n\n                    // ═══════════════════════════════════════════════════════════════\n                    // PHASE 6: Rebuild index and track removed keys\n                    // NOTE: We do NOT re-sync here! Sync would bring back cleaned keys.\n                    // ═══════════════════════════════════════════════════════════════\n                    progress.report({ message: 'Rebuilding index after cleanup...' });\n                    await this.i18nIndex.ensureInitialized(true);\n                    if (token.isCancellationRequested) return;\n\n                    // ═══════════════════════════════════════════════════════════════\n                    // PHASE 7: Final check for remaining issues\n                    // ═══════════════════════════════════════════════════════════════\n                    progress.report({ message: 'Final verification scan...' });\n                    await vscode.commands.executeCommand('ai-localizer.i18n.rescan');\n                    if (token.isCancellationRequested) return;\n\n                    // Re-run missing refs fix in case cleanup created orphans\n                    const postCleanupMissing = await this.scanSourceFilesForMissingRefs(folder);\n                    if (postCleanupMissing.missingReferences > 0) {\n                        progress.report({ message: 'Fixing any orphaned references after cleanup...' });\n                        await this.bulkFixMissingReferences(folder, token, progress);\n                        await this.i18nIndex.ensureInitialized(true);\n                    }\n                    if (token.isCancellationRequested) return;\n\n                    // ═══════════════════════════════════════════════════════════════\n                    // PHASE 8: Automatic cleanup retry loop before AI translation\n                    // ═══════════════════════════════════════════════════════════════\n                    // Automatically resolve any remaining issues instead of prompting user\n                    const maxRetries = 2;\n                    let retryCount = 0;\n                    let remainingUnused = 0;\n                    let remainingMissing = 0;\n                    let prevUnused = -1;\n                    let prevMissing = -1;\n\n                    while (retryCount < maxRetries) {\n                        if (token.isCancellationRequested) return;\n                        \n                        // Re-scan for remaining issues\n                        await runI18nScript('i18n:cleanup-unused', { folder });\n                        remainingUnused = await this.countUnusedKeysFromReport(folder);\n                        const missingRefsResult = await this.scanSourceFilesForMissingRefs(folder);\n                        remainingMissing = missingRefsResult.missingReferences;\n\n                        // If nothing changed from the previous pass, stop to avoid infinite loops\n                        if (remainingUnused === prevUnused && remainingMissing === prevMissing) {\n                            progress.report({ message: 'No progress in last pass; stopping cleanup loop.' });\n                            break;\n                        }\n\n                        // Break if all issues resolved\n                        if (remainingUnused === 0 && remainingMissing === 0) {\n                            progress.report({ message: 'All cleanup issues resolved. Proceeding to AI translation...' });\n                            break;\n                        }\n\n                        retryCount++;\n                        progress.report({ \n                            message: `Retry ${retryCount}/${maxRetries}: Automatically fixing ${remainingUnused} unused key(s) and ${remainingMissing} missing reference(s)...` \n                        });\n\n                        // Remember current state to detect no-progress next iteration\n                        prevUnused = remainingUnused;\n                        prevMissing = remainingMissing;\n\n                        // Fix remaining unused keys\n                        if (remainingUnused > 0) {\n                            await this.applyUnusedReportAcrossLocales(folder, token);\n                            await this.i18nIndex.ensureInitialized(true);\n                        }\n\n                        // Fix remaining missing references\n                        if (remainingMissing > 0) {\n                            await this.bulkFixMissingReferences(folder, token, progress);\n                            await this.i18nIndex.ensureInitialized(true);\n                        }\n                    }\n\n                    // If issues remain after retries, log warning but continue\n                    if (remainingUnused > 0 || remainingMissing > 0) {\n                        const warnMsg = `Warning: ${remainingUnused} unused key(s) and ${remainingMissing} missing reference(s) remain after ${maxRetries} retry attempts. Proceeding with AI translation anyway.`;\n                        progress.report({ message: warnMsg });\n                        console.warn(`[ProjectFixCommand] ${warnMsg}`);\n                    }\n\n                    // ═══════════════════════════════════════════════════════════════\n                    // PHASE 9: AI translation for untranslated strings\n                    // ═══════════════════════════════════════════════════════════════\n                    progress.report({ message: 'Detecting and translating untranslated strings (i18n:fix-untranslated)...' });\n                    await vscode.commands.executeCommand('ai-localizer.i18n.runFixUntranslatedScript');\n                    if (token.isCancellationRequested) return;\n\n                    // ═══════════════════════════════════════════════════════════════\n                    // PHASE 10: Final rebuild and report\n                    // ═══════════════════════════════════════════════════════════════\n                    progress.report({ message: 'Rebuilding translation index and diagnostics...' });\n                    await this.i18nIndex.ensureInitialized(true);\n                    await vscode.commands.executeCommand('ai-localizer.i18n.rescan');\n                    if (token.isCancellationRequested) return;\n\n                    await vscode.commands.executeCommand('ai-localizer.i18n.showHealthReport');\n                },\n            );\n\n            const apiKey = (await this.translationService.getApiKey())?.trim();\n            const translationNote = apiKey\n                ? 'AI translation was enabled for this run.'\n                : 'No OpenAI API key was configured; missing translations were not auto-filled by AI.';\n\n            vscode.window.showInformationMessage(\n                `AI Localizer: Project-wide i18n fix completed for workspace \"${folder.name}\". ${translationNote} Review locale files and git diff as needed.`,\n            );\n        } catch (err) {\n            const msg = err instanceof Error ? err.message : String(err);\n            console.error('AI Localizer: Failed to run project-wide i18n cleanup:', err);\n            vscode.window.showErrorMessage(\n                `AI Localizer: Failed to run project-wide i18n cleanup. ${msg}`,\n            );\n        }\n    }\n\n    private async countUnusedKeysFromReport(folder: vscode.WorkspaceFolder): Promise<number> {\n        const scriptsDir = vscode.Uri.joinPath(folder.uri, 'scripts');\n        const reportUri = vscode.Uri.joinPath(scriptsDir, '.i18n-unused-report.json');\n        try {\n            const data = await vscode.workspace.fs.readFile(reportUri);\n            const report = JSON.parse(sharedDecoder.decode(data)) as UnusedReport;\n            return Array.isArray(report.unused) ? report.unused.length : 0;\n        } catch {\n            return 0;\n        }\n    }\n\n    private async scanSourceFilesForMissingRefs(folder: vscode.WorkspaceFolder): Promise<{\n        missingReferences: number;\n        filesWithMissingRefs: vscode.Uri[];\n    }> {\n        const cfg = vscode.workspace.getConfiguration('ai-localizer');\n        const configuredGlobs = cfg.get<string[]>('i18n.sourceGlobs') || [];\n        const fallbackGlobs = [\n            '**/*.{ts,tsx,js,jsx,mjs,cjs,mts,cts,vue,svelte,php,py,cs,cshtml,razor}',\n            '**/*.blade.php',\n        ];\n        const sourceGlobs = configuredGlobs.length > 0\n            ? Array.from(new Set<string>([...configuredGlobs, ...fallbackGlobs]))\n            : fallbackGlobs;\n        const excludeGlobs = [\n            '**/node_modules/**',\n            '**/.git/**',\n            '**/dist/**',\n            '**/build/**',\n            '**/.next/**',\n            '**/.nuxt/**',\n            '**/.vite/**',\n            '**/coverage/**',\n            '**/out/**',\n            '**/.turbo/**',\n            '**/vendor/**',\n        ];\n        const exclude = excludeGlobs.length > 0 ? `{${excludeGlobs.join(',')}}` : undefined;\n\n        const seen = new Set<string>();\n        const uris: vscode.Uri[] = [];\n        const includes = sourceGlobs.length > 0 ? sourceGlobs : [];\n\n        for (const include of includes) {\n            try {\n                const pattern = new vscode.RelativePattern(folder, include);\n                const found = await vscode.workspace.findFiles(pattern, exclude);\n                for (const uri of found) {\n                    const key = uri.toString();\n                    if (!seen.has(key)) {\n                        seen.add(key);\n                        uris.push(uri);\n                    }\n                }\n            } catch {\n                // Skip invalid glob patterns\n            }\n        }\n\n        // Use the same logic as \"Rescan Translations\" diagnostics to avoid false positives.\n        const config = getDiagnosticConfig();\n        if (!config.enabled || !config.missingReferenceEnabled) {\n            return { missingReferences: 0, filesWithMissingRefs: [] };\n        }\n\n        let missingReferences = 0;\n        const filesWithMissingRefs: vscode.Uri[] = [];\n\n        for (const uri of uris) {\n            if (uri.scheme !== 'file') {\n                continue;\n            }\n            try {\n                const diags = await this.diagnosticAnalyzer.analyzeSourceFile(uri, config);\n                const missing = diags.filter((d) => d.code === 'ai-i18n.missing-reference');\n                if (missing.length > 0) {\n                    missingReferences += missing.length;\n                    filesWithMissingRefs.push(uri);\n                }\n            } catch {\n                // Skip files that can't be analyzed\n            }\n        }\n\n        return { missingReferences, filesWithMissingRefs };\n    }\n\n    /**\n     * Count usages of a translation key in source files.\n     * Used as a safety check before deleting keys from locale files.\n     */\n    private async countKeyUsageInSource(folder: vscode.WorkspaceFolder, key: string): Promise<number> {\n        const usedKeys = await this.buildSourceUsageSet(folder, new Set<string>([key]));\n        return usedKeys.has(key) ? 1 : 0;\n    }\n\n    private async buildSourceUsageSet(\n        folder: vscode.WorkspaceFolder,\n        candidateKeys: Set<string>,\n    ): Promise<Set<string>> {\n        const usedKeys = new Set<string>();\n        if (candidateKeys.size === 0) {\n            return usedKeys;\n        }\n\n        const cfg = vscode.workspace.getConfiguration('ai-localizer');\n        const configuredGlobs = cfg.get<string[]>('i18n.sourceGlobs') || [];\n        const fallbackGlobs = [\n            '**/*.{ts,tsx,js,jsx,mjs,cjs,mts,cts,vue,svelte,php,py,cs,cshtml,razor}',\n            '**/*.blade.php',\n        ];\n        const sourceGlobs = configuredGlobs.length > 0\n            ? Array.from(new Set<string>([...configuredGlobs, ...fallbackGlobs]))\n            : fallbackGlobs;\n        const excludeGlobs = [\n            '**/node_modules/**',\n            '**/.git/**',\n            '**/dist/**',\n            '**/build/**',\n            '**/.next/**',\n            '**/.nuxt/**',\n            '**/.vite/**',\n            '**/coverage/**',\n            '**/out/**',\n            '**/.turbo/**',\n            '**/vendor/**',\n        ];\n        const exclude = excludeGlobs.length > 0 ? `{${excludeGlobs.join(',')}}` : undefined;\n\n        const seen = new Set<string>();\n        const uris: vscode.Uri[] = [];\n        const includes = sourceGlobs.length > 0 ? sourceGlobs : [];\n\n        const folderPrefix = folder.uri.fsPath.replace(/\\\\/g, '/').toLowerCase().replace(/\\/$/, '') + '/';\n\n        for (const include of includes) {\n            try {\n                const found = await vscode.workspace.findFiles(include, exclude);\n                for (const uri of found) {\n                    const normalizedPath = uri.fsPath.replace(/\\\\/g, '/').toLowerCase();\n                    if (!normalizedPath.startsWith(folderPrefix)) {\n                        continue;\n                    }\n                    const key = uri.toString();\n                    if (!seen.has(key)) {\n                        seen.add(key);\n                        uris.push(uri);\n                    }\n                }\n            } catch {\n                // Skip invalid glob patterns\n            }\n        }\n\n        const tCallRegex = /(^|[^a-zA-Z0-9_$])(\\$?)t\\s*(?:<[^>]+>\\s*)?\\(\\s*(['\"`])([A-Za-z0-9_\\.\\-:]+)\\3\\s*([,)])/gm;\n        const laravelCallRegexes: Array<{ regex: RegExp; keyGroup: number }> = [\n            { regex: /\\b__\\s*\\(\\s*(['\"])([A-Za-z0-9_\\.\\-:]+)\\1\\s*(?:,|\\))/g, keyGroup: 2 },\n            { regex: /\\btrans\\s*\\(\\s*(['\"])([A-Za-z0-9_\\.\\-:]+)\\1\\s*(?:,|\\))/g, keyGroup: 2 },\n            { regex: /@lang\\s*\\(\\s*(['\"])([A-Za-z0-9_\\.\\-:]+)\\1\\s*(?:,|\\))/g, keyGroup: 2 },\n        ];\n        const pythonCallRegexes: Array<{ regex: RegExp; keyGroup: number }> = [\n            { regex: /\\b(_|gettext)\\s*\\(\\s*(['\"])([A-Za-z0-9_\\.\\-:]+)\\2\\s*(?:,|\\))/g, keyGroup: 3 },\n        ];\n        const keyLiteralRegex = /(['\"`])([A-Za-z0-9_\\-]+(?:[\\.:][A-Za-z0-9_\\-]+)+)\\1/g;\n\n        for (const uri of uris) {\n            try {\n                const data = await vscode.workspace.fs.readFile(uri);\n                const text = sharedDecoder.decode(data);\n\n                const commentRanges = findCommentRanges(text);\n\n                let match;\n                tCallRegex.lastIndex = 0;\n\n                while ((match = tCallRegex.exec(text)) !== null) {\n                    const tCallStart = match.index + match[1].length;\n\n                    if (isPositionInComment(tCallStart, commentRanges)) {\n                        continue;\n                    }\n\n                    const key = match[4];\n                    if (candidateKeys.has(key)) {\n                        usedKeys.add(key);\n                        if (usedKeys.size === candidateKeys.size) {\n                            return usedKeys;\n                        }\n                    }\n                }\n\n                for (const { regex, keyGroup } of laravelCallRegexes) {\n                    regex.lastIndex = 0;\n                    while ((match = regex.exec(text)) !== null) {\n                        if (isPositionInComment(match.index, commentRanges)) {\n                            continue;\n                        }\n                        const key = match[keyGroup];\n                        if (candidateKeys.has(key)) {\n                            usedKeys.add(key);\n                            if (usedKeys.size === candidateKeys.size) {\n                                return usedKeys;\n                            }\n                        }\n                    }\n                }\n\n                for (const { regex, keyGroup } of pythonCallRegexes) {\n                    regex.lastIndex = 0;\n                    while ((match = regex.exec(text)) !== null) {\n                        if (isPositionInComment(match.index, commentRanges)) {\n                            continue;\n                        }\n                        const key = match[keyGroup];\n                        if (candidateKeys.has(key)) {\n                            usedKeys.add(key);\n                            if (usedKeys.size === candidateKeys.size) {\n                                return usedKeys;\n                            }\n                        }\n                    }\n                }\n\n                if (usedKeys.size === candidateKeys.size) {\n                    return usedKeys;\n                }\n\n                tCallRegex.lastIndex = 0;\n                keyLiteralRegex.lastIndex = 0;\n                while ((match = keyLiteralRegex.exec(text)) !== null) {\n                    if (isPositionInComment(match.index, commentRanges)) {\n                        continue;\n                    }\n\n                    const key = match[2];\n                    if (candidateKeys.has(key)) {\n                        usedKeys.add(key);\n                        if (usedKeys.size === candidateKeys.size) {\n                            return usedKeys;\n                        }\n                    }\n                }\n            } catch {\n                // Skip files that can't be read\n            }\n        }\n\n        return usedKeys;\n    }\n\n    private async bulkFixMissingReferences(\n        folder: vscode.WorkspaceFolder,\n        token: vscode.CancellationToken,\n        progress: vscode.Progress<{ message?: string }>,\n    ): Promise<number> {\n        const maxPasses = 3;\n        let totalFixed = 0;\n\n        const runWithConcurrency = async <T>(\n            items: T[],\n            concurrency: number,\n            fn: (item: T) => Promise<void>,\n        ): Promise<void> => {\n            const queue = [...items];\n            const workers: Promise<void>[] = [];\n\n            const worker = async (): Promise<void> => {\n                while (queue.length > 0) {\n                    if (token.isCancellationRequested) return;\n                    const next = queue.shift();\n                    if (!next) return;\n                    await fn(next);\n                }\n            };\n\n            const count = Math.max(1, Math.min(concurrency, items.length || 1));\n            for (let i = 0; i < count; i++) {\n                workers.push(worker());\n            }\n            await Promise.all(workers);\n        };\n\n        for (let pass = 1; pass <= maxPasses; pass++) {\n            if (token.isCancellationRequested) return totalFixed;\n\n            // Scan source files directly for missing references (more reliable than diagnostics)\n            const issues = await this.scanSourceFilesForMissingRefs(folder);\n            if (issues.missingReferences === 0 || issues.filesWithMissingRefs.length === 0) {\n                break;\n            }\n\n            progress.report({\n                message: `Pass ${pass}/${maxPasses}: Fixing ${issues.missingReferences} missing refs in ${issues.filesWithMissingRefs.length} file(s)...`,\n            });\n\n            let fixedThisPass = 0;\n            const cfg = vscode.workspace.getConfiguration('ai-localizer');\n            const concurrency = Number(cfg.get<number>('i18n.bulkFixConcurrency') ?? 4);\n            await runWithConcurrency(issues.filesWithMissingRefs, concurrency, async (uri) => {\n                if (token.isCancellationRequested) return;\n                try {\n                    await vscode.commands.executeCommand('ai-localizer.i18n.bulkFixMissingKeyReferences', uri);\n                    fixedThisPass += 1;\n                } catch (err) {\n                    const msg = err instanceof Error ? err.message : String(err);\n                    console.warn(`AI Localizer: Bulk fix failed for ${uri.fsPath}. ${msg}`);\n                }\n            });\n\n            totalFixed += fixedThisPass;\n\n            // Rebuild index after fixes to pick up newly created keys\n            await this.i18nIndex.ensureInitialized(true);\n\n            // If we didn't manage to process any file, there's no point continuing.\n            if (fixedThisPass === 0) {\n                break;\n            }\n\n            // Check if we made progress\n            const afterIssues = await this.scanSourceFilesForMissingRefs(folder);\n            if (afterIssues.missingReferences >= issues.missingReferences) {\n                // No progress made, stop iterating\n                break;\n            }\n        }\n\n        return totalFixed;\n    }\n\n    private async appendKeysToAutoIgnore(folder: vscode.WorkspaceFolder, keys: string[]): Promise<void> {\n        if (!keys.length) return;\n        const scriptsDir = vscode.Uri.joinPath(folder.uri, 'scripts');\n        const autoUri = vscode.Uri.joinPath(scriptsDir, '.i18n-auto-ignore.json');\n\n        let existing: Record<string, unknown> = {};\n        try {\n            const data = await vscode.workspace.fs.readFile(autoUri);\n            const parsed = JSON.parse(sharedDecoder.decode(data));\n            if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n                existing = parsed as Record<string, unknown>;\n            }\n        } catch {\n            // file may not exist; we'll create it\n        }\n\n        const exactSet = new Set<string>(\n            Array.isArray(existing.exact) ? (existing.exact as unknown[]).map((v) => String(v)) : [],\n        );\n\n        const initialSize = exactSet.size;\n        for (const k of keys) {\n            exactSet.add(k);\n        }\n\n        if (exactSet.size === initialSize) {\n            return;\n        }\n\n        existing.exact = Array.from(exactSet).sort();\n        if (!Array.isArray(existing.exactInsensitive)) existing.exactInsensitive = [];\n        if (!Array.isArray(existing.contains)) existing.contains = [];\n\n        const payload = `${JSON.stringify(existing, null, 2)}\\n`;\n        await vscode.workspace.fs.createDirectory(scriptsDir);\n        await vscode.workspace.fs.writeFile(autoUri, sharedEncoder.encode(payload));\n    }\n\n    private deleteKeyPathInObject(obj: Record<string, unknown>, keyPath: string): boolean {\n        const segments = String(keyPath).split('.').filter(Boolean);\n        if (!segments.length) return false;\n\n        let deleted = false;\n        const helper = (target: Record<string, unknown>, index: number): boolean => {\n            const key = segments[index];\n            if (!(key in target)) {\n                return false;\n            }\n            if (index === segments.length - 1) {\n                delete target[key];\n                deleted = true;\n                return Object.keys(target).length === 0;\n            }\n            const child = target[key];\n            if (!child || typeof child !== 'object' || Array.isArray(child)) {\n                return false;\n            }\n            const shouldDeleteChild = helper(child as Record<string, unknown>, index + 1);\n            if (shouldDeleteChild) {\n                delete target[key];\n            }\n            return Object.keys(target).length === 0;\n        };\n\n        helper(obj, 0);\n        return deleted;\n    }\n\n    private async listLocalesInDir(autoDirUri: vscode.Uri): Promise<string[]> {\n        const locales: string[] = [];\n        try {\n            const entries = await vscode.workspace.fs.readDirectory(autoDirUri);\n            for (const [name, type] of entries) {\n                if (type === vscode.FileType.Directory) {\n                    locales.push(name);\n                } else if (type === vscode.FileType.File && name.endsWith('.json')) {\n                    const localeName = name.replace(/\\.json$/i, '');\n                    if (!locales.includes(localeName)) {\n                        locales.push(localeName);\n                    }\n                }\n            }\n        } catch {\n            // directory might not exist\n        }\n        return locales;\n    }\n\n    private async applyUnusedReportAcrossLocales(\n        folder: vscode.WorkspaceFolder,\n        token: vscode.CancellationToken,\n    ): Promise<ReportCleanupResult> {\n        return this.applyReportAcrossLocales(folder, token, 'unused');\n    }\n\n    private async applyInvalidReportAcrossLocales(\n        folder: vscode.WorkspaceFolder,\n        token: vscode.CancellationToken,\n    ): Promise<ReportCleanupResult> {\n        return this.applyReportAcrossLocales(folder, token, 'invalid');\n    }\n\n    private async applyReportAcrossLocales(\n        folder: vscode.WorkspaceFolder,\n        token: vscode.CancellationToken,\n        reportType: 'unused' | 'invalid',\n    ): Promise<ReportCleanupResult> {\n        const reportFileName = reportType === 'unused'\n            ? '.i18n-unused-report.json'\n            : '.i18n-invalid-report.json';\n        const scriptsDir = vscode.Uri.joinPath(folder.uri, 'scripts');\n        const reportUri = vscode.Uri.joinPath(scriptsDir, reportFileName);\n\n        let report: UnusedReport | InvalidReport;\n        try {\n            const data = await vscode.workspace.fs.readFile(reportUri);\n            report = JSON.parse(sharedDecoder.decode(data));\n        } catch {\n            return { filesChanged: 0, keysRemoved: 0 };\n        }\n\n        const entries = (reportType === 'unused'\n            ? (report as UnusedReport).unused\n            : (report as InvalidReport).invalid) || [];\n\n        if (!entries.length || !report.autoDir || !report.baseLocale) {\n            return { filesChanged: 0, keysRemoved: 0 };\n        }\n\n        const candidateKeys = new Set<string>();\n        for (const entry of entries) {\n            const keyPath = (entry as any).keyPath;\n            if (typeof keyPath === 'string' && keyPath) {\n                candidateKeys.add(keyPath);\n            }\n        }\n        const usedKeys = await this.buildSourceUsageSet(folder, candidateKeys);\n\n        // CRITICAL: For invalid keys, restore inline strings in code BEFORE deleting from locale files\n        // This prevents creating missing translation key diagnostics\n        if (reportType === 'invalid') {\n            let restoredCount = 0;\n            for (const entry of entries) {\n                if (token.isCancellationRequested) {\n                    break;\n                }\n                \n                const invalidEntry = entry as { keyPath: string; baseValue?: string; usages?: Array<{ file: string; line: number }> };\n                if (usedKeys.has(invalidEntry.keyPath)) {\n                    console.log(\n                        `[ProjectFixCommand] Skipping restore of \"${invalidEntry.keyPath}\" because it is still referenced in source.`\n                    );\n                    continue;\n                }\n                const usages = invalidEntry.usages || [];\n                const baseValue = invalidEntry.baseValue || '';\n                \n                for (const usage of usages) {\n                    if (!usage || typeof usage.file !== 'string' || typeof usage.line !== 'number') {\n                        continue;\n                    }\n                    \n                    try {\n                        const codeFileUri = vscode.Uri.joinPath(folder.uri, usage.file);\n                        const restored = await this.restoreInlineStringInFile(\n                            codeFileUri,\n                            invalidEntry.keyPath,\n                            baseValue,\n                            usage.line - 1, // Report uses 1-based line numbers\n                        );\n                        if (restored) {\n                            restoredCount++;\n                        }\n                    } catch (err) {\n                        console.error(`AI Localizer: Failed to restore code reference for ${invalidEntry.keyPath} in ${usage.file}:`, err);\n                    }\n                }\n            }\n            \n            if (restoredCount > 0) {\n                console.log(`[ProjectFixCommand] Restored ${restoredCount} inline string(s) before deleting invalid keys`);\n            }\n        }\n\n        const autoDirUri = vscode.Uri.joinPath(folder.uri, report.autoDir);\n        const locales = await this.listLocalesInDir(autoDirUri);\n        if (!locales.length) {\n            return { filesChanged: 0, keysRemoved: 0 };\n        }\n\n        const byFile = new Map<string, FileBucket>();\n        const processedKeys = new Set<string>();\n\n        for (const entry of entries) {\n            if (token.isCancellationRequested) {\n                return { filesChanged: 0, keysRemoved: processedKeys.size };\n            }\n\n            const { keyPath, baseFileRel } = entry;\n            if (!keyPath || !baseFileRel || processedKeys.has(keyPath)) {\n                continue;\n            }\n\n            // Safety guard: never delete keys that are still referenced in source.\n            if (usedKeys.has(keyPath)) {\n                console.log(\n                    `[ProjectFixCommand] Skipping deletion of \"${keyPath}\" because it is still referenced in source.`,\n                );\n                processedKeys.add(keyPath);\n                continue;\n            }\n\n            for (const locale of locales) {\n                if (token.isCancellationRequested) {\n                    return { filesChanged: 0, keysRemoved: processedKeys.size };\n                }\n\n                let fileRel: string;\n                if (baseFileRel === `${report.baseLocale}.json`) {\n                    // Single-file locale structure: en.json -> fr.json\n                    fileRel = `${locale}.json`;\n                } else if (baseFileRel.startsWith(`${report.baseLocale}/`)) {\n                    // Grouped locale structure: en/<path> -> fr/<path>\n                    const relTail = baseFileRel.slice(`${report.baseLocale}/`.length);\n                    fileRel = `${locale}/${relTail}`;\n                } else {\n                    fileRel = baseFileRel;\n                }\n\n                const fileUri = vscode.Uri.joinPath(\n                    autoDirUri,\n                    ...fileRel.split(/[\\\\/]+/).filter(Boolean),\n                );\n                const mapKey = fileUri.toString();\n\n                let bucket = byFile.get(mapKey);\n                if (!bucket) {\n                    try {\n                        const data = await vscode.workspace.fs.readFile(fileUri);\n                        const parsed = JSON.parse(sharedDecoder.decode(data));\n                        const json = (parsed && typeof parsed === 'object' && !Array.isArray(parsed))\n                            ? parsed as Record<string, unknown>\n                            : {};\n                        bucket = { uri: fileUri, json, changed: false, deletedKeys: [] };\n                        byFile.set(mapKey, bucket);\n                    } catch {\n                        continue;\n                    }\n                }\n\n                if (this.deleteKeyPathInObject(bucket.json, keyPath)) {\n                    bucket.changed = true;\n                    if (!bucket.deletedKeys.includes(keyPath)) {\n                        bucket.deletedKeys.push(keyPath);\n                    }\n                }\n            }\n\n            processedKeys.add(keyPath);\n        }\n\n        let filesChanged = 0;\n        for (const bucket of byFile.values()) {\n            if (!bucket.changed) continue;\n            if (token.isCancellationRequested) {\n                return { filesChanged, keysRemoved: processedKeys.size };\n            }\n\n            const payload = `${JSON.stringify(bucket.json, null, 2)}\\n`;\n            await vscode.workspace.fs.writeFile(bucket.uri, sharedEncoder.encode(payload));\n            filesChanged += 1;\n            await this.i18nIndex.updateFile(bucket.uri);\n            await vscode.commands.executeCommand(\n                'ai-localizer.i18n.refreshFileDiagnostics',\n                bucket.uri,\n                bucket.deletedKeys,\n            );\n        }\n\n        return { filesChanged, keysRemoved: processedKeys.size };\n    }\n\n    /**\n     * Restore a single t('key') call to an inline string in a specific file\n     */\n    private async restoreInlineStringInFile(\n        fileUri: vscode.Uri,\n        keyPath: string,\n        baseValue: string,\n        lineNumber: number,\n    ): Promise<boolean> {\n        try {\n            const doc = await vscode.workspace.openTextDocument(fileUri);\n            const lineText = doc.lineAt(lineNumber).text;\n\n            const escapedKey = keyPath.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n            const patterns = [\n                new RegExp(`t\\\\(\\\\s*['\"]${escapedKey}['\"]\\\\s*\\\\)`, 'g'),\n                new RegExp(`t\\\\(\\\\s*['\"]${escapedKey}['\"]\\\\s*,\\\\s*\\\\{[^}]*\\\\}\\\\s*\\\\)`, 'g'),\n            ];\n\n            let newLineText = lineText;\n            let replaced = false;\n\n            const placeholderRegex = /\\{([A-Za-z0-9_]+(?:\\.[A-Za-z0-9_]+)?)\\}/g;\n            const hasPlaceholders = placeholderRegex.test(baseValue);\n\n            let replacement: string;\n            if (hasPlaceholders) {\n                const escaped = baseValue\n                    .replace(/`/g, '\\\\`')\n                    .replace(/\\$/g, '\\\\$');\n                replacement = `\\`${escaped}\\``;\n            } else {\n                const escaped = baseValue\n                    .replace(/\\\\/g, '\\\\\\\\')\n                    .replace(/'/g, \"\\\\'\")\n                    .replace(/\\r?\\n/g, '\\\\n');\n                replacement = `'${escaped}'`;\n            }\n\n            for (const pattern of patterns) {\n                if (pattern.test(newLineText)) {\n                    newLineText = newLineText.replace(pattern, replacement);\n                    replaced = true;\n                    break;\n                }\n            }\n\n            if (!replaced) {\n                return false;\n            }\n\n            const simplifyRedundantStringFallbacks = (input: string): string => {\n                let out = input;\n                const withParens = /\\(\\s*(['\"`])((?:\\\\.|(?!\\1)[^\\\\\\r\\n])+?)\\1\\s*\\)\\s*(\\|\\||\\?\\?)\\s*\\(\\s*\\1\\2\\1\\s*\\)/g;\n                const withoutParens = /(['\"`])((?:\\\\.|(?!\\1)[^\\\\\\r\\n])+?)\\1\\s*(\\|\\||\\?\\?)\\s*\\1\\2\\1/g;\n                for (let i = 0; i < 10; i += 1) {\n                    const next = out.replace(withParens, (_m, q, v) => `${q}${v}${q}`)\n                        .replace(withoutParens, (_m, q, v) => `${q}${v}${q}`);\n                    if (next === out) break;\n                    out = next;\n                }\n                return out;\n            };\n\n            newLineText = simplifyRedundantStringFallbacks(newLineText);\n\n            const edit = new vscode.WorkspaceEdit();\n            const range = doc.lineAt(lineNumber).range;\n            edit.replace(fileUri, range, newLineText);\n            await vscode.workspace.applyEdit(edit);\n            return true;\n        } catch (err) {\n            console.error(`AI Localizer: Failed to restore inline string for ${keyPath} at ${fileUri.fsPath}:${lineNumber}:`, err);\n            return false;\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\scaffoldMessagesCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\scriptCommands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\statusCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\uninstallProjectI18nCommand.ts","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":313,"column":43,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":313,"endColumn":44,"suggestions":[{"messageId":"removeEscape","fix":{"range":[12377,12378],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[12377,12377],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\-.","line":313,"column":45,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":313,"endColumn":46,"suggestions":[{"messageId":"removeEscape","fix":{"range":[12379,12380],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[12379,12379],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\-.","line":443,"column":42,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":443,"endColumn":43,"suggestions":[{"messageId":"removeEscape","fix":{"range":[17215,17216],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[17215,17215],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\\".","line":849,"column":72,"nodeType":"TemplateElement","messageId":"unnecessaryEscape","endLine":849,"endColumn":73,"suggestions":[{"messageId":"removeEscape","fix":{"range":[31167,31168],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[31167,31167],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\\".","line":849,"column":87,"nodeType":"TemplateElement","messageId":"unnecessaryEscape","endLine":849,"endColumn":88,"suggestions":[{"messageId":"removeEscape","fix":{"range":[31182,31183],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[31182,31182],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'full' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":856,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":856,"endColumn":23}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\r\nimport { TextDecoder, TextEncoder } from 'util';\r\nimport { I18nIndex } from '../core/i18nIndex';\r\nimport { pickWorkspaceFolder } from '../core/workspace';\r\nimport { getGitStatus, createSnapshotCommit } from '../core/gitMonitor';\r\nimport { GitRecoveryHandler } from './untranslated/handlers/gitRecoveryHandler';\r\nimport { operationLock } from './untranslated/utils/operationLock';\r\nimport { findCommentRanges, isPositionInComment } from './untranslated/utils/commentParser';\r\n\r\nconst sharedDecoder = new TextDecoder('utf-8');\r\nconst sharedEncoder = new TextEncoder();\r\n\r\ntype Replacement = {\r\n    start: number;\r\n    end: number;\r\n    replacement: string;\r\n    key: string;\r\n};\r\n\r\nexport class UninstallProjectI18nCommand {\r\n    private gitRecoveryHandler: GitRecoveryHandler;\r\n\r\n    constructor(\r\n        private i18nIndex: I18nIndex,\r\n        private context?: vscode.ExtensionContext,\r\n        private log?: vscode.OutputChannel,\r\n    ) {\r\n        this.gitRecoveryHandler = new GitRecoveryHandler(context, log);\r\n    }\r\n\r\n    async execute(): Promise<void> {\r\n        const folder = await pickWorkspaceFolder();\r\n        if (!folder) {\r\n            vscode.window.showInformationMessage('AI Localizer: No workspace folder available.');\r\n            return;\r\n        }\r\n\r\n        const lockedResult = await operationLock.withGlobalLock(\r\n            'key-management',\r\n            `Uninstall i18n from ${folder.name}`,\r\n            async (token) => this.executeWithLock(folder, token),\r\n            { cancellable: true },\r\n        );\r\n\r\n        if (lockedResult === null) {\r\n            return;\r\n        }\r\n    }\r\n\r\n    private async executeWithLock(folder: vscode.WorkspaceFolder, token?: vscode.CancellationToken): Promise<void> {\r\n        const status = await getGitStatus(folder);\r\n        if (token?.isCancellationRequested) {\r\n            return;\r\n        }\r\n\r\n        if (!status.hasGit) {\r\n            const choice = await vscode.window.showQuickPick(\r\n                [\r\n                    {\r\n                        label: 'Continue without git snapshot',\r\n                        description: 'Proceed without creating a snapshot git commit.',\r\n                    },\r\n                    {\r\n                        label: 'Cancel',\r\n                        description: 'Do not uninstall i18n right now.',\r\n                    },\r\n                ],\r\n                {\r\n                    placeHolder:\r\n                        'AI Localizer: No git repository detected for this workspace. Continue without a snapshot commit?',\r\n                },\r\n            );\r\n\r\n            if (!choice || choice.label !== 'Continue without git snapshot') {\r\n                return;\r\n            }\r\n        } else if (status.isDirty) {\r\n            const choice = await vscode.window.showQuickPick(\r\n                [\r\n                    {\r\n                        label: 'Create snapshot commit and continue',\r\n                        description: 'Create a git commit before uninstalling i18n.',\r\n                    },\r\n                    {\r\n                        label: 'Continue without snapshot (not recommended)',\r\n                        description: 'Uninstall i18n without taking a snapshot first.',\r\n                    },\r\n                    {\r\n                        label: 'Cancel',\r\n                        description: 'Do not uninstall i18n right now.',\r\n                    },\r\n                ],\r\n                {\r\n                    placeHolder:\r\n                        'AI Localizer: Workspace has uncommitted changes. Create a snapshot git commit before uninstalling i18n?',\r\n                },\r\n            );\r\n\r\n            if (!choice || choice.label === 'Cancel') {\r\n                return;\r\n            }\r\n\r\n            if (choice.label === 'Create snapshot commit and continue') {\r\n                const snapshot = await createSnapshotCommit(folder, 'chore: i18n pre-uninstall snapshot');\r\n                if (!snapshot.success) {\r\n                    const message = snapshot.error\r\n                        ? `AI Localizer: Failed to create git snapshot commit. ${snapshot.error}`\r\n                        : 'AI Localizer: Failed to create git snapshot commit.';\r\n                    vscode.window.showErrorMessage(message);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        const confirm = await vscode.window.showQuickPick(\r\n            [\r\n                {\r\n                    label: 'Uninstall i18n (replace t() calls with strings)',\r\n                    description: 'Revert i18n key usage back to string literals across this workspace.',\r\n                },\r\n                {\r\n                    label: 'Cancel',\r\n                    description: 'Do not uninstall i18n right now.',\r\n                },\r\n            ],\r\n            {\r\n                placeHolder: 'AI Localizer: Uninstall/remove i18n from this project?',\r\n            },\r\n        );\r\n\r\n        if (!confirm || confirm.label !== 'Uninstall i18n (replace t() calls with strings)') {\r\n            return;\r\n        }\r\n\r\n        await vscode.window.withProgress(\r\n            {\r\n                location: vscode.ProgressLocation.Notification,\r\n                title: `AI Localizer: Uninstalling i18n from ${folder.name}...`,\r\n                cancellable: true,\r\n            },\r\n            async (progress, progressToken) => {\r\n                if (progressToken.isCancellationRequested || token?.isCancellationRequested) {\r\n                    return;\r\n                }\r\n\r\n                progress.report({ message: 'Building translation index...' });\r\n                await this.i18nIndex.ensureInitialized(true);\r\n\r\n                if (progressToken.isCancellationRequested || token?.isCancellationRequested) {\r\n                    return;\r\n                }\r\n\r\n                const defaultLocale =\r\n                    vscode.workspace.getConfiguration('ai-localizer').get<string>('i18n.defaultLocale') || 'en';\r\n\r\n                const localeUris = await this.gitRecoveryHandler.getLocaleFileUris(\r\n                    folder,\r\n                    defaultLocale,\r\n                    this.i18nIndex,\r\n                );\r\n\r\n                progress.report({ message: 'Scanning source files for t() calls...' });\r\n                const sourceUris = await this.collectSourceFileUris(folder);\r\n\r\n                if (progressToken.isCancellationRequested || token?.isCancellationRequested) {\r\n                    return;\r\n                }\r\n\r\n                let filesChanged = 0;\r\n                let totalReplacements = 0;\r\n                let missingKeys = 0;\r\n\r\n                const maxFiles = sourceUris.length;\r\n                for (let i = 0; i < sourceUris.length; i += 1) {\r\n                    const uri = sourceUris[i];\r\n                    if (progressToken.isCancellationRequested || token?.isCancellationRequested) {\r\n                        return;\r\n                    }\r\n                    const pct = maxFiles > 0 ? Math.round((i / maxFiles) * 100) : 0;\r\n                    progress.report({ message: `Processing ${i + 1}/${maxFiles} (${pct}%)`, increment: 0 });\r\n\r\n                    const result = await this.processFile(folder, uri, defaultLocale, localeUris);\r\n                    if (result.changed) {\r\n                        filesChanged += 1;\r\n                        totalReplacements += result.replacements;\r\n                    }\r\n                    missingKeys += result.missingKeys;\r\n                }\r\n\r\n                progress.report({ message: 'Optionally cleaning up i18n scripts/config...' });\r\n\r\n                const cleanupChoice = await vscode.window.showQuickPick(\r\n                    [\r\n                        {\r\n                            label: 'Remove AI Localizer i18n scripts from package.json and /scripts',\r\n                            description: 'Removes i18n:* scripts and deletes AI Localizer scripts in /scripts.',\r\n                        },\r\n                        {\r\n                            label: 'Skip cleanup',\r\n                            description: 'Leave scripts and config files untouched.',\r\n                        },\r\n                    ],\r\n                    { placeHolder: 'AI Localizer: Clean up i18n scripts and config files too?' },\r\n                );\r\n\r\n                if (cleanupChoice && cleanupChoice.label.startsWith('Remove AI Localizer i18n scripts')) {\r\n                    await this.cleanupProjectI18nScripts(folder);\r\n                }\r\n\r\n                vscode.window.showInformationMessage(\r\n                    `AI Localizer: i18n uninstall completed for \"${folder.name}\". Updated ${filesChanged} file(s), made ${totalReplacements} replacement(s).` +\r\n                        (missingKeys > 0\r\n                            ? ` ${missingKeys} key(s) were missing from the index and required recovery/fallback.`\r\n                            : ''),\r\n                );\r\n            },\r\n        );\r\n    }\r\n\r\n    private async collectSourceFileUris(folder: vscode.WorkspaceFolder): Promise<vscode.Uri[]> {\r\n        const cfg = vscode.workspace.getConfiguration('ai-localizer');\r\n        const sourceGlobs = cfg.get<string[]>('i18n.sourceGlobs') || [\r\n            '**/*.{ts,tsx,js,jsx,vue,php}',\r\n            '**/*.blade.php',\r\n        ];\r\n        const excludeGlobs = cfg.get<string[]>('i18n.sourceExcludeGlobs') || [\r\n            '**/node_modules/**',\r\n            '**/.git/**',\r\n            '**/dist/**',\r\n            '**/build/**',\r\n            '**/.next/**',\r\n            '**/.nuxt/**',\r\n            '**/.vite/**',\r\n            '**/coverage/**',\r\n            '**/out/**',\r\n            '**/.turbo/**',\r\n            '**/vendor/**',\r\n        ];\r\n\r\n        const exclude = excludeGlobs.length > 0 ? `{${excludeGlobs.join(',')}}` : undefined;\r\n        const seen = new Set<string>();\r\n        const out: vscode.Uri[] = [];\r\n\r\n        for (const include of sourceGlobs) {\r\n            try {\r\n                const pattern = new vscode.RelativePattern(folder, include);\r\n                const found = await vscode.workspace.findFiles(pattern, exclude);\r\n                for (const uri of found) {\r\n                    const key = uri.toString();\r\n                    if (!seen.has(key)) {\r\n                        seen.add(key);\r\n                        out.push(uri);\r\n                    }\r\n                }\r\n            } catch {\r\n                // ignore\r\n            }\r\n        }\r\n\r\n        return out;\r\n    }\r\n\r\n    private async processFile(\r\n        folder: vscode.WorkspaceFolder,\r\n        uri: vscode.Uri,\r\n        defaultLocale: string,\r\n        localeUris: vscode.Uri[],\r\n    ): Promise<{ changed: boolean; replacements: number; missingKeys: number }> {\r\n        let doc: vscode.TextDocument;\r\n        try {\r\n            doc = await vscode.workspace.openTextDocument(uri);\r\n        } catch {\r\n            return { changed: false, replacements: 0, missingKeys: 0 };\r\n        }\r\n\r\n        const text = doc.getText();\r\n        if (!text || !/\\b\\$?t\\s*\\(|__\\s*\\(/.test(text)) {\r\n            return { changed: false, replacements: 0, missingKeys: 0 };\r\n        }\r\n\r\n        const commentRanges = findCommentRanges(text);\r\n\r\n        const replacements: Replacement[] = [];\r\n        let missingKeys = 0;\r\n\r\n        const tryAddReplacement = (start: number, end: number, replacement: string, key: string) => {\r\n            if (start < 0 || end <= start || end > text.length) {\r\n                return;\r\n            }\r\n            if (isPositionInComment(start, commentRanges)) {\r\n                return;\r\n            }\r\n            for (const r of replacements) {\r\n                const overlap = !(end <= r.start || start >= r.end);\r\n                if (overlap) {\r\n                    return;\r\n                }\r\n            }\r\n            replacements.push({ start, end, replacement, key });\r\n        };\r\n\r\n        const tCallPattern = /\\b\\$?t\\s*\\(\\s*(['\"`])([^'\"`]+)\\1/g;\r\n        const phpCallPattern = /\\b__\\s*\\(\\s*(['\"`])([^'\"`]+)\\1/g;\r\n\r\n        const handleCallMatches = async (pattern: RegExp) => {\r\n            pattern.lastIndex = 0;\r\n            while (true) {\r\n                const match = pattern.exec(text);\r\n                if (!match) break;\r\n\r\n                const callStart = match.index;\r\n                const key = match[2];\r\n                if (!key || !/^[A-Za-z0-9_\\.\\-]+$/.test(key)) {\r\n                    continue;\r\n                }\r\n\r\n                const callEnd = this.findCallExpressionEnd(text, callStart);\r\n                if (callEnd === null) {\r\n                    continue;\r\n                }\r\n\r\n                const callText = text.slice(callStart, callEnd);\r\n                const valueInfo = await this.resolveKeyToValue(\r\n                    folder,\r\n                    uri.fsPath,\r\n                    key,\r\n                    defaultLocale,\r\n                    localeUris,\r\n                    callText,\r\n                );\r\n\r\n                if (!valueInfo) {\r\n                    missingKeys += 1;\r\n                    continue;\r\n                }\r\n\r\n                tryAddReplacement(callStart, callEnd, valueInfo.replacementExpr, key);\r\n            }\r\n        };\r\n\r\n        await handleCallMatches(tCallPattern);\r\n        await handleCallMatches(phpCallPattern);\r\n\r\n        // Best-effort: if we removed all t() calls from the file, remove the AI Localizer\r\n        // import for t to avoid leaving an unused import behind.\r\n        if (replacements.length > 0) {\r\n            const simulated = this.applyReplacementsToText(text, replacements);\r\n            const hasRemainingTCall = this.hasTCallOutsideComments(simulated);\r\n            if (!hasRemainingTCall) {\r\n                const cfg = vscode.workspace.getConfiguration('ai-localizer');\r\n                const tImportPath = cfg.get<string>('i18n.tImportPath') || '@/i18n';\r\n                const importRanges = this.findTImportRanges(text, tImportPath);\r\n                for (const r of importRanges) {\r\n                    tryAddReplacement(r.start, r.end, '', '__import__');\r\n                }\r\n            }\r\n        }\r\n\r\n        if (replacements.length === 0) {\r\n            return { changed: false, replacements: 0, missingKeys };\r\n        }\r\n\r\n        const edit = new vscode.WorkspaceEdit();\r\n        replacements.sort((a, b) => b.start - a.start);\r\n        for (const r of replacements) {\r\n            const range = new vscode.Range(doc.positionAt(r.start), doc.positionAt(r.end));\r\n            edit.replace(uri, range, r.replacement);\r\n        }\r\n\r\n        const applied = await vscode.workspace.applyEdit(edit);\r\n        if (applied) {\r\n            await doc.save();\r\n        }\r\n\r\n        return { changed: applied, replacements: replacements.length, missingKeys };\r\n    }\r\n\r\n    private async resolveKeyToValue(\r\n        folder: vscode.WorkspaceFolder,\r\n        sourceFilePath: string,\r\n        key: string,\r\n        defaultLocale: string,\r\n        localeUris: vscode.Uri[],\r\n        callText: string,\r\n    ): Promise<{ replacementExpr: string } | null> {\r\n        const record = this.i18nIndex.getRecord(key);\r\n        const defaultValue = record?.locales?.get(defaultLocale);\r\n\r\n        const optionsText = this.extractFirstObjectArg(callText);\r\n        const optionsMap = optionsText ? this.parseSimpleObjectLiteral(optionsText) : null;\r\n\r\n        let resolvedValue = defaultValue;\r\n        let mustRecoverFromGit = this.isSuspiciousReplacement(key, resolvedValue || '', optionsMap);\r\n\r\n        if (!resolvedValue || mustRecoverFromGit) {\r\n            const recovered = await this.gitRecoveryHandler.recoverFromSourceFileHistory(\r\n                folder,\r\n                sourceFilePath,\r\n                key,\r\n                defaultLocale,\r\n                365,\r\n                '[Uninstall]'\r\n            );\r\n\r\n            if (recovered?.value) {\r\n                resolvedValue = recovered.value;\r\n                mustRecoverFromGit = false;\r\n            }\r\n        }\r\n\r\n        if (!resolvedValue) {\r\n            const recoveredFromLocale = await this.gitRecoveryHandler.recoverKeyFromGit(folder, localeUris, key, defaultLocale, {\r\n                daysBack: 365,\r\n                maxCommits: 100,\r\n                extractRef: null,\r\n                logPrefix: '[Uninstall]',\r\n            });\r\n            if (recoveredFromLocale?.value) {\r\n                resolvedValue = recoveredFromLocale.value;\r\n            }\r\n        }\r\n\r\n        if (!resolvedValue) {\r\n            return null;\r\n        }\r\n\r\n        const placeholders = this.extractPlaceholders(resolvedValue);\r\n        if (placeholders.length > 0 && optionsMap) {\r\n            const tpl = this.tryBuildTemplateLiteral(resolvedValue, placeholders, optionsMap);\r\n            if (tpl) {\r\n                return { replacementExpr: tpl };\r\n            }\r\n        }\r\n\r\n        return { replacementExpr: this.toSingleQuotedJsString(resolvedValue) };\r\n    }\r\n\r\n    private isSuspiciousReplacement(key: string, value: string, options: Map<string, string> | null): boolean {\r\n        const trimmed = String(value || '').trim();\r\n        if (!trimmed) return true;\r\n        if (trimmed === key) return true;\r\n\r\n        if (/^[A-Za-z0-9_]+(\\.[A-Za-z0-9_\\-]+)+$/.test(trimmed) && !/\\s/.test(trimmed)) {\r\n            return true;\r\n        }\r\n\r\n        const lowerKey = key.toLowerCase();\r\n        const looksLabelish =\r\n            lowerKey.includes('.label.') ||\r\n            lowerKey.includes('.button.') ||\r\n            lowerKey.includes('.title.') ||\r\n            lowerKey.includes('.heading.') ||\r\n            lowerKey.includes('.placeholder.');\r\n        const words = trimmed.split(/\\s+/).filter(Boolean);\r\n        if (looksLabelish && words.length >= 10) {\r\n            return true;\r\n        }\r\n\r\n        const placeholders = this.extractPlaceholders(trimmed);\r\n        if (placeholders.length > 0) {\r\n            if (!options) {\r\n                return true;\r\n            }\r\n            for (const p of placeholders) {\r\n                if (!options.has(p)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private extractPlaceholders(value: string): string[] {\r\n        const out: string[] = [];\r\n        const seen = new Set<string>();\r\n        const re = /\\{([a-zA-Z_][a-zA-Z0-9_]*)\\}/g;\r\n        let m: RegExpExecArray | null;\r\n        while ((m = re.exec(value))) {\r\n            const name = m[1];\r\n            if (!seen.has(name)) {\r\n                seen.add(name);\r\n                out.push(name);\r\n            }\r\n        }\r\n        return out;\r\n    }\r\n\r\n    private extractFirstObjectArg(callText: string): string | null {\r\n        const commaIdx = callText.indexOf(',');\r\n        if (commaIdx === -1) return null;\r\n\r\n        const afterComma = callText.slice(commaIdx + 1);\r\n        const braceIdx = afterComma.indexOf('{');\r\n        if (braceIdx === -1) return null;\r\n\r\n        const absoluteStart = commaIdx + 1 + braceIdx;\r\n        const end = this.findMatchingBracket(callText, absoluteStart, '{', '}');\r\n        if (end === null) return null;\r\n\r\n        return callText.slice(absoluteStart, end + 1);\r\n    }\r\n\r\n    private parseSimpleObjectLiteral(text: string): Map<string, string> | null {\r\n        const trimmed = text.trim();\r\n        if (!trimmed.startsWith('{') || !trimmed.endsWith('}')) {\r\n            return null;\r\n        }\r\n\r\n        const inner = trimmed.slice(1, -1).trim();\r\n        if (!inner) {\r\n            return new Map();\r\n        }\r\n\r\n        const parts: string[] = [];\r\n        let current = '';\r\n        let depthParen = 0;\r\n        let depthBrace = 0;\r\n        let depthBracket = 0;\r\n        let quote: 'single' | 'double' | 'template' | null = null;\r\n\r\n        for (let i = 0; i < inner.length; i += 1) {\r\n            const ch = inner[i];\r\n            const prev = i > 0 ? inner[i - 1] : '';\r\n\r\n            if (quote) {\r\n                current += ch;\r\n                if (quote === 'single' && ch === \"'\" && prev !== '\\\\') quote = null;\r\n                if (quote === 'double' && ch === '\"' && prev !== '\\\\') quote = null;\r\n                if (quote === 'template' && ch === '`' && prev !== '\\\\') quote = null;\r\n                continue;\r\n            }\r\n\r\n            if (ch === \"'\") {\r\n                quote = 'single';\r\n                current += ch;\r\n                continue;\r\n            }\r\n            if (ch === '\"') {\r\n                quote = 'double';\r\n                current += ch;\r\n                continue;\r\n            }\r\n            if (ch === '`') {\r\n                quote = 'template';\r\n                current += ch;\r\n                continue;\r\n            }\r\n\r\n            if (ch === '(') depthParen += 1;\r\n            if (ch === ')') depthParen = Math.max(0, depthParen - 1);\r\n            if (ch === '{') depthBrace += 1;\r\n            if (ch === '}') depthBrace = Math.max(0, depthBrace - 1);\r\n            if (ch === '[') depthBracket += 1;\r\n            if (ch === ']') depthBracket = Math.max(0, depthBracket - 1);\r\n\r\n            if (ch === ',' && depthParen === 0 && depthBrace === 0 && depthBracket === 0) {\r\n                const part = current.trim();\r\n                if (part) parts.push(part);\r\n                current = '';\r\n                continue;\r\n            }\r\n\r\n            current += ch;\r\n        }\r\n\r\n        const last = current.trim();\r\n        if (last) parts.push(last);\r\n\r\n        const map = new Map<string, string>();\r\n        for (const part of parts) {\r\n            const colonIdx = part.indexOf(':');\r\n            if (colonIdx === -1) {\r\n                const name = part.trim();\r\n                if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name)) {\r\n                    map.set(name, name);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            const left = part.slice(0, colonIdx).trim();\r\n            const right = part.slice(colonIdx + 1).trim();\r\n\r\n            if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(left)) {\r\n                continue;\r\n            }\r\n            if (!right) {\r\n                continue;\r\n            }\r\n            map.set(left, right);\r\n        }\r\n\r\n        return map;\r\n    }\r\n\r\n    private tryBuildTemplateLiteral(\r\n        value: string,\r\n        placeholders: string[],\r\n        options: Map<string, string>,\r\n    ): string | null {\r\n        let out = '`';\r\n        let cursor = 0;\r\n\r\n        while (cursor < value.length) {\r\n            const nextOpen = value.indexOf('{', cursor);\r\n            if (nextOpen === -1) {\r\n                out += this.escapeTemplateStatic(value.slice(cursor));\r\n                break;\r\n            }\r\n            const nextClose = value.indexOf('}', nextOpen + 1);\r\n            if (nextClose === -1) {\r\n                return null;\r\n            }\r\n\r\n            const name = value.slice(nextOpen + 1, nextClose);\r\n            if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name) || !options.has(name)) {\r\n                return null;\r\n            }\r\n\r\n            out += this.escapeTemplateStatic(value.slice(cursor, nextOpen));\r\n            out += '${' + options.get(name) + '}';\r\n            cursor = nextClose + 1;\r\n        }\r\n\r\n        out += '`';\r\n        return out;\r\n    }\r\n\r\n    private escapeTemplateStatic(text: string): string {\r\n        return text\r\n            .replace(/\\\\/g, '\\\\\\\\')\r\n            .replace(/`/g, '\\\\`')\r\n            .replace(/\\$\\{/g, '\\\\${');\r\n    }\r\n\r\n    private toSingleQuotedJsString(value: string): string {\r\n        const escaped = String(value)\r\n            .replace(/\\\\/g, '\\\\\\\\')\r\n            .replace(/\\r/g, '\\\\r')\r\n            .replace(/\\n/g, '\\\\n')\r\n            .replace(/\\t/g, '\\\\t')\r\n            .replace(/'/g, \"\\\\'\");\r\n        return `'${escaped}'`;\r\n    }\r\n\r\n    private findCallExpressionEnd(text: string, callStart: number): number | null {\r\n        const openParen = text.indexOf('(', callStart);\r\n        if (openParen === -1) return null;\r\n\r\n        let depth = 0;\r\n        let quote: 'single' | 'double' | 'template' | null = null;\r\n\r\n        for (let i = openParen; i < text.length; i += 1) {\r\n            const ch = text[i];\r\n            const prev = i > 0 ? text[i - 1] : '';\r\n\r\n            if (quote) {\r\n                if (quote === 'single' && ch === \"'\" && prev !== '\\\\') quote = null;\r\n                if (quote === 'double' && ch === '\"' && prev !== '\\\\') quote = null;\r\n                if (quote === 'template' && ch === '`' && prev !== '\\\\') quote = null;\r\n                continue;\r\n            }\r\n\r\n            if (ch === \"'\") {\r\n                quote = 'single';\r\n                continue;\r\n            }\r\n            if (ch === '\"') {\r\n                quote = 'double';\r\n                continue;\r\n            }\r\n            if (ch === '`') {\r\n                quote = 'template';\r\n                continue;\r\n            }\r\n\r\n            if (ch === '(') depth += 1;\r\n            if (ch === ')') {\r\n                depth -= 1;\r\n                if (depth === 0) {\r\n                    return i + 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private findMatchingBracket(\r\n        text: string,\r\n        start: number,\r\n        open: string,\r\n        close: string,\r\n    ): number | null {\r\n        let depth = 0;\r\n        let quote: 'single' | 'double' | 'template' | null = null;\r\n\r\n        for (let i = start; i < text.length; i += 1) {\r\n            const ch = text[i];\r\n            const prev = i > 0 ? text[i - 1] : '';\r\n\r\n            if (quote) {\r\n                if (quote === 'single' && ch === \"'\" && prev !== '\\\\') quote = null;\r\n                if (quote === 'double' && ch === '\"' && prev !== '\\\\') quote = null;\r\n                if (quote === 'template' && ch === '`' && prev !== '\\\\') quote = null;\r\n                continue;\r\n            }\r\n\r\n            if (ch === \"'\") {\r\n                quote = 'single';\r\n                continue;\r\n            }\r\n            if (ch === '\"') {\r\n                quote = 'double';\r\n                continue;\r\n            }\r\n            if (ch === '`') {\r\n                quote = 'template';\r\n                continue;\r\n            }\r\n\r\n            if (ch === open) {\r\n                depth += 1;\r\n            } else if (ch === close) {\r\n                depth -= 1;\r\n                if (depth === 0) {\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private async cleanupProjectI18nScripts(folder: vscode.WorkspaceFolder): Promise<void> {\r\n        await this.cleanupPackageJsonScripts(folder);\r\n\r\n        const targets: vscode.Uri[] = [\r\n            vscode.Uri.joinPath(folder.uri, 'scripts', 'extract-i18n.js'),\r\n            vscode.Uri.joinPath(folder.uri, 'scripts', 'replace-i18n.js'),\r\n            vscode.Uri.joinPath(folder.uri, 'scripts', 'sync-i18n.js'),\r\n            vscode.Uri.joinPath(folder.uri, 'scripts', 'fix-untranslated.js'),\r\n            vscode.Uri.joinPath(folder.uri, 'scripts', 'rewrite-i18n-blade.js'),\r\n            vscode.Uri.joinPath(folder.uri, 'scripts', 'cleanup-i18n-unused.js'),\r\n            vscode.Uri.joinPath(folder.uri, 'scripts', 'restore-i18n-invalid.js'),\r\n            vscode.Uri.joinPath(folder.uri, 'scripts', 'i18n-ignore-patterns.json'),\r\n            vscode.Uri.joinPath(folder.uri, 'scripts', 'package.json'),\r\n            vscode.Uri.joinPath(folder.uri, 'scripts', '.i18n-untranslated-report.json'),\r\n            vscode.Uri.joinPath(folder.uri, 'scripts', '.i18n-untranslated-untranslated.json'),\r\n            vscode.Uri.joinPath(folder.uri, 'scripts', '.i18n-untranslated-compact.json'),\r\n            vscode.Uri.joinPath(folder.uri, 'scripts', '.i18n-unused-report.json'),\r\n            vscode.Uri.joinPath(folder.uri, 'scripts', '.i18n-invalid-report.json'),\r\n            vscode.Uri.joinPath(folder.uri, 'scripts', '.i18n-review-generated.json'),\r\n        ];\r\n\r\n        for (const uri of targets) {\r\n            try {\r\n                await vscode.workspace.fs.delete(uri, { recursive: false, useTrash: false });\r\n            } catch {\r\n                // ignore\r\n            }\r\n        }\r\n\r\n        try {\r\n            await vscode.workspace.fs.delete(vscode.Uri.joinPath(folder.uri, 'scripts', 'lib'), {\r\n                recursive: true,\r\n                useTrash: false,\r\n            });\r\n        } catch {\r\n            // ignore\r\n        }\r\n    }\r\n\r\n    private async cleanupPackageJsonScripts(folder: vscode.WorkspaceFolder): Promise<void> {\r\n        const pkgUri = vscode.Uri.joinPath(folder.uri, 'package.json');\r\n        let raw: string;\r\n        try {\r\n            raw = sharedDecoder.decode(await vscode.workspace.fs.readFile(pkgUri));\r\n        } catch {\r\n            return;\r\n        }\r\n\r\n        let json: any;\r\n        try {\r\n            json = JSON.parse(raw);\r\n        } catch {\r\n            return;\r\n        }\r\n\r\n        if (json && typeof json === 'object') {\r\n            if (json.aiI18n && typeof json.aiI18n === 'object') {\r\n                delete json.aiI18n;\r\n            }\r\n\r\n            if (json.scripts && typeof json.scripts === 'object') {\r\n                const scriptKeys = [\r\n                    'i18n:extract',\r\n                    'i18n:rewrite',\r\n                    'i18n:sync',\r\n                    'i18n:fix-untranslated',\r\n                    'i18n:rewrite-blade',\r\n                    'i18n:cleanup-unused',\r\n                    'i18n:restore-invalid',\r\n                ];\r\n\r\n                const aiLocalizerScriptRe =\r\n                    /\\bnode\\s+\\.?\\/?scripts\\/(extract-i18n|replace-i18n|sync-i18n|fix-untranslated|rewrite-i18n-blade|cleanup-i18n-unused|restore-i18n-invalid)\\.js\\b/i;\r\n\r\n                for (const k of scriptKeys) {\r\n                    if (typeof json.scripts[k] === 'string' && aiLocalizerScriptRe.test(json.scripts[k])) {\r\n                        delete json.scripts[k];\r\n                    }\r\n                }\r\n\r\n                if (json.scripts.postbuild === 'npm run i18n:sync') {\r\n                    delete json.scripts.postbuild;\r\n                }\r\n            }\r\n\r\n            const updated = JSON.stringify(json, null, 2);\r\n            await vscode.workspace.fs.writeFile(pkgUri, sharedEncoder.encode(`${updated}\\n`));\r\n        }\r\n    }\r\n\r\n    private applyReplacementsToText(source: string, replacements: Replacement[]): string {\r\n        let out = source;\r\n        const sorted = [...replacements].sort((a, b) => b.start - a.start);\r\n        for (const r of sorted) {\r\n            out = out.slice(0, r.start) + r.replacement + out.slice(r.end);\r\n        }\r\n        return out;\r\n    }\r\n\r\n    private hasTCallOutsideComments(text: string): boolean {\r\n        const ranges = findCommentRanges(text);\r\n        const re = /\\b\\$?t\\s*\\(/g;\r\n        let m: RegExpExecArray | null;\r\n        while ((m = re.exec(text))) {\r\n            if (!isPositionInComment(m.index, ranges)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private findTImportRanges(text: string, importPath: string): Array<{ start: number; end: number }> {\r\n        const escaped = importPath.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n        const re = new RegExp(\r\n            `(^|\\\\r?\\\\n)([\\\\t ]*import\\\\s*\\\\{\\\\s*t\\\\s*\\\\}\\\\s*from\\\\s*['\\\"]${escaped}['\\\"]\\\\s*;?[\\\\t ]*)(?=\\\\r?\\\\n|$)`,\r\n            'g',\r\n        );\r\n\r\n        const ranges: Array<{ start: number; end: number }> = [];\r\n        let m: RegExpExecArray | null;\r\n        while ((m = re.exec(text))) {\r\n            const full = m[0];\r\n            const prefix = m[1] || '';\r\n            const importStmt = m[2] || '';\r\n            const stmtStart = m.index + prefix.length;\r\n            const stmtEnd = stmtStart + importStmt.length;\r\n            const lineEnd = this.findLineEnd(text, stmtEnd);\r\n            ranges.push({ start: stmtStart, end: lineEnd });\r\n        }\r\n        return ranges;\r\n    }\r\n\r\n    private findLineEnd(text: string, from: number): number {\r\n        const nextNl = text.indexOf('\\n', from);\r\n        if (nextNl === -1) {\r\n            return text.length;\r\n        }\r\n        return nextNl + 1;\r\n    }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\untranslatedCommands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\untranslated\\handlers\\batchRecoveryHandler.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":181,"column":36,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":181,"endColumn":62},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":327,"column":44,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":327,"endColumn":70},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":390,"column":44,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":390,"endColumn":70}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\r\nimport * as path from 'path';\r\nimport { TextDecoder } from 'util';\r\nimport { execFile } from 'child_process';\r\nimport { promisify } from 'util';\r\nimport { LocaleCache, getLocaleCache } from '../utils/localeCache';\r\nimport {\r\n    getKeyPathVariations,\r\n    extractAllUserTextFromContent,\r\n    extractHardcodedStringFromLine,\r\n    calculateTextRelevanceScore,\r\n    extractHintWords,\r\n    escapeRegExp,\r\n} from '../utils';\r\nimport { CommitTracker } from '../../../core/commitTracker';\r\n\r\nconst execFileAsync = promisify(execFile);\r\nconst sharedDecoder = new TextDecoder('utf-8');\r\n\r\nconst GIT_TIMEOUT_MS = 30000;\r\nconst GIT_MAX_BUFFER = 10 * 1024 * 1024;\r\nconst PARALLEL_BATCH_SIZE = 5;\r\n\r\nexport interface BatchRecoveryResult {\r\n    key: string;\r\n    value: string | null;\r\n    source: string;\r\n    error?: string;\r\n}\r\n\r\nexport interface BatchRecoveryOptions {\r\n    daysBack?: number;\r\n    maxCommitsPerFile?: number;\r\n    extractRef?: { commitHash: string } | null;\r\n}\r\n\r\n/**\r\n * High-performance batch recovery handler for bulk fixing missing translations.\r\n * Uses pre-loaded caches and parallel processing for maximum speed.\r\n */\r\nexport class BatchRecoveryHandler {\r\n    private recoveryCache = new Map<string, { value: string; source: string }>();\r\n    private sourceContentCache = new Map<string, string>();\r\n    private diffCache = new Map<string, string>();\r\n\r\n    constructor(\r\n        private context?: vscode.ExtensionContext,\r\n        private log?: vscode.OutputChannel,\r\n    ) {}\r\n\r\n    /**\r\n     * Recover multiple keys in parallel using cached data\r\n     */\r\n    async recoverKeysBatch(\r\n        folder: vscode.WorkspaceFolder,\r\n        keys: string[],\r\n        locale: string,\r\n        options?: BatchRecoveryOptions,\r\n    ): Promise<Map<string, BatchRecoveryResult>> {\r\n        const results = new Map<string, BatchRecoveryResult>();\r\n        const extractRef = options?.extractRef ?? null;\r\n        const maxCommitsPerFile = options?.maxCommitsPerFile ?? 15;\r\n        const daysBack = options?.daysBack ?? 120; // Increased from 90\r\n\r\n        // Initialize cache (respect daysBack for git history window)\r\n        const cache = getLocaleCache(folder, this.log);\r\n        await cache.initialize(locale, daysBack);\r\n\r\n        this.log?.appendLine(`[BatchRecovery] Starting batch recovery for ${keys.length} keys`);\r\n        const startTime = Date.now();\r\n\r\n        // PHASE 1: Check recovery cache for already-found keys\r\n        const uncachedKeys: string[] = [];\r\n        for (const key of keys) {\r\n            const cacheKey = `${folder.uri.fsPath}::${locale}::${key}`;\r\n            const cached = this.recoveryCache.get(cacheKey);\r\n            if (cached) {\r\n                results.set(key, { key, value: cached.value, source: cached.source });\r\n            } else {\r\n                uncachedKeys.push(key);\r\n            }\r\n        }\r\n        \r\n        if (uncachedKeys.length === 0) {\r\n            this.log?.appendLine(`[BatchRecovery] All ${keys.length} keys found in cache`);\r\n            return results;\r\n        }\r\n        \r\n        this.log?.appendLine(`[BatchRecovery] ${results.size} cache hits, ${uncachedKeys.length} to search`);\r\n\r\n        // PHASE 2: Try extractRef commit first (if available)\r\n        if (extractRef) {\r\n            await this.searchExtractRefBatch(folder, cache, uncachedKeys, locale, extractRef.commitHash, results);\r\n        }\r\n\r\n        // Filter out found keys\r\n        let stillMissing = uncachedKeys.filter(k => !results.has(k));\r\n        \r\n        if (stillMissing.length === 0) {\r\n            this.logCompletion(startTime, keys.length, results.size);\r\n            return results;\r\n        }\r\n\r\n        // PHASE 3: Search HEAD content for target locale (fastest)\r\n        this.searchHeadContentBatch(cache, stillMissing, locale, results);\r\n\r\n        // Filter out found keys\r\n        stillMissing = stillMissing.filter(k => !results.has(k));\r\n        \r\n        if (stillMissing.length === 0) {\r\n            this.logCompletion(startTime, keys.length, results.size);\r\n            return results;\r\n        }\r\n\r\n        // PHASE 3.5: Search HEAD content for ALL locales (key might exist in another locale)\r\n        this.searchAllLocalesHeadContent(cache, stillMissing, results);\r\n        stillMissing = stillMissing.filter(k => !results.has(k));\r\n\r\n        if (stillMissing.length === 0) {\r\n            this.logCompletion(startTime, keys.length, results.size);\r\n            return results;\r\n        }\r\n\r\n        // PHASE 4: Search git history for target locale (batched)\r\n        await this.searchGitHistoryBatch(folder, cache, stillMissing, locale, maxCommitsPerFile, results);\r\n\r\n        // Filter out found keys\r\n        stillMissing = stillMissing.filter(k => !results.has(k));\r\n\r\n        if (stillMissing.length === 0) {\r\n            this.logCompletion(startTime, keys.length, results.size);\r\n            return results;\r\n        }\r\n\r\n        // PHASE 4.5: Search git history for ALL locales\r\n        await this.searchAllLocalesGitHistory(folder, cache, stillMissing, locale, maxCommitsPerFile, results);\r\n        stillMissing = stillMissing.filter(k => !results.has(k));\r\n\r\n        if (stillMissing.length === 0) {\r\n            this.logCompletion(startTime, keys.length, results.size);\r\n            return results;\r\n        }\r\n\r\n        // PHASE 5: Search source file git history (backup strategy)\r\n        await this.searchSourceFilesParallel(folder, cache, stillMissing, locale, daysBack, results);\r\n\r\n        this.logCompletion(startTime, keys.length, results.size);\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Search extractRef commit for all keys at once\r\n     */\r\n    private async searchExtractRefBatch(\r\n        folder: vscode.WorkspaceFolder,\r\n        cache: LocaleCache,\r\n        keys: string[],\r\n        locale: string,\r\n        commitHash: string,\r\n        results: Map<string, BatchRecoveryResult>,\r\n    ): Promise<void> {\r\n        this.log?.appendLine(`[BatchRecovery] Checking extract ref commit: ${commitHash}`);\r\n        \r\n        const localeFiles = cache.getLocaleFiles(locale);\r\n        \r\n        // Build all key variations upfront\r\n        const keyVariationsMap = new Map<string, string[]>();\r\n        for (const key of keys) {\r\n            keyVariationsMap.set(key, getKeyPathVariations(key));\r\n        }\r\n\r\n        // Check each locale file\r\n        for (const file of localeFiles) {\r\n            const json = await cache.getContentAtCommit(file.path, commitHash);\r\n            if (!json) continue;\r\n\r\n            // Search all keys in this file\r\n            for (const key of keys) {\r\n                if (results.has(key)) continue;\r\n                \r\n                const variations = keyVariationsMap.get(key)!;\r\n                for (const keyVariant of variations) {\r\n                    const value = this.getNestedValue(json, keyVariant);\r\n                    if (value && typeof value === 'string') {\r\n                        const strValue = String(value);\r\n                        if (this.isSuspiciousKeyValuePair(key, strValue)) {\r\n                            this.log?.appendLine(\r\n                                `[BatchRecovery] Skipping extract-ref candidate for ${keyVariant} because value \"${strValue.slice(0, 50)}...\" looks mismatched with key`,\r\n                            );\r\n                            continue;\r\n                        }\r\n\r\n                        const cacheKey = `${folder.uri.fsPath}::${locale}::${key}`;\r\n                        const result = { value: strValue, source: `ref:${commitHash}` };\r\n                        this.recoveryCache.set(cacheKey, result);\r\n                        results.set(key, { key, value: strValue, source: result.source });\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Search HEAD content for all keys at once\r\n     */\r\n    private searchHeadContentBatch(\r\n        cache: LocaleCache,\r\n        keys: string[],\r\n        locale: string,\r\n        results: Map<string, BatchRecoveryResult>,\r\n    ): void {\r\n        this.log?.appendLine(`[BatchRecovery] Searching HEAD content for ${keys.length} keys in ${locale}`);\r\n        \r\n        const localeFiles = cache.getLocaleFiles(locale);\r\n        \r\n        for (const key of keys) {\r\n            if (results.has(key)) continue;\r\n            \r\n            const variations = getKeyPathVariations(key);\r\n            \r\n            for (const file of localeFiles) {\r\n                const content = cache.getHeadContent(file.path);\r\n                if (!content) continue;\r\n\r\n                for (const keyVariant of variations) {\r\n                    const value = this.getNestedValue(content.json, keyVariant);\r\n                    if (value && typeof value === 'string') {\r\n                        const strValue = String(value);\r\n                        if (this.isSuspiciousKeyValuePair(key, strValue)) {\r\n                            this.log?.appendLine(\r\n                                `[BatchRecovery] Skipping HEAD candidate for ${keyVariant} because value \"${strValue.slice(0, 50)}...\" looks mismatched with key`,\r\n                            );\r\n                            continue;\r\n                        }\r\n\r\n                        results.set(key, { key, value: strValue, source: 'head' });\r\n                        break;\r\n                    }\r\n                }\r\n                \r\n                if (results.has(key)) break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Search HEAD content across ALL locales (key might exist in another locale)\r\n     */\r\n    private searchAllLocalesHeadContent(\r\n        cache: LocaleCache,\r\n        keys: string[],\r\n        results: Map<string, BatchRecoveryResult>,\r\n    ): void {\r\n        this.log?.appendLine(`[BatchRecovery] Searching ALL locales HEAD content for ${keys.length} keys`);\r\n        \r\n        const allFiles = cache.getAllLocaleFiles();\r\n        \r\n        for (const key of keys) {\r\n            if (results.has(key)) continue;\r\n            \r\n            const variations = getKeyPathVariations(key);\r\n            \r\n            for (const file of allFiles) {\r\n                const content = cache.getHeadContent(file.path);\r\n                if (!content) continue;\r\n\r\n                for (const keyVariant of variations) {\r\n                    const value = this.getNestedValue(content.json, keyVariant);\r\n                    if (value && typeof value === 'string') {\r\n                        const strValue = String(value);\r\n                        if (this.isSuspiciousKeyValuePair(key, strValue)) {\r\n                            this.log?.appendLine(\r\n                                `[BatchRecovery] Skipping ALL-locales HEAD candidate for ${keyVariant} because value \"${strValue.slice(0, 50)}...\" looks mismatched with key`,\r\n                            );\r\n                            continue;\r\n                        }\r\n\r\n                        results.set(key, { key, value: strValue, source: `head:${file.locale}` });\r\n                        break;\r\n                    }\r\n                }\r\n                \r\n                if (results.has(key)) break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Search git history for all keys in parallel batches\r\n     */\r\n    private async searchGitHistoryBatch(\r\n        folder: vscode.WorkspaceFolder,\r\n        cache: LocaleCache,\r\n        keys: string[],\r\n        locale: string,\r\n        maxCommitsPerFile: number,\r\n        results: Map<string, BatchRecoveryResult>,\r\n    ): Promise<void> {\r\n        this.log?.appendLine(`[BatchRecovery] Searching git history (${locale}) for ${keys.length} keys`);\r\n        \r\n        const localeFiles = cache.getLocaleFiles(locale);\r\n        \r\n        // Pre-build key variations\r\n        const keyVariationsMap = new Map<string, string[]>();\r\n        for (const key of keys) {\r\n            keyVariationsMap.set(key, getKeyPathVariations(key));\r\n        }\r\n\r\n        // Process files in parallel batches\r\n        for (let i = 0; i < localeFiles.length; i += PARALLEL_BATCH_SIZE) {\r\n            const batch = localeFiles.slice(i, i + PARALLEL_BATCH_SIZE);\r\n            \r\n            await Promise.all(batch.map(async (file) => {\r\n                const history = cache.getGitHistory(file.path);\r\n                if (!history || history.commits.length === 0) return;\r\n\r\n                const commitsToCheck = history.commits.slice(0, maxCommitsPerFile);\r\n                \r\n                for (const commit of commitsToCheck) {\r\n                    const json = await cache.getContentAtCommit(file.path, commit.hash);\r\n                    if (!json) continue;\r\n\r\n                    for (const key of keys) {\r\n                        if (results.has(key)) continue;\r\n                        \r\n                        const variations = keyVariationsMap.get(key)!;\r\n                        for (const keyVariant of variations) {\r\n                            const value = this.getNestedValue(json, keyVariant);\r\n                            if (value && typeof value === 'string') {\r\n                                const strValue = String(value);\r\n                                if (this.isSuspiciousKeyValuePair(key, strValue)) {\r\n                                    this.log?.appendLine(\r\n                                        `[BatchRecovery] Skipping history candidate for ${keyVariant} because value \"${strValue.slice(0, 50)}...\" looks mismatched with key`,\r\n                                    );\r\n                                    continue;\r\n                                }\r\n\r\n                                const cacheKey = `${folder.uri.fsPath}::${locale}::${key}`;\r\n                                const result = { value: strValue, source: `history:${commit.hash}` };\r\n                                this.recoveryCache.set(cacheKey, result);\r\n                                results.set(key, { key, value: strValue, source: result.source });\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Search git history across ALL locales for missing keys\r\n     */\r\n    private async searchAllLocalesGitHistory(\r\n        folder: vscode.WorkspaceFolder,\r\n        cache: LocaleCache,\r\n        keys: string[],\r\n        requestedLocale: string,\r\n        maxCommitsPerFile: number,\r\n        results: Map<string, BatchRecoveryResult>,\r\n    ): Promise<void> {\r\n        this.log?.appendLine(`[BatchRecovery] Searching ALL locales git history for ${keys.length} keys`);\r\n        \r\n        const allFiles = cache.getAllLocaleFiles();\r\n        \r\n        // Pre-build key variations\r\n        const keyVariationsMap = new Map<string, string[]>();\r\n        for (const key of keys) {\r\n            keyVariationsMap.set(key, getKeyPathVariations(key));\r\n        }\r\n\r\n        // Process files in parallel batches\r\n        for (let i = 0; i < allFiles.length; i += PARALLEL_BATCH_SIZE) {\r\n            const batch = allFiles.slice(i, i + PARALLEL_BATCH_SIZE);\r\n            \r\n            await Promise.all(batch.map(async (file) => {\r\n                const history = cache.getGitHistory(file.path);\r\n                if (!history || history.commits.length === 0) return;\r\n\r\n                const commitsToCheck = history.commits.slice(0, maxCommitsPerFile);\r\n                \r\n                for (const commit of commitsToCheck) {\r\n                    const json = await cache.getContentAtCommit(file.path, commit.hash);\r\n                    if (!json) continue;\r\n\r\n                    for (const key of keys) {\r\n                        if (results.has(key)) continue;\r\n                        \r\n                        const variations = keyVariationsMap.get(key)!;\r\n                        for (const keyVariant of variations) {\r\n                            const value = this.getNestedValue(json, keyVariant);\r\n                            if (value && typeof value === 'string') {\r\n                                const strValue = String(value);\r\n                                if (this.isSuspiciousKeyValuePair(key, strValue)) {\r\n                                    this.log?.appendLine(\r\n                                        `[BatchRecovery] Skipping ALL-locales history candidate for ${keyVariant} because value \"${strValue.slice(0, 50)}...\" looks mismatched with key`,\r\n                                    );\r\n                                    continue;\r\n                                }\r\n\r\n                                // Cache under the requested locale to align with lookups\r\n                                const cacheKey = `${folder.uri.fsPath}::${requestedLocale}::${key}`;\r\n                                const result = { value: strValue, source: `history:${file.locale}:${commit.hash}` };\r\n                                this.recoveryCache.set(cacheKey, result);\r\n                                results.set(key, { key, value: strValue, source: result.source });\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Search source files for original hardcoded text in parallel\r\n     */\r\n    private async searchSourceFilesParallel(\r\n        folder: vscode.WorkspaceFolder,\r\n        cache: LocaleCache,\r\n        keys: string[],\r\n        locale: string,\r\n        daysBack: number,\r\n        results: Map<string, BatchRecoveryResult>,\r\n    ): Promise<void> {\r\n        this.log?.appendLine(`[BatchRecovery] Searching source files for ${keys.length} keys`);\r\n        \r\n        // Build source file index for all missing keys at once\r\n        await cache.buildSourceFileKeyIndex(keys);\r\n\r\n        // Process keys in parallel\r\n        for (let i = 0; i < keys.length; i += PARALLEL_BATCH_SIZE) {\r\n            const batch = keys.slice(i, i + PARALLEL_BATCH_SIZE);\r\n            \r\n            await Promise.allSettled(batch.map(async (key) => {\r\n                if (results.has(key)) return;\r\n                \r\n                const sourceFiles = cache.getSourceFilesForKey(key);\r\n                if (sourceFiles.length === 0) {\r\n                    results.set(key, { key, value: null, source: 'not_found' });\r\n                    return;\r\n                }\r\n\r\n                const result = await this.extractOriginalTextFromSource(folder, sourceFiles[0], key, daysBack);\r\n                if (result) {\r\n                    const cacheKey = `${folder.uri.fsPath}::${locale}::${key}`;\r\n                    this.recoveryCache.set(cacheKey, result);\r\n                    results.set(key, { key, value: result.value, source: result.source });\r\n                } else {\r\n                    results.set(key, { key, value: null, source: 'not_found' });\r\n                }\r\n            }));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Extract original hardcoded text from source file git history\r\n     */\r\n    private async extractOriginalTextFromSource(\r\n        folder: vscode.WorkspaceFolder,\r\n        sourceFilePath: string,\r\n        key: string,\r\n        daysBack: number,\r\n    ): Promise<{ value: string; source: string } | null> {\r\n        const relPath = path.relative(folder.uri.fsPath, sourceFilePath);\r\n\r\n        // Get current content\r\n        let currentContent = this.sourceContentCache.get(sourceFilePath);\r\n        if (!currentContent) {\r\n            try {\r\n                const data = await vscode.workspace.fs.readFile(vscode.Uri.file(sourceFilePath));\r\n                currentContent = sharedDecoder.decode(data);\r\n                this.sourceContentCache.set(sourceFilePath, currentContent);\r\n            } catch {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        const tCallPattern = new RegExp(`\\\\b\\\\$?t\\\\(\\\\s*['\"]${escapeRegExp(key)}['\"]`);\r\n        const placeholderHints = this.extractPlaceholderHintsFromContent(currentContent, key);\r\n\r\n        // Get file history\r\n        try {\r\n            type CommitEntry = { hash: string; message: string };\r\n            let commits: CommitEntry[] = [];\r\n            const baseArgs = ['log', `--since=${daysBack} days ago`, '-n', '30', '--format=%H|%s', '--', relPath.replace(/\\\\/g, '/')];\r\n            const { stdout } = await execFileAsync(\r\n                'git',\r\n                baseArgs,\r\n                { cwd: folder.uri.fsPath, timeout: GIT_TIMEOUT_MS, maxBuffer: GIT_MAX_BUFFER },\r\n            );\r\n\r\n            commits = stdout\r\n                .trim()\r\n                .split('\\n')\r\n                .filter(Boolean)\r\n                .map((line) => {\r\n                    const [hash, ...msgParts] = line.split('|');\r\n                    return { hash: hash.trim(), message: msgParts.join('|').trim() };\r\n                })\r\n                .filter((c) => c.hash);\r\n\r\n            // Fallback: if no commits in window, grab most recent history without date limit\r\n            if (commits.length === 0) {\r\n                const { stdout: fallback } = await execFileAsync(\r\n                    'git',\r\n                    ['log', '-n', '30', '--format=%H|%s', '--', relPath.replace(/\\\\/g, '/')],\r\n                    { cwd: folder.uri.fsPath, timeout: GIT_TIMEOUT_MS, maxBuffer: GIT_MAX_BUFFER },\r\n                );\r\n                commits = fallback\r\n                    .trim()\r\n                    .split('\\n')\r\n                    .filter(Boolean)\r\n                    .map((line) => {\r\n                        const [hash, ...msgParts] = line.split('|');\r\n                        return { hash: hash.trim(), message: msgParts.join('|').trim() };\r\n                    })\r\n                    .filter((c) => c.hash);\r\n            }\r\n\r\n            if (commits.length < 2) return null;\r\n\r\n            // Find the commit that introduced the t() call\r\n            let commitWithTCall: string | null = null;\r\n            let commitWithoutTCall: string | null = null;\r\n\r\n            for (let i = 0; i < commits.length - 1; i++) {\r\n                const content = await this.getSourceContentAtCommit(folder, sourceFilePath, commits[i].hash);\r\n                if (!content) continue;\r\n\r\n                if (tCallPattern.test(content)) {\r\n                    commitWithTCall = commits[i].hash;\r\n                    const nextContent = await this.getSourceContentAtCommit(folder, sourceFilePath, commits[i + 1].hash);\r\n                    if (nextContent && !tCallPattern.test(nextContent)) {\r\n                        commitWithoutTCall = commits[i + 1].hash;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Priority: check commits mentioning i18n/translate with their previous commit\r\n            const keywordIndex = commits.findIndex((hash) => {\r\n                return /i18n|translat|lang|locale|intl/i.test(hash.message);\r\n            });\r\n            if (keywordIndex > -1 && keywordIndex + 1 < commits.length) {\r\n                const fromCommit = commits[keywordIndex + 1].hash;\r\n                const toCommit = commits[keywordIndex].hash;\r\n                const result = await this.extractFromDiff(folder, sourceFilePath, fromCommit, toCommit, key, placeholderHints);\r\n                if (result) {\r\n                    return { value: result, source: `diff:${fromCommit.slice(0, 7)}..${toCommit.slice(0, 7)}` };\r\n                }\r\n            }\r\n\r\n            if (!commitWithTCall || !commitWithoutTCall) return null;\r\n\r\n            // Get diff between commits\r\n            const result = await this.extractFromDiff(folder, sourceFilePath, commitWithoutTCall, commitWithTCall, key, placeholderHints);\r\n            if (result) {\r\n                return { value: result, source: `diff:${commitWithoutTCall.slice(0, 7)}..${commitWithTCall.slice(0, 7)}` };\r\n            }\r\n\r\n            // Fallback: search old content for matching text\r\n            const oldContent = await this.getSourceContentAtCommit(folder, sourceFilePath, commitWithoutTCall);\r\n            if (oldContent) {\r\n                const hintWords = extractHintWords(key);\r\n                const candidates = extractAllUserTextFromContent(oldContent, hintWords);\r\n                if (candidates.length > 0) {\r\n                    candidates.sort((a, b) => b.score - a.score);\r\n                    if (candidates[0].score >= 5) {\r\n                        return {\r\n                            value: candidates[0].text,\r\n                            source: `source:${commitWithoutTCall.slice(0, 7)}`,\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        } catch {\r\n            // Git operation failed\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get source file content at a specific commit\r\n     */\r\n    private async getSourceContentAtCommit(\r\n        folder: vscode.WorkspaceFolder,\r\n        filePath: string,\r\n        commitHash: string,\r\n    ): Promise<string | null> {\r\n        const cacheKey = `src:${filePath}:${commitHash}`;\r\n        if (this.sourceContentCache.has(cacheKey)) {\r\n            return this.sourceContentCache.get(cacheKey) || null;\r\n        }\r\n\r\n        try {\r\n            const relPath = path.relative(folder.uri.fsPath, filePath).replace(/\\\\/g, '/');\r\n            const { stdout } = await execFileAsync(\r\n                'git',\r\n                ['show', `${commitHash}:${relPath}`],\r\n                { cwd: folder.uri.fsPath, timeout: GIT_TIMEOUT_MS, maxBuffer: GIT_MAX_BUFFER },\r\n            );\r\n            this.sourceContentCache.set(cacheKey, stdout);\r\n            return stdout;\r\n        } catch {\r\n            this.sourceContentCache.set(cacheKey, '');\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Extract original text from git diff\r\n     */\r\n    private async extractFromDiff(\r\n        folder: vscode.WorkspaceFolder,\r\n        filePath: string,\r\n        fromCommit: string,\r\n        toCommit: string,\r\n        key: string,\r\n        placeholderHints: string[] = [],\r\n    ): Promise<string | null> {\r\n        const diffKey = `${filePath}:${fromCommit}:${toCommit}`;\r\n        let diff = this.diffCache.get(diffKey);\r\n\r\n        if (!diff) {\r\n            try {\r\n                const relPath = path.relative(folder.uri.fsPath, filePath).replace(/\\\\/g, '/');\r\n                const { stdout } = await execFileAsync(\r\n                    'git',\r\n                    ['diff', fromCommit, toCommit, '--', relPath],\r\n                    { cwd: folder.uri.fsPath, timeout: GIT_TIMEOUT_MS, maxBuffer: GIT_MAX_BUFFER },\r\n                );\r\n                diff = stdout;\r\n                this.diffCache.set(diffKey, diff);\r\n            } catch {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        if (!diff) return null;\r\n\r\n        const tCallPattern = new RegExp(`\\\\b\\\\$?t\\\\(\\\\s*['\"]${escapeRegExp(key)}['\"]`);\r\n        const hintWords = extractHintWords(key);\r\n        const diffLines = diff.split('\\n');\r\n        const hunkRemovedTexts: Array<{ text: string; score: number }> = [];\r\n        \r\n        let currentHunkRemoved: string[] = [];\r\n        let currentHunkAdded: string[] = [];\r\n\r\n        for (const line of diffLines) {\r\n            if (line.startsWith('@@')) {\r\n                const addedHasT = currentHunkAdded.some(l => tCallPattern.test(l));\r\n                if (addedHasT) {\r\n                    for (const removed of currentHunkRemoved) {\r\n                        const texts = extractAllUserTextFromContent(removed, hintWords);\r\n                        hunkRemovedTexts.push(\r\n                            ...texts\r\n                                .map(t => {\r\n                                    const lower = t.text.toLowerCase();\r\n                                    const hintMatches = hintWords.filter(h => lower.includes(h)).length;\r\n                                    const phMatches = placeholderHints.filter(p => lower.includes(p)).length;\r\n                                    if (hintMatches === 0 && phMatches === 0) {\r\n                                        return null;\r\n                                    }\r\n                                    let score = t.score;\r\n                                    if (phMatches > 0) score += 3 * phMatches;\r\n                                    score += addedHasT ? 3 : 0;\r\n                                    return { text: t.text, score };\r\n                                })\r\n                                .filter(Boolean) as Array<{ text: string; score: number }>\r\n                        );\r\n                    }\r\n                }\r\n                currentHunkRemoved = [];\r\n                currentHunkAdded = [];\r\n                continue;\r\n            }\r\n\r\n            if (line.startsWith('-') && !line.startsWith('---')) {\r\n                currentHunkRemoved.push(line.slice(1));\r\n            } else if (line.startsWith('+') && !line.startsWith('+++')) {\r\n                currentHunkAdded.push(line.slice(1));\r\n            }\r\n        }\r\n\r\n        // Process last hunk\r\n        if (currentHunkAdded.some(l => tCallPattern.test(l))) {\r\n            for (const removed of currentHunkRemoved) {\r\n                const texts = extractAllUserTextFromContent(removed, hintWords);\r\n                hunkRemovedTexts.push(\r\n                    ...texts\r\n                        .map(t => {\r\n                            const lower = t.text.toLowerCase();\r\n                            const hintMatches = hintWords.filter(h => lower.includes(h)).length;\r\n                            const phMatches = placeholderHints.filter(p => lower.includes(p)).length;\r\n                            if (hintMatches === 0 && phMatches === 0) return null;\r\n                            let score = t.score;\r\n                            if (phMatches > 0) score += 3 * phMatches;\r\n                            score += 3;\r\n                            return { text: t.text, score };\r\n                        })\r\n                        .filter(Boolean) as Array<{ text: string; score: number }>\r\n                );\r\n            }\r\n        }\r\n\r\n        // Extract from individual removed lines\r\n        for (const line of diffLines) {\r\n            if (line.startsWith('-') && !line.startsWith('---')) {\r\n                const extracted = extractHardcodedStringFromLine(line.slice(1), key);\r\n                if (extracted) {\r\n                    const lower = extracted.toLowerCase();\r\n                    const hintMatches = hintWords.filter(h => lower.includes(h)).length;\r\n                    const phMatches = placeholderHints.filter(p => lower.includes(p)).length;\r\n                    if (extracted.includes('.') && !/\\s/.test(extracted)) continue;\r\n                    if (hintMatches === 0 && phMatches === 0) {\r\n                        continue;\r\n                    }\r\n                    const score = calculateTextRelevanceScore(extracted, hintWords) + 5 + (phMatches > 0 ? 3 * phMatches : 0);\r\n                    hunkRemovedTexts.push({ text: extracted, score });\r\n                }\r\n            }\r\n        }\r\n\r\n        if (hunkRemovedTexts.length > 0) {\r\n            hunkRemovedTexts.sort((a, b) => b.score - a.score);\r\n            if (hunkRemovedTexts[0].score >= 3) {\r\n                return hunkRemovedTexts[0].text;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private extractPlaceholderHintsFromContent(content: string, key: string): string[] {\r\n        const placeholders = new Set<string>();\r\n        const pattern = new RegExp(`\\\\bt\\\\(\\\\s*['\"]${escapeRegExp(key)}['\"]\\\\s*,\\\\s*\\\\{([^}]+)\\\\}`, 'g');\r\n        let match;\r\n        while ((match = pattern.exec(content)) !== null) {\r\n            const obj = match[1];\r\n            const props = obj.split(/[:,]/).map((p) => p.trim());\r\n            for (const p of props) {\r\n                if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(p)) {\r\n                    placeholders.add(p.toLowerCase());\r\n                }\r\n            }\r\n        }\r\n        return Array.from(placeholders);\r\n    }\r\n\r\n    /**\r\n     * Get nested value from object using dot notation path\r\n     */\r\n    private getNestedValue(obj: any, path: string): any {\r\n        const segments = path.split('.').filter(Boolean);\r\n        let current = obj;\r\n        for (const segment of segments) {\r\n            if (!current || typeof current !== 'object' || Array.isArray(current)) {\r\n                return undefined;\r\n            }\r\n            if (!Object.prototype.hasOwnProperty.call(current, segment)) {\r\n                return undefined;\r\n            }\r\n            current = current[segment];\r\n        }\r\n        return current;\r\n    }\r\n\r\n    private isLabelishKeyPath(key: string): boolean {\r\n        const parts = key.split('.').filter(Boolean).map((p) => p.toLowerCase());\r\n        if (!parts.length) return false;\r\n        const labelish = new Set([\r\n            'label',\r\n            'title',\r\n            'name',\r\n            'status',\r\n            'state',\r\n            'code',\r\n            'id',\r\n            'heading',\r\n            'caption',\r\n            'short',\r\n            'tag',\r\n            'badge',\r\n        ]);\r\n        for (const part of parts) {\r\n            if (labelish.has(part)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private looksLikeLongSentence(text: string): boolean {\r\n        const trimmed = text.trim();\r\n        if (!trimmed) return false;\r\n        const words = trimmed.split(/\\s+/).filter(Boolean);\r\n        const wordCount = words.length;\r\n        if (/[.!?]/.test(trimmed)) {\r\n            if (wordCount >= 4) {\r\n                return true;\r\n            }\r\n        }\r\n        if (/^\\s*(we|you|i|they|he|she|it)\\b/i.test(trimmed) && wordCount >= 4) {\r\n            return true;\r\n        }\r\n        if (wordCount >= 10) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private isSuspiciousKeyValuePair(key: string, value: string): boolean {\r\n        if (!this.isLabelishKeyPath(key)) {\r\n            return false;\r\n        }\r\n        return this.looksLikeLongSentence(value);\r\n    }\r\n\r\n    /**\r\n     * Get extract commit ref from commit tracker\r\n     */\r\n    getExtractCommitRef(folder: vscode.WorkspaceFolder): { commitHash: string } | null {\r\n        if (!this.context) return null;\r\n        return CommitTracker.getExtractCommitRef(this.context, folder);\r\n    }\r\n\r\n    private logCompletion(startTime: number, totalKeys: number, foundKeys: number): void {\r\n        const elapsed = Date.now() - startTime;\r\n        this.log?.appendLine(\r\n            `[BatchRecovery] Completed in ${elapsed}ms: ${foundKeys}/${totalKeys} keys recovered`\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Clear all caches\r\n     */\r\n    clearCaches(): void {\r\n        this.recoveryCache.clear();\r\n        this.sourceContentCache.clear();\r\n        this.diffCache.clear();\r\n    }\r\n}\r\n\r\n// Singleton instance per extension context\r\nlet batchRecoveryInstance: BatchRecoveryHandler | null = null;\r\n\r\nexport function getBatchRecoveryHandler(\r\n    context?: vscode.ExtensionContext,\r\n    log?: vscode.OutputChannel,\r\n): BatchRecoveryHandler {\r\n    if (!batchRecoveryInstance) {\r\n        batchRecoveryInstance = new BatchRecoveryHandler(context, log);\r\n    }\r\n    return batchRecoveryInstance;\r\n}\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\untranslated\\handlers\\cleanupHandler.ts","messages":[{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":127,"column":17,"nodeType":"BlockStatement","messageId":"unexpected","endLine":127,"endColumn":19,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[4686,4686],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":180,"column":25,"nodeType":"BlockStatement","messageId":"unexpected","endLine":180,"endColumn":27,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[6833,6833],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":190,"column":69,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":190,"endColumn":76},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":468,"column":17,"nodeType":"BlockStatement","messageId":"unexpected","endLine":468,"endColumn":19,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[17927,17927],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":515,"column":65,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":515,"endColumn":72,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[19968,19969],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":539,"column":25,"nodeType":"BlockStatement","messageId":"unexpected","endLine":539,"endColumn":27,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[21105,21105],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":559,"column":81,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":559,"endColumn":88},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'usages' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":862,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":862,"endColumn":21}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\nimport { I18nIndex } from '../../../core/i18nIndex';\nimport { pickWorkspaceFolder, runI18nScript } from '../../../core/workspace';\nimport {\n    sharedDecoder,\n    readJsonFile,\n    writeJsonFile,\n    hasKeyPathInObject,\n    deleteKeyPathInObject,\n} from '../utils/jsonUtils';\nimport { operationLock, OperationType } from '../utils/operationLock';\n\nexport class CleanupHandler {\n    constructor(\n        private i18nIndex: I18nIndex,\n        private deleteKeyFromLocaleFiles: (keyPath: string, uris: vscode.Uri[], defaultValue?: string) => Promise<number>,\n    ) {}\n\n    /**\n     * Check if operation can proceed, showing warning if blocked\n     */\n    private async canProceed(operationType: OperationType, description: string): Promise<boolean> {\n        if (!operationLock.isOperationRunning()) {\n            return true;\n        }\n        const current = operationLock.getCurrentOperation();\n        if (current?.type === operationType) {\n            return true;\n        }\n        const blockingMsg = operationLock.getBlockingOperationMessage();\n        vscode.window.showWarningMessage(\n            `AI Localizer: Cannot start \"${description}\" - ${blockingMsg}. Please wait for it to complete.`\n        );\n        return false;\n    }\n\n    /**\n     * Cleanup unused keys in a locale file\n     */\n    async cleanupUnusedInFile(documentUri?: vscode.Uri): Promise<void> {\n        const targetUri = documentUri || vscode.window.activeTextEditor?.document.uri;\n        if (!targetUri) {\n            vscode.window.showInformationMessage(\n                'AI Localizer: No active document to cleanup unused keys.',\n            );\n            return;\n        }\n\n        // Check if another operation is blocking\n        if (!(await this.canProceed('cleanup-unused', 'Cleanup Unused Keys'))) {\n            return;\n        }\n\n        const doc = await vscode.workspace.openTextDocument(targetUri);\n        if (doc.languageId !== 'json' && doc.languageId !== 'jsonc') {\n            vscode.window.showInformationMessage(\n                'AI Localizer: Cleanup unused keys only applies to locale JSON files.',\n            );\n            return;\n        }\n\n        let folder = vscode.workspace.getWorkspaceFolder(targetUri) ?? undefined;\n        if (!folder) {\n            folder = await pickWorkspaceFolder();\n        }\n        if (!folder) {\n            vscode.window.showInformationMessage('AI Localizer: No workspace folder available.');\n            return;\n        }\n\n        const scriptsDir = vscode.Uri.joinPath(folder.uri, 'scripts');\n        const reportUri = vscode.Uri.joinPath(scriptsDir, '.i18n-unused-report.json');\n\n        let rawReport: string;\n        try {\n            const data = await vscode.workspace.fs.readFile(reportUri);\n            rawReport = sharedDecoder.decode(data);\n        } catch {\n            const choice = await vscode.window.showQuickPick(\n                [\n                    {\n                        label: 'Generate report',\n                        description:\n                            'Run i18n:cleanup-unused script now to analyze and generate the unused keys report.',\n                    },\n                    { label: 'Cancel', description: 'Skip cleaning up unused keys for now.' },\n                ],\n                {\n                    placeHolder:\n                        'AI Localizer: Unused keys report not found. Generate it by running the cleanup script?',\n                },\n            );\n            if (!choice || choice.label !== 'Generate report') {\n                return;\n            }\n            await runI18nScript('i18n:cleanup-unused');\n            vscode.window.showInformationMessage(\n                'AI Localizer: Running i18n:cleanup-unused script in a terminal. Re-run this quick fix after it completes.',\n            );\n            return;\n        }\n\n        let report: any;\n        try {\n            report = JSON.parse(rawReport);\n        } catch {\n            vscode.window.showErrorMessage(\n                'AI Localizer: Unused keys report is not valid JSON.',\n            );\n            return;\n        }\n\n        const allUnused = Array.isArray(report.unused) ? report.unused : [];\n        if (!allUnused.length) {\n            vscode.window.showInformationMessage(\n                'AI Localizer: No unused keys found in unused keys report.',\n            );\n            return;\n        }\n\n        // Parse the current file to find which keys exist in it\n        let root: any = {};\n        try {\n            const text = doc.getText();\n            const parsed = JSON.parse(text);\n            if (parsed && typeof parsed === 'object') root = parsed;\n        } catch {}\n        if (!root || typeof root !== 'object' || Array.isArray(root)) root = {};\n\n        // Filter to only keys that exist in this file\n        const unused = allUnused.filter((item: any) => {\n            if (!item || typeof item.keyPath !== 'string') return false;\n            return hasKeyPathInObject(root, item.keyPath);\n        });\n\n        if (!unused.length) {\n            vscode.window.showInformationMessage(\n                'AI Localizer: No unused keys from report were found in this file.',\n            );\n            return;\n        }\n\n        const choice = await vscode.window.showQuickPick(\n            [\n                {\n                    label: 'Remove unused keys in this file',\n                    description: `Remove ${unused.length} unused key(s) from this locale file only.`,\n                },\n                {\n                    label: 'Remove unused keys in all locale files',\n                    description: `Remove ${unused.length} unused key(s) from this and all other locale files.`,\n                },\n                {\n                    label: 'Cancel',\n                    description: 'Do not remove keys.',\n                },\n            ],\n            {\n                placeHolder: `AI Localizer: Remove ${unused.length} unused key(s) found in this file?`,\n            },\n        );\n        if (!choice || choice.label === 'Cancel') {\n            return;\n        }\n\n        const applyToAllLocales = choice.label === 'Remove unused keys in all locale files';\n\n        // Acquire lock before modifying files\n        const result = await operationLock.withGlobalLock(\n            'cleanup-unused',\n            'Cleanup Unused Keys',\n            async () => {\n                // Re-read the file to get fresh content (avoid stale data)\n                let freshRoot: any = {};\n                try {\n                    const freshDoc = await vscode.workspace.openTextDocument(targetUri);\n                    const text = freshDoc.getText();\n                    const parsed = JSON.parse(text);\n                    if (parsed && typeof parsed === 'object') freshRoot = parsed;\n                } catch {}\n                if (!freshRoot || typeof freshRoot !== 'object' || Array.isArray(freshRoot)) {\n                    freshRoot = {};\n                }\n\n                const deletedKeys = new Set<string>();\n                const keysStillInUse: string[] = [];\n                for (const item of unused) {\n                    if (!item || typeof item.keyPath !== 'string') continue;\n                    const keyPath = item.keyPath;\n                    const hasUsage = await this.checkKeyUsageInCode(folder!, keyPath);\n                    if (hasUsage) {\n                        keysStillInUse.push(keyPath);\n                        continue;\n                    }\n                    if (deleteKeyPathInObject(freshRoot, keyPath)) {\n                        deletedKeys.add(keyPath);\n                    }\n                }\n\n                if (!deletedKeys.size) {\n                    return { deletedKeys, deletedFromOtherFiles: 0, keysStillInUse };\n                }\n\n                await operationLock.withFileLock(targetUri, 'cleanup-unused', async () => {\n                    await writeJsonFile(targetUri, freshRoot);\n                });\n\n                await this.i18nIndex.updateFile(targetUri);\n                await vscode.commands.executeCommand(\n                    'ai-localizer.i18n.refreshFileDiagnostics',\n                    targetUri,\n                    Array.from(deletedKeys),\n                );\n\n                let deletedFromOtherFiles = 0;\n\n                if (applyToAllLocales && deletedKeys.size > 0) {\n                    await this.i18nIndex.ensureInitialized();\n                    for (const keyPath of deletedKeys) {\n                        const record = this.i18nIndex.getRecord(keyPath);\n                        if (!record) continue;\n                        const otherUris = record.locations\n                            .map((l) => l.uri)\n                            .filter((u) => u.toString() !== targetUri.toString());\n                        if (!otherUris.length) continue;\n                        deletedFromOtherFiles += await this.deleteKeyFromLocaleFiles(keyPath, otherUris);\n                    }\n                }\n\n                return { deletedKeys, deletedFromOtherFiles, keysStillInUse };\n            }\n        );\n\n        if (!result) {\n            return;\n        }\n\n        const { deletedKeys, deletedFromOtherFiles, keysStillInUse } = result;\n\n        if (!deletedKeys.size) {\n            if (keysStillInUse && keysStillInUse.length > 0) {\n                vscode.window.showInformationMessage(\n                    `AI Localizer: Skipped ${keysStillInUse.length} key(s) because they are still referenced in source code. No unused keys were removed from this file.`,\n                );\n            } else {\n                vscode.window.showInformationMessage(\n                    'AI Localizer: No unused keys were removed from this file.',\n                );\n            }\n            return;\n        }\n\n        let message: string;\n        if (deletedFromOtherFiles > 0) {\n            message = `AI Localizer: Removed ${deletedKeys.size} unused key(s) from this file and cleaned up unused keys in ${deletedFromOtherFiles} other locale file(s).`;\n        } else {\n            message = `AI Localizer: Removed ${deletedKeys.size} unused key(s) from this file.`;\n        }\n\n        if (keysStillInUse && keysStillInUse.length > 0) {\n            message += ` ${keysStillInUse.length} key(s) were skipped because they are still referenced in source code.`;\n        }\n\n        vscode.window.showInformationMessage(message);\n    }\n\n    /**\n     * Remove a single unused key from a locale file\n     */\n    async removeUnusedKeyInFile(documentUri: vscode.Uri, keyPath: string): Promise<void> {\n        if (!documentUri) {\n            vscode.window.showInformationMessage(\n                'AI Localizer: No document provided to remove unused key.',\n            );\n            return;\n        }\n\n        const doc = await vscode.workspace.openTextDocument(documentUri);\n        if (doc.languageId !== 'json' && doc.languageId !== 'jsonc') {\n            vscode.window.showInformationMessage(\n                'AI Localizer: Remove unused key only applies to locale JSON files.',\n            );\n            return;\n        }\n\n        let folder = vscode.workspace.getWorkspaceFolder(documentUri) ?? undefined;\n        if (!folder) {\n            folder = await pickWorkspaceFolder();\n        }\n        if (!folder) {\n            vscode.window.showInformationMessage('AI Localizer: No workspace folder available.');\n            return;\n        }\n\n        const scriptsDir = vscode.Uri.joinPath(folder.uri, 'scripts');\n        const reportUri = vscode.Uri.joinPath(scriptsDir, '.i18n-unused-report.json');\n\n        let rawReport: string;\n        try {\n            const data = await vscode.workspace.fs.readFile(reportUri);\n            rawReport = sharedDecoder.decode(data);\n        } catch {\n            const choice = await vscode.window.showQuickPick(\n                [\n                    {\n                        label: 'Generate report',\n                        description:\n                            'Run i18n:cleanup-unused script now to analyze and generate the unused keys report.',\n                    },\n                    { label: 'Cancel', description: 'Skip removing this unused key for now.' },\n                ],\n                {\n                    placeHolder:\n                        'AI Localizer: Unused keys report not found. Generate it by running the cleanup script?',\n                },\n            );\n            if (!choice || choice.label !== 'Generate report') {\n                return;\n            }\n            await runI18nScript('i18n:cleanup-unused');\n            vscode.window.showInformationMessage(\n                'AI Localizer: Running i18n:cleanup-unused script in a terminal. Re-run this quick fix after it completes.',\n            );\n            return;\n        }\n\n        let report: any;\n        try {\n            report = JSON.parse(rawReport);\n        } catch {\n            vscode.window.showErrorMessage(\n                'AI Localizer: Unused keys report is not valid JSON.',\n            );\n            return;\n        }\n\n        const unused = Array.isArray(report.unused) ? report.unused : [];\n        const hasEntry = unused.some(\n            (item: any) => item && typeof item.keyPath === 'string' && item.keyPath === keyPath,\n        );\n        if (!hasEntry) {\n            vscode.window.showInformationMessage(\n                `AI Localizer: Key ${keyPath} is not marked as unused in unused keys report.`,\n            );\n        }\n\n        let root: any = await readJsonFile(documentUri) || {};\n        if (!root || typeof root !== 'object' || Array.isArray(root)) root = {};\n\n        const inUse = await this.checkKeyUsageInCode(folder, keyPath);\n        if (inUse) {\n            vscode.window.showInformationMessage(\n                `AI Localizer: Key ${keyPath} is still referenced in source code. Skipping removal.`,\n            );\n            return;\n        }\n\n        if (!deleteKeyPathInObject(root, keyPath)) {\n            vscode.window.showInformationMessage(\n                `AI Localizer: Key ${keyPath} was not found in this file.`,\n            );\n            return;\n        }\n\n        await writeJsonFile(documentUri, root);\n\n        await this.i18nIndex.updateFile(documentUri);\n        await vscode.commands.executeCommand(\n            'ai-localizer.i18n.refreshFileDiagnostics',\n            documentUri,\n            [keyPath],\n        );\n\n        vscode.window.showInformationMessage(\n            `AI Localizer: Removed unused key ${keyPath} from this file.`,\n        );\n    }\n\n    /**\n     * Restore invalid keys in a locale file\n     */\n    async restoreInvalidInFile(documentUri?: vscode.Uri): Promise<void> {\n        const targetUri = documentUri || vscode.window.activeTextEditor?.document.uri;\n        if (!targetUri) {\n            vscode.window.showInformationMessage(\n                'AI Localizer: No active document to cleanup invalid keys.',\n            );\n            return;\n        }\n\n        // Check if another operation is blocking\n        if (!(await this.canProceed('cleanup-invalid', 'Restore Invalid Keys'))) {\n            return;\n        }\n\n        const doc = await vscode.workspace.openTextDocument(targetUri);\n        if (doc.languageId !== 'json' && doc.languageId !== 'jsonc') {\n            vscode.window.showInformationMessage(\n                'AI Localizer: Restore invalid keys only applies to locale JSON files.',\n            );\n            return;\n        }\n\n        let folder = vscode.workspace.getWorkspaceFolder(targetUri) ?? undefined;\n        if (!folder) {\n            folder = await pickWorkspaceFolder();\n        }\n        if (!folder) {\n            vscode.window.showInformationMessage('AI Localizer: No workspace folder available.');\n            return;\n        }\n\n        const scriptsDir = vscode.Uri.joinPath(folder.uri, 'scripts');\n        const reportUri = vscode.Uri.joinPath(scriptsDir, '.i18n-invalid-report.json');\n\n        let rawReport: string;\n        try {\n            const data = await vscode.workspace.fs.readFile(reportUri);\n            rawReport = sharedDecoder.decode(data);\n        } catch {\n            const choice = await vscode.window.showQuickPick(\n                [\n                    {\n                        label: 'Generate report',\n                        description:\n                            'Run i18n:restore-invalid script now to analyze and generate the invalid keys report.',\n                    },\n                    { label: 'Cancel', description: 'Skip cleaning up invalid keys for now.' },\n                ],\n                {\n                    placeHolder:\n                        'AI Localizer: Invalid keys report not found. Generate it by running the restore-invalid script?',\n                },\n            );\n            if (!choice || choice.label !== 'Generate report') {\n                return;\n            }\n            await runI18nScript('i18n:restore-invalid');\n            vscode.window.showInformationMessage(\n                'AI Localizer: Running i18n:restore-invalid script in a terminal. Re-run this quick fix after it completes.',\n            );\n            return;\n        }\n\n        let report: any;\n        try {\n            report = JSON.parse(rawReport);\n        } catch {\n            vscode.window.showErrorMessage(\n                'AI Localizer: Invalid keys report is not valid JSON.',\n            );\n            return;\n        }\n\n        const allInvalid = Array.isArray(report.invalid) ? report.invalid : [];\n        if (!allInvalid.length) {\n            vscode.window.showInformationMessage(\n                'AI Localizer: No invalid/non-translatable keys found in invalid keys report.',\n            );\n            return;\n        }\n\n        let root: any = {};\n        try {\n            const text = doc.getText();\n            const parsed = JSON.parse(text);\n            if (parsed && typeof parsed === 'object') root = parsed;\n        } catch {}\n        if (!root || typeof root !== 'object' || Array.isArray(root)) root = {};\n\n        const invalid = allInvalid.filter((item: any) => {\n            if (!item || typeof item.keyPath !== 'string') return false;\n            return hasKeyPathInObject(root, item.keyPath);\n        });\n\n        if (!invalid.length) {\n            vscode.window.showInformationMessage(\n                'AI Localizer: No invalid/non-translatable keys from report were found in this file.',\n            );\n            return;\n        }\n\n        const choice = await vscode.window.showQuickPick(\n            [\n                {\n                    label: 'Restore code references and remove from this file',\n                    description: `Restore inline strings in code and remove ${invalid.length} invalid key(s) from this locale file only.`,\n                },\n                {\n                    label: 'Cancel',\n                    description: 'Do not change code or locale files.',\n                },\n            ],\n            {\n                placeHolder: `AI Localizer: Restore ${invalid.length} invalid key(s) found in this file to inline strings?`,\n            },\n        );\n        if (!choice || choice.label === 'Cancel') {\n            return;\n        }\n\n        // Acquire lock for the modification operations\n        const result = await operationLock.withGlobalLock(\n            'cleanup-invalid',\n            'Restore Invalid Keys',\n            async () => {\n                let codeRestoreCount = 0;\n                for (const item of invalid) {\n                    if (!item || typeof item.keyPath !== 'string') continue;\n                    const usages = Array.isArray(item.usages) ? item.usages : [];\n                    const baseValue = typeof item.baseValue === 'string' ? item.baseValue : '';\n\n                    for (const usage of usages) {\n                        if (!usage || typeof usage.file !== 'string' || typeof usage.line !== 'number') continue;\n                        const codeFileUri = vscode.Uri.joinPath(folder!.uri, usage.file);\n                        try {\n                            const restored = await this.restoreInlineStringInFile(\n                                codeFileUri,\n                                item.keyPath,\n                                baseValue,\n                                usage.line - 1,\n                            );\n                            if (restored) {\n                                codeRestoreCount++;\n                            }\n                        } catch (err) {\n                            console.error(`AI Localizer: Failed to restore code reference for ${item.keyPath} in ${usage.file}:`, err);\n                        }\n                    }\n                }\n\n                // Re-read the file to get fresh content\n                let freshRoot: any = {};\n                try {\n                    const freshDoc = await vscode.workspace.openTextDocument(targetUri);\n                    const text = freshDoc.getText();\n                    const parsed = JSON.parse(text);\n                    if (parsed && typeof parsed === 'object') freshRoot = parsed;\n                } catch {}\n                if (!freshRoot || typeof freshRoot !== 'object' || Array.isArray(freshRoot)) {\n                    freshRoot = {};\n                }\n\n                // Verify that keys are safe to delete by checking for current usages\n                const deletedKeys = new Set<string>();\n                const keysStillInUse: string[] = [];\n                \n                for (const item of invalid) {\n                    if (!item || typeof item.keyPath !== 'string') continue;\n                    \n                    // Check if the key still has any references in the codebase\n                    await this.i18nIndex.ensureInitialized();\n                    const record = this.i18nIndex.getRecord(item.keyPath);\n                    \n                    // If the key has a record and it's used in code, don't delete it\n                    if (record && record.locations && record.locations.length > 0) {\n                        // The key is still referenced in locale files, check if it's actually used in code\n                        // We need to scan the codebase to check for actual usages\n                        const hasCurrentUsages = await this.checkKeyUsageInCode(folder!, item.keyPath);\n                        \n                        if (hasCurrentUsages) {\n                            keysStillInUse.push(item.keyPath);\n                            continue; // Skip deletion for this key\n                        }\n                    }\n                    \n                    if (deleteKeyPathInObject(freshRoot, item.keyPath)) {\n                        deletedKeys.add(item.keyPath);\n                    }\n                }\n\n                if (deletedKeys.size > 0) {\n                    await operationLock.withFileLock(targetUri, 'cleanup-invalid', async () => {\n                        await writeJsonFile(targetUri, freshRoot);\n                    });\n\n                    await this.i18nIndex.updateFile(targetUri);\n                    await vscode.commands.executeCommand(\n                        'ai-localizer.i18n.refreshFileDiagnostics',\n                        targetUri,\n                        Array.from(deletedKeys),\n                    );\n                }\n\n                return { codeRestoreCount, deletedKeys, keysStillInUse };\n            }\n        );\n\n        if (!result) {\n            return;\n        }\n\n        const { codeRestoreCount, deletedKeys, keysStillInUse } = result;\n        \n        let message = codeRestoreCount > 0\n            ? `AI Localizer: Restored ${codeRestoreCount} code reference(s) and removed ${deletedKeys.size} invalid key(s) from this file.`\n            : `AI Localizer: Removed ${deletedKeys.size} invalid/non-translatable key(s) from this file.`;\n        \n        if (keysStillInUse && keysStillInUse.length > 0) {\n            message += ` Note: ${keysStillInUse.length} key(s) skipped because they are still in use.`;\n        }\n        \n        vscode.window.showInformationMessage(message);\n    }\n\n    /**\n     * Check if a key is currently used in source code\n     */\n    private async checkKeyUsageInCode(\n        folder: vscode.WorkspaceFolder,\n        keyPath: string,\n    ): Promise<boolean> {\n        const cfg = vscode.workspace.getConfiguration('ai-localizer');\n        const maxSourceFilesToScan = cfg.get<number>('i18n.maxSourceFilesToScan') ?? 5000;\n        const sourceGlobs = cfg.get<string[]>('i18n.sourceGlobs') || [\n            '**/*.{ts,tsx,js,jsx,vue}',\n            '**/*.php',\n            '**/*.blade.php',\n        ];\n        const excludeGlobs = cfg.get<string[]>('i18n.sourceExcludeGlobs') || [\n            '**/node_modules/**',\n            '**/.git/**',\n            '**/dist/**',\n            '**/build/**',\n        ];\n\n        const escapedKey = keyPath.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n        const searchPatterns: RegExp[] = [\n            // JS/TS/Vue: t('key'), t (\"key\"), $t(`key`)\n            new RegExp(`\\\\b\\\\$?t\\\\s*\\\\(\\\\s*(['\"\\`])${escapedKey}\\\\1\\\\s*(?:,|\\\\))`),\n            // Laravel: __('key'), trans('key'), @lang('key')\n            new RegExp(`\\\\b__\\\\s*\\\\(\\\\s*(['\"])${escapedKey}\\\\1\\\\s*(?:,|\\\\))`),\n            new RegExp(`\\\\btrans\\\\s*\\\\(\\\\s*(['\"])${escapedKey}\\\\1\\\\s*(?:,|\\\\))`),\n            new RegExp(`@lang\\\\s*\\\\(\\\\s*(['\"])${escapedKey}\\\\1\\\\s*(?:,|\\\\))`),\n            new RegExp(`\\\\bLang::get\\\\s*\\\\(\\\\s*(['\"])${escapedKey}\\\\1\\\\s*(?:,|\\\\))`),\n        ];\n\n        const exclude = excludeGlobs.length > 0 ? `{${excludeGlobs.join(',')}}` : undefined;\n\n        const seen = new Set<string>();\n        const uris: vscode.Uri[] = [];\n        const includes = sourceGlobs.length > 0 ? sourceGlobs : [];\n\n        for (const include of includes) {\n            try {\n                const pattern = new vscode.RelativePattern(folder, include);\n                const found = await vscode.workspace.findFiles(pattern, exclude, maxSourceFilesToScan);\n                for (const uri of found) {\n                    const key = uri.toString();\n                    if (!seen.has(key)) {\n                        seen.add(key);\n                        uris.push(uri);\n                    }\n                }\n            } catch {\n                // Skip invalid glob patterns\n            }\n        }\n\n        for (const uri of uris) {\n            try {\n                // Safety: only scan files that belong to this workspace folder.\n                // vscode.workspace.findFiles can still return matches from other folders\n                // in a multi-root workspace depending on patterns.\n                if (vscode.workspace.getWorkspaceFolder(uri)?.uri.toString() !== folder.uri.toString()) {\n                    continue;\n                }\n                const data = await vscode.workspace.fs.readFile(uri);\n                const content = sharedDecoder.decode(data);\n \n                for (const searchPattern of searchPatterns) {\n                    if (searchPattern.test(content)) return true;\n                }\n            } catch {\n                // Skip files that can't be read\n            }\n        }\n\n        return false; // Key not found in any source files\n    }\n\n    /**\n     * Restore a single t('key') call to an inline string in a specific file\n     */\n    private async restoreInlineStringInFile(\n        fileUri: vscode.Uri,\n        keyPath: string,\n        baseValue: string,\n        lineNumber: number,\n    ): Promise<boolean> {\n        try {\n            const doc = await vscode.workspace.openTextDocument(fileUri);\n            const lineText = doc.lineAt(lineNumber).text;\n\n            const escapedKey = keyPath.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n            const patterns = [\n                new RegExp(`t\\\\(\\\\s*['\"]${escapedKey}['\"]\\\\s*\\\\)`, 'g'),\n                new RegExp(`t\\\\(\\\\s*['\"]${escapedKey}['\"]\\\\s*,\\\\s*\\\\{[^}]*\\\\}\\\\s*\\\\)`, 'g'),\n            ];\n\n            let newLineText = lineText;\n            let replaced = false;\n\n            const placeholderRegex = /\\{([A-Za-z0-9_]+(?:\\.[A-Za-z0-9_]+)?)\\}/g;\n            const hasPlaceholders = placeholderRegex.test(baseValue);\n\n            let replacement: string;\n            if (hasPlaceholders) {\n                const escaped = baseValue\n                    .replace(/`/g, '\\\\`')\n                    .replace(/\\$/g, '\\\\$');\n                replacement = `\\`${escaped}\\``;\n            } else {\n                const escaped = baseValue\n                    .replace(/\\\\/g, '\\\\\\\\')\n                    .replace(/'/g, \"\\\\'\")\n                    .replace(/\\r?\\n/g, '\\\\n');\n                replacement = `'${escaped}'`;\n            }\n\n            for (const pattern of patterns) {\n                if (pattern.test(newLineText)) {\n                    newLineText = newLineText.replace(pattern, replacement);\n                    replaced = true;\n                    break;\n                }\n            }\n\n            if (!replaced) return false;\n\n            const simplifyRedundantStringFallbacks = (input: string): string => {\n                let out = input;\n                const withParens = /\\(\\s*(['\"`])((?:\\\\.|(?!\\1)[^\\\\\\r\\n])+?)\\1\\s*\\)\\s*(\\|\\||\\?\\?)\\s*\\(\\s*\\1\\2\\1\\s*\\)/g;\n                const withoutParens = /(['\"`])((?:\\\\.|(?!\\1)[^\\\\\\r\\n])+?)\\1\\s*(\\|\\||\\?\\?)\\s*\\1\\2\\1/g;\n                for (let i = 0; i < 10; i += 1) {\n                    const next = out.replace(withParens, (_m, q, v) => `${q}${v}${q}`)\n                        .replace(withoutParens, (_m, q, v) => `${q}${v}${q}`);\n                    if (next === out) break;\n                    out = next;\n                }\n                return out;\n            };\n\n            newLineText = simplifyRedundantStringFallbacks(newLineText);\n\n            const edit = new vscode.WorkspaceEdit();\n            const lineRange = doc.lineAt(lineNumber).range;\n            edit.replace(fileUri, lineRange, newLineText);\n            const applied = await vscode.workspace.applyEdit(edit);\n            if (applied) {\n                await doc.save();\n            }\n            return applied;\n        } catch (err) {\n            console.error(`AI Localizer: Failed to restore inline string in ${fileUri.fsPath}:`, err);\n            return false;\n        }\n    }\n\n    /**\n     * Remove an invalid key from a locale file\n     */\n    async removeInvalidKeyInFile(documentUri: vscode.Uri, keyPath: string): Promise<void> {\n        if (!documentUri) {\n            vscode.window.showInformationMessage(\n                'AI Localizer: No document provided to remove invalid key.',\n            );\n            return;\n        }\n\n        const doc = await vscode.workspace.openTextDocument(documentUri);\n        if (doc.languageId !== 'json' && doc.languageId !== 'jsonc') {\n            vscode.window.showInformationMessage(\n                'AI Localizer: Remove invalid key only applies to locale JSON files.',\n            );\n            return;\n        }\n\n        let folder = vscode.workspace.getWorkspaceFolder(documentUri) ?? undefined;\n        if (!folder) {\n            folder = await pickWorkspaceFolder();\n        }\n        if (!folder) {\n            vscode.window.showInformationMessage('AI Localizer: No workspace folder available.');\n            return;\n        }\n\n        const scriptsDir = vscode.Uri.joinPath(folder.uri, 'scripts');\n        const reportUri = vscode.Uri.joinPath(scriptsDir, '.i18n-invalid-report.json');\n\n        let rawReport: string;\n        try {\n            const data = await vscode.workspace.fs.readFile(reportUri);\n            rawReport = sharedDecoder.decode(data);\n        } catch {\n            const choice = await vscode.window.showQuickPick(\n                [\n                    {\n                        label: 'Generate report',\n                        description:\n                            'Run i18n:restore-invalid script now to analyze and generate the invalid keys report.',\n                    },\n                    { label: 'Cancel', description: 'Skip removing this invalid key for now.' },\n                ],\n                {\n                    placeHolder:\n                        'AI Localizer: Invalid keys report not found. Generate it by running the restore-invalid script?',\n                },\n            );\n            if (!choice || choice.label !== 'Generate report') {\n                return;\n            }\n            await runI18nScript('i18n:restore-invalid');\n            vscode.window.showInformationMessage(\n                'AI Localizer: Running i18n:restore-invalid script in a terminal. Re-run this quick fix after it completes.',\n            );\n            return;\n        }\n\n        let report: any;\n        try {\n            report = JSON.parse(rawReport);\n        } catch {\n            vscode.window.showErrorMessage(\n                'AI Localizer: Invalid keys report is not valid JSON.',\n            );\n            return;\n        }\n\n        const invalid = Array.isArray(report.invalid) ? report.invalid : [];\n        const entry = invalid.find(\n            (item: any) => item && typeof item.keyPath === 'string' && item.keyPath === keyPath,\n        );\n        if (!entry) {\n            vscode.window.showInformationMessage(\n                `AI Localizer: Key ${keyPath} is not marked as invalid/non-translatable in invalid keys report.`,\n            );\n            return;\n        }\n\n        const choice = await vscode.window.showQuickPick(\n            [\n                {\n                    label: 'Restore code references and remove from locale files',\n                    description: `Restore inline string in code and remove ${keyPath} from all locale files.`,\n                },\n                {\n                    label: 'Cancel',\n                    description: 'Do not change code or locale files.',\n                },\n            ],\n            {\n                placeHolder: `AI Localizer: Restore invalid key ${keyPath} to inline string and remove from locale files?`,\n            },\n        );\n        if (!choice || choice.label === 'Cancel') {\n            return;\n        }\n\n        // Safety check for keys in use\n        const usages = Array.isArray(entry.usages) ? entry.usages : [];\n\n        const hasCurrentUsages = await this.checkKeyUsageInCode(folder, keyPath);\n        if (hasCurrentUsages) {\n            vscode.window.showWarningMessage(\n                `AI Localizer: Key \"${keyPath}\" is still referenced in source code. It cannot be safely removed. ` +\n                `Please restore inline strings in code or regenerate the invalid keys report before retrying.`,\n            );\n            return;\n        }\n\n        // Remove from this locale file\n        let root: any = await readJsonFile(documentUri) || {};\n        if (!root || typeof root !== 'object' || Array.isArray(root)) root = {};\n\n        const inUse = await this.checkKeyUsageInCode(folder, keyPath);\n        if (inUse) {\n            vscode.window.showInformationMessage(\n                `AI Localizer: Key ${keyPath} is still referenced in source code. Skipping removal.`,\n            );\n            return;\n        }\n\n        if (deleteKeyPathInObject(root, keyPath)) {\n            await writeJsonFile(documentUri, root);\n\n            await this.i18nIndex.updateFile(documentUri);\n            await vscode.commands.executeCommand(\n                'ai-localizer.i18n.refreshFileDiagnostics',\n                documentUri,\n                [keyPath],\n            );\n        }\n\n        // Also remove from other locale files\n        await this.i18nIndex.ensureInitialized();\n        const record = this.i18nIndex.getRecord(keyPath);\n        if (record) {\n            const otherUris = record.locations\n                .map((l) => l.uri)\n                .filter((u) => u.toString() !== documentUri.toString());\n            if (otherUris.length) {\n                await this.deleteKeyFromLocaleFiles(keyPath, otherUris);\n            }\n        }\n\n        vscode.window.showInformationMessage(\n            `AI Localizer: Removed invalid/non-translatable key ${keyPath} from locale files.`,\n        );\n    }\n\n    /**\n     * Restore invalid key in code\n     */\n    async restoreInvalidKeyInCode(\n        documentUri: vscode.Uri,\n        position: { line: number; character: number },\n        key: string,\n    ): Promise<void> {\n        const doc = await vscode.workspace.openTextDocument(documentUri);\n\n        let folder = vscode.workspace.getWorkspaceFolder(documentUri) ?? undefined;\n        if (!folder) {\n            folder = await pickWorkspaceFolder();\n        }\n        if (!folder) {\n            vscode.window.showInformationMessage('AI Localizer: No workspace folder available.');\n            return;\n        }\n\n        const scriptsDir = vscode.Uri.joinPath(folder.uri, 'scripts');\n        const reportUri = vscode.Uri.joinPath(scriptsDir, '.i18n-invalid-report.json');\n\n        let rawReport: string;\n        try {\n            const data = await vscode.workspace.fs.readFile(reportUri);\n            rawReport = sharedDecoder.decode(data);\n        } catch {\n            const choice = await vscode.window.showQuickPick(\n                [\n                    {\n                        label: 'Generate report',\n                        description:\n                            'Run i18n:restore-invalid script now to analyze and generate the invalid keys report.',\n                    },\n                    { label: 'Cancel', description: 'Skip restoring this key for now.' },\n                ],\n                {\n                    placeHolder:\n                        'AI Localizer: Invalid keys report not found. Generate it by running the restore-invalid script?',\n                },\n            );\n            if (!choice || choice.label !== 'Generate report') {\n                return;\n            }\n            await runI18nScript('i18n:restore-invalid');\n            vscode.window.showInformationMessage(\n                'AI Localizer: Running i18n:restore-invalid script in a terminal. Re-run this quick fix after it completes.',\n            );\n            return;\n        }\n\n        let report: any;\n        try {\n            report = JSON.parse(rawReport);\n        } catch {\n            vscode.window.showErrorMessage(\n                'AI Localizer: Invalid keys report is not valid JSON.',\n            );\n            return;\n        }\n\n        const invalid = Array.isArray(report.invalid) ? report.invalid : [];\n        const entry = invalid.find(\n            (item: any) => item && typeof item.keyPath === 'string' && item.keyPath === key,\n        );\n        if (!entry || typeof entry.baseValue !== 'string') {\n            vscode.window.showInformationMessage(\n                `AI Localizer: No invalid/non-translatable entry found in invalid keys report for key ${key}.`,\n            );\n            return;\n        }\n\n        const baseValue = String(entry.baseValue || '');\n\n        await this.i18nIndex.ensureInitialized();\n        const record = this.i18nIndex.getRecord(key);\n        const localeUris = record ? record.locations.map((l) => l.uri) : [];\n\n        let shouldDeleteFromLocales = false;\n        if (localeUris.length) {\n            const choice = await vscode.window.showQuickPick(\n                [\n                    {\n                        label: 'Restore and delete from locale files',\n                        description: `Remove ${key} from ${localeUris.length} locale file(s) after restoring inline string.`,\n                    },\n                    {\n                        label: 'Cancel',\n                        description: 'Do not change code or locale files.',\n                    },\n                ],\n                {\n                    placeHolder: `AI Localizer: Restore invalid key ${key} and delete it from locale files?`,\n                },\n            );\n            if (!choice || choice.label === 'Cancel') {\n                return;\n            }\n            shouldDeleteFromLocales = true;\n        }\n\n        // Use regex-based replacement\n        const lineText = doc.lineAt(position.line).text;\n        const escapedKey = key.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n        const patterns = [\n            new RegExp(`t\\\\(\\\\s*['\"]${escapedKey}['\"]\\\\s*\\\\)`, 'g'),\n            new RegExp(`t\\\\(\\\\s*['\"]${escapedKey}['\"]\\\\s*,\\\\s*\\\\{[^}]*\\\\}\\\\s*\\\\)`, 'g'),\n        ];\n\n        let newLineText = lineText;\n        let replaced = false;\n\n        const placeholderRegex = /\\{([A-Za-z0-9_]+(?:\\.[A-Za-z0-9_]+)?)\\}/g;\n        const hasPlaceholders = placeholderRegex.test(baseValue);\n\n        let replacement: string;\n        if (hasPlaceholders) {\n            const escaped = baseValue\n                .replace(/`/g, '\\\\`')\n                .replace(/\\$/g, '\\\\$');\n            replacement = `\\`${escaped}\\``;\n        } else {\n            const escaped = baseValue\n                .replace(/\\\\/g, '\\\\\\\\')\n                .replace(/'/g, \"\\\\'\")\n                .replace(/\\r?\\n/g, '\\\\n');\n            replacement = `'${escaped}'`;\n        }\n\n        for (const pattern of patterns) {\n            if (pattern.test(newLineText)) {\n                newLineText = newLineText.replace(pattern, replacement);\n                replaced = true;\n                break;\n            }\n        }\n\n        if (!replaced) {\n            vscode.window.showInformationMessage(\n                `AI Localizer: No matching t('${key}') call found at this location to restore.`,\n            );\n            return;\n        }\n\n        const edit = new vscode.WorkspaceEdit();\n        const lineRange = doc.lineAt(position.line).range;\n        edit.replace(documentUri, lineRange, newLineText);\n        const applied = await vscode.workspace.applyEdit(edit);\n        if (!applied) {\n            vscode.window.showErrorMessage(\n                'AI Localizer: Failed to apply restore quick fix edit to source file.',\n            );\n            return;\n        }\n\n        await doc.save();\n\n        let deletedFromLocales = 0;\n        if (shouldDeleteFromLocales && localeUris.length) {\n            deletedFromLocales = await this.deleteKeyFromLocaleFiles(key, localeUris);\n        }\n\n        if (deletedFromLocales > 0) {\n            vscode.window.showInformationMessage(\n                `AI Localizer: Restored inline string for invalid/non-translatable key ${key} at this location and removed it from ${deletedFromLocales} locale file(s).`,\n            );\n        } else {\n            vscode.window.showInformationMessage(\n                `AI Localizer: Restored inline string for invalid/non-translatable key ${key} at this location.`,\n            );\n        }\n    }\n}\n\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\untranslated\\handlers\\gitRecoveryHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\untranslated\\handlers\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\untranslated\\handlers\\keyManagementHandler.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'clearLocaleDirCache' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":24},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":154,"column":27,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":154,"endColumn":41},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":462,"column":21,"nodeType":"BlockStatement","messageId":"unexpected","endLine":463,"endColumn":14,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[17136,17149],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":537,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":537,"endColumn":29,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[20378,20379],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":544,"column":47,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":544,"endColumn":55,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[20679,20680],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":578,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":578,"endColumn":29,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[22133,22134],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":585,"column":47,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":585,"endColumn":55,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[22434,22435],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":676,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":676,"endColumn":29,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[26194,26195],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":683,"column":47,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":683,"endColumn":55,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[26495,26496],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":707,"column":17,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":707,"endColumn":25,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[27420,27421],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":714,"column":43,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":714,"endColumn":51,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[27693,27694],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":771,"column":14,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":771,"endColumn":31,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[29914,29915],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":772,"column":13,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":772,"endColumn":30,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[29973,29974],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":835,"column":59,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":835,"endColumn":60,"suggestions":[{"messageId":"removeEscape","fix":{"range":[32324,32325],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[32324,32324],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\-.","line":835,"column":61,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":835,"endColumn":62,"suggestions":[{"messageId":"removeEscape","fix":{"range":[32326,32327],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[32326,32326],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":839,"column":62,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":839,"endColumn":63,"suggestions":[{"messageId":"removeEscape","fix":{"range":[32484,32485],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[32484,32484],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\-.","line":839,"column":64,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":839,"endColumn":65,"suggestions":[{"messageId":"removeEscape","fix":{"range":[32486,32487],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[32486,32486],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":843,"column":60,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":843,"endColumn":61,"suggestions":[{"messageId":"removeEscape","fix":{"range":[32642,32643],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[32642,32642],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\-.","line":843,"column":62,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":843,"endColumn":63,"suggestions":[{"messageId":"removeEscape","fix":{"range":[32644,32645],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[32644,32644],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":879,"column":67,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":879,"endColumn":68,"suggestions":[{"messageId":"removeEscape","fix":{"range":[34112,34113],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[34112,34112],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\-.","line":879,"column":69,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":879,"endColumn":70,"suggestions":[{"messageId":"removeEscape","fix":{"range":[34114,34115],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[34114,34114],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":973,"column":61,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":973,"endColumn":68},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":993,"column":29,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":993,"endColumn":54,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[39065,39066],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":1028,"column":75,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1028,"endColumn":82},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":1084,"column":82,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1084,"endColumn":89},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":1088,"column":33,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1088,"endColumn":40},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":1124,"column":41,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1124,"endColumn":48},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":1213,"column":74,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1213,"endColumn":81},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":1216,"column":69,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1216,"endColumn":76},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":1232,"column":60,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1232,"endColumn":67},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":1240,"column":61,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1240,"endColumn":68},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'timestamp' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1392,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":1392,"endColumn":28}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":23,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\nimport * as path from 'path';\nimport { I18nIndex, extractKeyAtPosition } from '../../../core/i18nIndex';\nimport {\n    clearLocaleDirCache,\n    setLaravelTranslationValue,\n    setTranslationValue,\n    setTranslationValuesBatch,\n    deriveRootFromFile,\n} from '../../../core/i18nFs';\nimport { getGranularSyncService } from '../../../services/granularSyncService';\nimport { TranslationService } from '../../../services/translationService';\nimport { pickWorkspaceFolder } from '../../../core/workspace';\nimport { findKeyInHistory, getFileContentAtCommit } from '../../../core/gitHistory';\nimport { CommitTracker } from '../../../core/commitTracker';\nimport {\n    sharedDecoder,\n    sharedEncoder,\n    readJsonFile,\n    writeJsonFile,\n    deleteKeyPathInObject,\n    getNestedValue,\n    setNestedValue,\n} from '../utils/jsonUtils';\nimport {\n    computeEditDistance,\n    buildLabelFromKeySegment,\n    escapeRegExp,\n    looksLikeUserText,\n} from '../utils/textAnalysis';\nimport { findCommentRanges, isPositionInComment } from '../utils/commentParser';\nimport { GitRecoveryHandler } from './gitRecoveryHandler';\nimport { getBatchRecoveryHandler } from './batchRecoveryHandler';\nimport { clearLocaleCaches } from '../utils/localeCache';\nimport { operationLock, OperationType } from '../utils/operationLock';\n\nexport class KeyManagementHandler {\n    private deletionGuardPending: Map<string, { key: string; value: string; timeout: NodeJS.Timeout }> = new Map();\n\n    constructor(\n        private i18nIndex: I18nIndex,\n        private gitRecoveryHandler: GitRecoveryHandler,\n        private translationService: TranslationService,\n        private context?: vscode.ExtensionContext,\n        private log?: vscode.OutputChannel,\n    ) {}\n\n    /**\n     * Cleanup all pending guard timeouts. Call on extension deactivation.\n     */\n    dispose(): void {\n        for (const [, pending] of this.deletionGuardPending) {\n            clearTimeout(pending.timeout);\n        }\n        this.deletionGuardPending.clear();\n    }\n\n    /**\n     * Check if operation can proceed, showing warning if blocked\n     */\n    private async canProceed(operationType: OperationType, description: string): Promise<boolean> {\n        if (!operationLock.isOperationRunning()) {\n            return true;\n        }\n        const current = operationLock.getCurrentOperation();\n        if (current?.type === operationType) {\n            return true;\n        }\n        const blockingMsg = operationLock.getBlockingOperationMessage();\n        vscode.window.showWarningMessage(\n            `AI Localizer: Cannot start \"${description}\" - ${blockingMsg}. Please wait for it to complete.`\n        );\n        return false;\n    }\n\n    private decodeSimpleJsStringLiteral(content: string): string {\n        return String(content || '')\n            .replace(/\\\\n/g, ' ')\n            .replace(/\\\\r/g, ' ')\n            .replace(/\\\\t/g, ' ')\n            .replace(/\\\\'/g, \"'\")\n            .replace(/\\\\\"/g, '\"')\n            .replace(/\\\\\\\\/g, '\\\\');\n    }\n\n    private buildCollapsedTranslationExpressionEdit(\n        doc: vscode.TextDocument,\n        keyRange: vscode.Range,\n        originalKey: string,\n        targetKey: string,\n    ): { range: vscode.Range; newText: string } | null {\n        const text = doc.getText();\n        const keyStartOffset = doc.offsetAt(keyRange.start);\n        const keyEndOffset = doc.offsetAt(keyRange.end);\n        if (keyStartOffset < 0 || keyEndOffset <= keyStartOffset) return null;\n\n        const safeKey = escapeRegExp(originalKey);\n\n        const windowSize = 20000;\n        const windowStart = Math.max(0, keyStartOffset - windowSize);\n        const prefixText = text.slice(windowStart, keyStartOffset);\n        const callStartCandidateRegex = /\\b(\\$?)t\\s*\\(/g;\n\n        const candidates: Array<{ startIdx: number; hasDollar: boolean }> = [];\n        for (let m = callStartCandidateRegex.exec(prefixText); m; m = callStartCandidateRegex.exec(prefixText)) {\n            const absIdx = windowStart + (m.index ?? 0);\n            candidates.push({ startIdx: absIdx, hasDollar: (m[1] as string) === '$' });\n        }\n        if (!candidates.length) return null;\n\n        const findCloseParenFrom = (openParenIdx: number): number | null => {\n            let depth = 0;\n            let inString: string | null = null;\n            let escape = false;\n\n            for (let i = openParenIdx; i < text.length; i += 1) {\n                const ch = text[i] as string;\n\n                if (inString) {\n                    if (escape) {\n                        escape = false;\n                        continue;\n                    }\n                    if (ch === '\\\\') {\n                        escape = true;\n                        continue;\n                    }\n                    if (ch === inString) {\n                        inString = null;\n                    }\n                    continue;\n                }\n\n                if (ch === \"'\" || ch === '\"' || ch === '`') {\n                    inString = ch;\n                    continue;\n                }\n\n                if (ch === '(') {\n                    depth += 1;\n                    continue;\n                }\n                if (ch === ')') {\n                    depth -= 1;\n                    if (depth === 0) return i;\n                    continue;\n                }\n            }\n            return null;\n        };\n\n        const findEnclosingCall = (): { startIdx: number; hasDollar: boolean; openParenIdx: number; closeParenIdx: number } | null => {\n            for (let i = candidates.length - 1; i >= 0; i -= 1) {\n                const c = candidates[i]!;\n                const openParenIdx = text.indexOf('(', c.startIdx);\n                if (openParenIdx === -1) continue;\n                const closeParenIdx = findCloseParenFrom(openParenIdx);\n                if (closeParenIdx == null) continue;\n                if (c.startIdx <= keyStartOffset && keyEndOffset <= closeParenIdx) {\n                    return { startIdx: c.startIdx, hasDollar: c.hasDollar, openParenIdx, closeParenIdx };\n                }\n            }\n            return null;\n        };\n\n        const call = findEnclosingCall();\n        if (!call) return null;\n\n        const findFirstArgEndIdx = (): number | null => {\n            const firstArgRegex = new RegExp(\n                \"\\\\b\\\\$?t\\\\s*\\\\(\\\\s*(['\\\"`])\" + safeKey + \"\\\\1\",\n                'g',\n            );\n            firstArgRegex.lastIndex = call.startIdx;\n            const m = firstArgRegex.exec(text);\n            if (!m || typeof m.index !== 'number') return null;\n            const matchText = m[0] as string;\n            return m.index + matchText.length;\n        };\n\n        const afterFirstArgIdx = findFirstArgEndIdx();\n        if (afterFirstArgIdx == null) return null;\n\n        const shouldCollapseCallArgs = (() => {\n            let i = afterFirstArgIdx;\n            while (i < text.length && /\\s/.test(text[i] as string)) i += 1;\n            if ((text[i] as string) !== ',') {\n                return true;\n            }\n\n            i += 1;\n            while (i < text.length && /\\s/.test(text[i] as string)) i += 1;\n            const quote = text[i] as string;\n            if (quote !== \"'\" && quote !== '\"' && quote !== '`') return false;\n\n            i += 1;\n            let escape = false;\n            let sawTemplateExpr = false;\n            for (; i < text.length; i += 1) {\n                const ch = text[i] as string;\n                if (escape) {\n                    escape = false;\n                    continue;\n                }\n                if (ch === '\\\\') {\n                    escape = true;\n                    continue;\n                }\n                if (quote === '`' && ch === '$' && (text[i + 1] as string) === '{') {\n                    sawTemplateExpr = true;\n                }\n                if (ch === quote) {\n                    i += 1;\n                    break;\n                }\n            }\n            if (quote === '`' && sawTemplateExpr) return false;\n\n            while (i < text.length && /\\s/.test(text[i] as string)) i += 1;\n            return i === call.closeParenIdx;\n        })();\n\n        if (!shouldCollapseCallArgs) return null;\n\n        let endIdx = call.closeParenIdx;\n\n        const rest = text.slice(call.closeParenIdx + 1);\n        const fallbackMatch = rest.match(/^\\s*(\\|\\||\\?\\?)\\s*(['\"`])((?:\\\\.|(?!\\2)[\\s\\S])*)\\2/);\n        if (fallbackMatch && typeof fallbackMatch[3] === 'string') {\n            const quote = fallbackMatch[2] as string;\n            const raw = fallbackMatch[3] as string;\n            if (!(quote === '`' && raw.includes('${'))) {\n                endIdx = call.closeParenIdx + fallbackMatch[0].length;\n            }\n        }\n\n        const startPos = doc.positionAt(call.startIdx);\n        const endPos = doc.positionAt(endIdx + 1);\n\n        const escapedTargetKey = String(targetKey).replace(/\\\\/g, '\\\\\\\\').replace(/'/g, \"\\\\'\");\n        const newText = `${call.hasDollar ? '$' : ''}t('${escapedTargetKey}')`;\n\n        return {\n            range: new vscode.Range(startPos, endPos),\n            newText,\n        };\n    }\n\n    private extractInlineDefaultForKeyFromLine(line: string, key: string): string | null {\n        const safeKey = escapeRegExp(key);\n\n        const quoteGroup = \"(['\\\"`])\";\n        const callWithDefaultFullRegex = new RegExp(\n            \"\\\\b\\\\$?t\\\\s*\\\\(\\\\s*(['\\\"])\" +\n                safeKey +\n                \"\\\\1\\\\s*,\\\\s*\" +\n                quoteGroup +\n                \"((?:\\\\\\\\.|(?!\\\\2)[\\\\s\\\\S])*)\\\\2\",\n        );\n        const m1 = line.match(callWithDefaultFullRegex);\n        if (m1 && typeof m1[3] === 'string') {\n            const quote = m1[2] as string;\n            const raw = m1[3];\n            if (quote === '`' && raw.includes('${')) {\n                return null;\n            }\n            const decoded = this.decodeSimpleJsStringLiteral(raw).replace(/\\s+/g, ' ').trim();\n            if (!decoded) return null;\n            return looksLikeUserText(decoded) ? decoded : null;\n        }\n\n        const callThenFallbackRegex = new RegExp(\n            \"\\\\b\\\\$?t\\\\s*\\\\(\\\\s*(['\\\"])\" +\n                safeKey +\n                \"\\\\1\\\\s*\\\\)\\\\s*(\\\\|\\\\||\\\\?\\\\?)\\\\s*\" +\n                quoteGroup +\n                \"((?:\\\\\\\\.|(?!\\\\3)[\\\\s\\\\S])*)\\\\3\",\n        );\n        const m2 = line.match(callThenFallbackRegex);\n        if (m2 && typeof m2[4] === 'string') {\n            const quote = m2[3] as string;\n            const raw = m2[4];\n            if (quote === '`' && raw.includes('${')) {\n                return null;\n            }\n            const decoded = this.decodeSimpleJsStringLiteral(raw).replace(/\\s+/g, ' ').trim();\n            if (!decoded) return null;\n            return looksLikeUserText(decoded) ? decoded : null;\n        }\n\n        return null;\n    }\n\n    private buildNormalizedMissingReferenceKey(\n        folder: vscode.WorkspaceFolder,\n        documentUri: vscode.Uri,\n        key: string,\n    ): string | null {\n        const rel = path\n            .relative(folder.uri.fsPath, documentUri.fsPath)\n            .replace(/\\\\/g, '/');\n        const parts = rel.split('/').filter(Boolean);\n\n        let componentName: string | null = null;\n        for (let i = 0; i < parts.length; i += 1) {\n            if (String(parts[i]).toLowerCase() === 'components' && i + 1 < parts.length) {\n                componentName = parts[i + 1];\n                break;\n            }\n        }\n\n        if (componentName) {\n            componentName = String(componentName).replace(/\\.(tsx|ts|jsx|js|vue|svelte)$/i, '');\n        }\n\n        const keyParts = String(key).split('.').filter(Boolean);\n        if (keyParts.length === 0) return null;\n\n        const normalizedParts: string[] = [];\n\n        if (componentName) {\n            normalizedParts.push('components');\n            normalizedParts.push(String(componentName));\n        }\n\n        let remaining = [...keyParts];\n        if (componentName && remaining.length > 0) {\n            if (remaining[0] && remaining[0].toLowerCase() === String(componentName).toLowerCase()) {\n                remaining = remaining.slice(1);\n            }\n            if (remaining[0] && remaining[0].toLowerCase() === 'app') {\n                remaining = remaining.slice(1);\n            }\n        }\n\n        const cleaned = remaining.map((seg, idx) => {\n            let s = String(seg || '');\n            if (idx === remaining.length - 1) {\n                s = s.replace(/(_text|_label|_title|_message|_placeholder)$/i, '');\n            }\n            s = s\n                .replace(/[^A-Za-z0-9]+/g, '_')\n                .replace(/_+/g, '_')\n                .replace(/^_+|_+$/g, '')\n                .toLowerCase();\n            return s;\n        });\n\n        for (const seg of cleaned) {\n            if (seg) normalizedParts.push(seg);\n        }\n\n        if (normalizedParts.length < 2) {\n            return null;\n        }\n\n        return normalizedParts.join('.');\n    }\n\n    /**\n     * Fix missing key reference\n     */\n    async fixMissingKeyReference(\n        documentUri: vscode.Uri,\n        position: { line: number; character: number },\n        key: string,\n    ): Promise<void> {\n        const doc = await vscode.workspace.openTextDocument(documentUri);\n\n        const languageId = doc.languageId;\n\n        let folder = vscode.workspace.getWorkspaceFolder(documentUri) ?? undefined;\n        if (!folder) {\n            folder = await pickWorkspaceFolder();\n        }\n        if (!folder) {\n            vscode.window.showInformationMessage('AI Localizer: No workspace folder available.');\n            return;\n        }\n\n        const cfg = vscode.workspace.getConfiguration('ai-localizer');\n        const defaultLocale = cfg.get<string>('i18n.defaultLocale') || 'en';\n        const rootName = deriveRootFromFile(folder, documentUri);\n        const isLaravelSource = languageId === 'php' || languageId === 'blade';\n        const keyParts = String(key).split('.').filter(Boolean);\n        const keyLeaf = keyParts[keyParts.length - 1] || '';\n        const keyPrefix = keyParts.slice(0, -1).join('.');\n\n        const syncService = getGranularSyncService(this.context);\n        await syncService.syncKeys(folder, [key]);\n\n        await this.i18nIndex.ensureInitialized();\n        const allKeys = this.i18nIndex.getAllKeys();\n\n        const vsPosition = new vscode.Position(position.line, position.character);\n        const keyInfo = extractKeyAtPosition(doc, vsPosition);\n        const canReplaceReference = !!keyInfo && keyInfo.key === key;\n        const inlineDefault =\n            !isLaravelSource && canReplaceReference\n                ? this.extractInlineDefaultForKeyFromLine(doc.lineAt(keyInfo.range.start.line).text, key)\n                : null;\n        const normalizedKey =\n            !isLaravelSource && canReplaceReference\n                ? this.buildNormalizedMissingReferenceKey(folder, documentUri, key)\n                : null;\n        const targetKey = normalizedKey || key;\n\n        if (canReplaceReference && targetKey !== key) {\n            const record = this.i18nIndex.getRecord(targetKey);\n            if (record) {\n                const edit = new vscode.WorkspaceEdit();\n                const collapsed = this.buildCollapsedTranslationExpressionEdit(\n                    doc,\n                    keyInfo.range,\n                    key,\n                    targetKey,\n                );\n                if (collapsed) {\n                    edit.replace(documentUri, collapsed.range, collapsed.newText);\n                } else {\n                    edit.replace(documentUri, keyInfo.range, targetKey);\n                }\n                const applied = await vscode.workspace.applyEdit(edit);\n                if (applied) {\n                    await doc.save();\n                    vscode.window.showInformationMessage(\n                        `AI Localizer: Auto-fixed \"${key}\" → \"${targetKey}\"`,\n                    );\n                    return;\n                }\n            }\n        }\n\n        if (inlineDefault && inlineDefault.trim()) {\n            const value = inlineDefault.trim();\n\n            if (isLaravelSource) {\n                await setLaravelTranslationValue(folder, defaultLocale, targetKey, value);\n            } else {\n                await setTranslationValue(folder, defaultLocale, targetKey, value, { rootName });\n            }\n\n            if (canReplaceReference) {\n                const edit = new vscode.WorkspaceEdit();\n                const collapsed = this.buildCollapsedTranslationExpressionEdit(\n                    doc,\n                    keyInfo.range,\n                    key,\n                    targetKey,\n                );\n                if (collapsed) {\n                    edit.replace(documentUri, collapsed.range, collapsed.newText);\n                } else if (targetKey !== key) {\n                    edit.replace(documentUri, keyInfo.range, targetKey);\n                }\n                await vscode.workspace.applyEdit(edit);\n                await doc.save();\n            }\n\n            try {\n                await syncService.syncKeys(folder, [targetKey]);\n            } catch {\n            }\n\n            vscode.window.showInformationMessage(\n                `AI Localizer: Created \"${targetKey}\" = \"${value.slice(0, 50)}${value.length > 50 ? '...' : ''}\" in locale ${defaultLocale}.`,\n            );\n            return;\n        }\n\n        // STEP 1: Try to find the best matching existing key (typo fix)\n        let bestKey: string | null = null;\n        let bestScore = Number.POSITIVE_INFINITY;\n\n        for (const candidate of allKeys) {\n            if (!candidate) continue;\n            const parts = candidate.split('.').filter(Boolean);\n            if (!parts.length) continue;\n            const prefix = parts.slice(0, -1).join('.');\n            if (prefix !== keyPrefix) continue;\n            const leaf = parts[parts.length - 1] || '';\n            const score = computeEditDistance(keyLeaf, leaf);\n            if (score < bestScore) {\n                bestScore = score;\n                bestKey = candidate;\n            }\n        }\n\n        // Check if the best key is a good enough match\n        if (bestKey) {\n            const bestParts = bestKey.split('.').filter(Boolean);\n            const bestLeaf = bestParts[bestParts.length - 1] || '';\n            const maxLen = Math.max(bestLeaf.length, keyLeaf.length);\n            if (maxLen > 0 && bestScore <= Math.max(2, Math.floor(maxLen / 4))) {\n                // Auto-fix: Replace with similar key\n                const vsPosition = new vscode.Position(position.line, position.character);\n                const keyInfo = extractKeyAtPosition(doc, vsPosition);\n                if (keyInfo && keyInfo.key === key) {\n                    const edit = new vscode.WorkspaceEdit();\n                    edit.replace(documentUri, keyInfo.range, bestKey);\n                    const applied = await vscode.workspace.applyEdit(edit);\n                    if (applied) {\n                        await doc.save();\n                        vscode.window.showInformationMessage(\n                            `AI Localizer: Auto-fixed \"${key}\" → \"${bestKey}\"`,\n                        );\n                        return;\n                    }\n                }\n            }\n        }\n\n        // STEP 2: Try to recover value from git history\n        this.log?.appendLine(`[MissingRefFix] Attempting git recovery for \"${key}\" from source file: ${documentUri.fsPath}`);\n        \n        // Try source file history first (most likely to have the original text)\n        const sourceFileRecovery = await this.gitRecoveryHandler.recoverFromSourceFileHistory(\n            folder,\n            documentUri.fsPath,\n            key,\n            defaultLocale,\n            365,\n            '[MissingRefFix]'\n        );\n        \n        if (sourceFileRecovery) {\n            if (isLaravelSource) {\n                await setLaravelTranslationValue(folder, defaultLocale, targetKey, sourceFileRecovery.value);\n            } else {\n                await setTranslationValue(folder, defaultLocale, targetKey, sourceFileRecovery.value, { rootName });\n            }\n\n            if (canReplaceReference) {\n                const edit = new vscode.WorkspaceEdit();\n                const collapsed = this.buildCollapsedTranslationExpressionEdit(\n                    doc,\n                    keyInfo!.range,\n                    key,\n                    targetKey,\n                );\n                if (collapsed) {\n                    edit.replace(documentUri, collapsed.range, collapsed.newText);\n                } else if (targetKey !== key) {\n                    edit.replace(documentUri, keyInfo!.range, targetKey);\n                }\n                const applied = await vscode.workspace.applyEdit(edit);\n                if (applied) {\n                    await doc.save();\n                }\n            }\n\n            vscode.window.showInformationMessage(\n                `AI Localizer: Restored \"${targetKey}\" = \"${sourceFileRecovery.value.slice(0, 50)}${sourceFileRecovery.value.length > 50 ? '...' : ''}\" from ${sourceFileRecovery.source}.`,\n            );\n            return;\n        }\n        \n        // Fallback to locale file history\n        const localeUris = await this.gitRecoveryHandler.getLocaleFileUris(folder, defaultLocale, this.i18nIndex);\n        const recovery = await this.gitRecoveryHandler.recoverKeyFromGit(folder, localeUris, key, defaultLocale, {\n            daysBack: 365,\n            maxCommits: 100,\n            perDayCommitLimit: 5,\n            logPrefix: '[MissingRefFix]',\n        });\n\n        if (recovery) {\n            if (isLaravelSource) {\n                await setLaravelTranslationValue(folder, defaultLocale, targetKey, recovery.value);\n            } else {\n                await setTranslationValue(folder, defaultLocale, targetKey, recovery.value, { rootName });\n            }\n\n            if (canReplaceReference) {\n                const edit = new vscode.WorkspaceEdit();\n                const collapsed = this.buildCollapsedTranslationExpressionEdit(\n                    doc,\n                    keyInfo!.range,\n                    key,\n                    targetKey,\n                );\n                if (collapsed) {\n                    edit.replace(documentUri, collapsed.range, collapsed.newText);\n                } else if (targetKey !== key) {\n                    edit.replace(documentUri, keyInfo!.range, targetKey);\n                }\n                const applied = await vscode.workspace.applyEdit(edit);\n                if (applied) {\n                    await doc.save();\n                }\n            }\n            vscode.window.showInformationMessage(\n                `AI Localizer: Restored \"${targetKey}\" from ${recovery.source}.`,\n            );\n            return;\n        }\n        this.log?.appendLine(`[MissingRefFix] Git recovery failed for \"${key}\".`);\n\n        // STEP 3: Show options (only as fallback)\n        const items: vscode.QuickPickItem[] = [];\n\n        if (bestKey && bestKey !== key) {\n            const bestParts = bestKey.split('.').filter(Boolean);\n            const bestLeaf = bestParts[bestParts.length - 1] || '';\n            const maxLen = Math.max(bestLeaf.length, keyLeaf.length);\n            if (maxLen > 0 && bestScore <= Math.max(3, Math.floor(maxLen / 2))) {\n                items.push({\n                    label: `$(replace) Replace with: ${bestKey}`,\n                    description: `Similar key found (edit distance: ${bestScore})`,\n                    detail: 'Use closest matching translation key in the same namespace',\n                });\n            }\n        }\n\n        const suggestedLabel = buildLabelFromKeySegment(keyLeaf) || key;\n\n        items.push({\n            label: `$(add) Create new key with value: \"${suggestedLabel}\"`,\n            description: 'Create a new locale entry using this key',\n            detail: `Key: ${targetKey}`,\n        });\n\n        items.push({\n            label: '$(edit) Create new key with custom value...',\n            description: 'Enter a custom translation value',\n        });\n\n        const choice = await vscode.window.showQuickPick(items, {\n            placeHolder: `AI Localizer: Fix missing \"${key}\" (no git history found)`,\n        });\n        if (!choice) return;\n\n        if (choice.label.startsWith('$(replace)') && bestKey) {\n            const vsPosition = new vscode.Position(position.line, position.character);\n            const keyInfo = extractKeyAtPosition(doc, vsPosition);\n            if (!keyInfo || keyInfo.key !== key) {\n                vscode.window.showInformationMessage(\n                    `AI Localizer: Could not locate \"${key}\" at this position.`,\n                );\n                return;\n            }\n\n            const edit = new vscode.WorkspaceEdit();\n            edit.replace(documentUri, keyInfo.range, bestKey);\n            const applied = await vscode.workspace.applyEdit(edit);\n            if (!applied) {\n                vscode.window.showErrorMessage(\n                    'AI Localizer: Failed to apply reference fix to source file.',\n                );\n                return;\n            }\n            await doc.save();\n            vscode.window.showInformationMessage(\n                `AI Localizer: Replaced \"${key}\" with \"${bestKey}\".`,\n            );\n            return;\n        }\n\n        if (choice.label.includes('custom value')) {\n            const customValue = await vscode.window.showInputBox({\n                prompt: `Enter translation value for \"${targetKey}\"`,\n                value: suggestedLabel,\n                placeHolder: 'Translation value...',\n            });\n            if (!customValue) return;\n            if (isLaravelSource) {\n                await setLaravelTranslationValue(folder, defaultLocale, targetKey, customValue);\n            } else {\n                await setTranslationValue(folder, defaultLocale, targetKey, customValue, { rootName });\n            }\n\n            if (canReplaceReference) {\n                const edit = new vscode.WorkspaceEdit();\n                const collapsed = this.buildCollapsedTranslationExpressionEdit(\n                    doc,\n                    keyInfo!.range,\n                    key,\n                    targetKey,\n                );\n                if (collapsed) {\n                    edit.replace(documentUri, collapsed.range, collapsed.newText);\n                } else if (targetKey !== key) {\n                    edit.replace(documentUri, keyInfo!.range, targetKey);\n                }\n                const applied = await vscode.workspace.applyEdit(edit);\n                if (applied) {\n                    await doc.save();\n                }\n            }\n            vscode.window.showInformationMessage(\n                `AI Localizer: Created \"${targetKey}\" = \"${customValue}\" in locale ${defaultLocale}.`,\n            );\n            return;\n        }\n\n        // Default: create with suggested label\n        if (isLaravelSource) {\n            await setLaravelTranslationValue(folder, defaultLocale, targetKey, suggestedLabel);\n        } else {\n            await setTranslationValue(folder, defaultLocale, targetKey, suggestedLabel, { rootName });\n        }\n\n        if (canReplaceReference) {\n            const edit = new vscode.WorkspaceEdit();\n            const collapsed = this.buildCollapsedTranslationExpressionEdit(\n                doc,\n                keyInfo!.range,\n                key,\n                targetKey,\n            );\n            if (collapsed) {\n                edit.replace(documentUri, collapsed.range, collapsed.newText);\n            } else if (targetKey !== key) {\n                edit.replace(documentUri, keyInfo!.range, targetKey);\n            }\n            const applied = await vscode.workspace.applyEdit(edit);\n            if (applied) {\n                await doc.save();\n            }\n        }\n        vscode.window.showInformationMessage(\n            `AI Localizer: Created \"${targetKey}\" = \"${suggestedLabel}\" in locale ${defaultLocale}.`,\n        );\n    }\n\n    /**\n     * Add a key's default value to the auto-ignore list\n     */\n    async addKeyToIgnoreList(folderUri: vscode.Uri, key: string): Promise<void> {\n        await this.i18nIndex.ensureInitialized();\n        const record = this.i18nIndex.getRecord(key);\n        if (!record) {\n            vscode.window.showInformationMessage(\n                `AI Localizer: No translation record found for key ${key}.`,\n            );\n            return;\n        }\n\n        const defaultValue = record.locales.get(record.defaultLocale);\n        if (typeof defaultValue !== 'string' || !defaultValue.trim()) {\n            vscode.window.showInformationMessage(\n                `AI Localizer: No default value found for key ${key}.`,\n            );\n            return;\n        }\n\n        const scriptsDir = vscode.Uri.joinPath(folderUri, 'scripts');\n        const ignoreUri = vscode.Uri.joinPath(scriptsDir, '.i18n-auto-ignore.json');\n        let ignoreData: { exact?: string[]; exactInsensitive?: string[]; contains?: string[] } = {\n            exact: [],\n            exactInsensitive: [],\n            contains: [],\n        };\n\n        try {\n            const data = await vscode.workspace.fs.readFile(ignoreUri);\n            const raw = sharedDecoder.decode(data);\n            const parsed = JSON.parse(raw);\n            if (parsed && typeof parsed === 'object') {\n                ignoreData = {\n                    exact: Array.isArray(parsed.exact) ? parsed.exact : [],\n                    exactInsensitive: Array.isArray(parsed.exactInsensitive) ? parsed.exactInsensitive : [],\n                    contains: Array.isArray(parsed.contains) ? parsed.contains : [],\n                };\n            }\n        } catch {\n            // File doesn't exist, use defaults\n        }\n\n        const normalizedValue = defaultValue.replace(/\\s+/g, ' ').trim();\n        if (!ignoreData.exact!.includes(normalizedValue)) {\n            ignoreData.exact!.push(normalizedValue);\n        }\n\n        const payload = JSON.stringify(ignoreData, null, 2) + '\\n';\n        await vscode.workspace.fs.writeFile(ignoreUri, sharedEncoder.encode(payload));\n\n        await vscode.commands.executeCommand('ai-localizer.i18n.rescan');\n\n        vscode.window.showInformationMessage(\n            `AI Localizer: Added \"${normalizedValue}\" to ignore list. Diagnostics will be refreshed.`,\n        );\n    }\n\n    /**\n     * Bulk fix missing translation key references in a ts/tsx file\n     * Optimized version using batch recovery with parallel processing\n     */\n    async bulkFixMissingKeyReferences(documentUri: vscode.Uri): Promise<void> {\n        const doc = await vscode.workspace.openTextDocument(documentUri);\n        const languageId = doc.languageId;\n\n        const supportedLanguages = [\n            'typescript', 'typescriptreact',\n            'javascript', 'javascriptreact',\n            'vue',\n            'php', 'blade',\n        ];\n\n        if (!supportedLanguages.includes(languageId)) {\n            vscode.window.showWarningMessage(\n                'AI Localizer: Bulk fix is available for JS/TS/JSX/TSX/Vue/PHP/Blade files.',\n            );\n            return;\n        }\n\n        const isLaravelSource = languageId === 'php' || languageId === 'blade';\n\n        // Check if another operation is blocking\n        if (!(await this.canProceed('key-management', 'Bulk Fix Missing References'))) {\n            return;\n        }\n\n        let folder = vscode.workspace.getWorkspaceFolder(documentUri) ?? undefined;\n        if (!folder) {\n            folder = await pickWorkspaceFolder();\n        }\n        if (!folder) {\n            vscode.window.showInformationMessage('AI Localizer: No workspace folder available.');\n            return;\n        }\n\n        this.log?.appendLine(\n            `[BulkFixMissingRefs] Starting for ${documentUri.fsPath} (lang=${languageId})`,\n        );\n\n        // Extract all translation keys from the file\n        const text = doc.getText();\n        const commentRanges = findCommentRanges(text);\n        const keyMatches: Array<{ key: string; range: vscode.Range; hasVariables: boolean }> = [];\n\n        if (isLaravelSource) {\n            const patterns: Array<{ regex: RegExp; keyGroupIndex: number }> = [\n                {\n                    regex: /\\b__\\s*\\(\\s*(['\"])([A-Za-z0-9_\\.\\-]+)\\1\\s*(?:,|\\))/g,\n                    keyGroupIndex: 2,\n                },\n                {\n                    regex: /\\btrans\\s*\\(\\s*(['\"])([A-Za-z0-9_\\.\\-]+)\\1\\s*(?:,|\\))/g,\n                    keyGroupIndex: 2,\n                },\n                {\n                    regex: /@lang\\s*\\(\\s*(['\"])([A-Za-z0-9_\\.\\-]+)\\1\\s*(?:,|\\))/g,\n                    keyGroupIndex: 2,\n                },\n            ];\n\n            for (const { regex, keyGroupIndex } of patterns) {\n                regex.lastIndex = 0;\n                let match;\n                // eslint-disable-next-line no-cond-assign\n                while ((match = regex.exec(text)) !== null) {\n                    const matchIndex = match.index;\n\n                    if (isPositionInComment(matchIndex, commentRanges)) {\n                        continue;\n                    }\n\n                    const key = match[keyGroupIndex] as string;\n                    if (!key) {\n                        continue;\n                    }\n\n                    const quoteChar = match[1] as string;\n                    const fullMatch = match[0] as string;\n                    const quotePosInMatch = fullMatch.indexOf(quoteChar);\n                    if (quotePosInMatch === -1) {\n                        continue;\n                    }\n                    const keyStartPosition = matchIndex + quotePosInMatch + 1;\n\n                    const startPos = doc.positionAt(keyStartPosition);\n                    const endPos = doc.positionAt(keyStartPosition + key.length);\n                    const range = new vscode.Range(startPos, endPos);\n                    keyMatches.push({ key, range, hasVariables: false });\n                }\n            }\n        } else {\n            const tCallRegex = /\\b(\\$?)t\\s*\\(\\s*(['\"])([A-Za-z0-9_\\.\\-]+)\\2\\s*([,)])/g;\n            let match;\n            // eslint-disable-next-line no-cond-assign\n            while ((match = tCallRegex.exec(text)) !== null) {\n                const dollarSignLength = match[1] ? 1 : 0;\n                const tCallStart = match.index + dollarSignLength;\n\n                if (isPositionInComment(tCallStart, commentRanges)) {\n                    continue;\n                }\n\n                const key = match[3];\n                const afterKey = match[4];\n                const hasVariables = afterKey === ',';\n\n                const quoteChar = match[2];\n                const searchStart = dollarSignLength + 2;\n                const quotePosInMatch = match[0].indexOf(quoteChar, searchStart);\n                const keyStartPosition = match.index + quotePosInMatch + 1;\n\n                const startPos = doc.positionAt(keyStartPosition);\n                const endPos = doc.positionAt(keyStartPosition + key.length);\n                const range = new vscode.Range(startPos, endPos);\n                keyMatches.push({ key, range, hasVariables });\n            }\n        }\n\n        if (keyMatches.length === 0) {\n            vscode.window.showInformationMessage(\n                'AI Localizer: No translation key references found in this file.',\n            );\n            return;\n        }\n\n        await this.i18nIndex.ensureInitialized();\n        const allKeys = this.i18nIndex.getAllKeys();\n        const validKeysSet = new Set<string>();\n\n        if (isLaravelSource) {\n            for (const key of allKeys) {\n                if (!key) continue;\n                const record = this.i18nIndex.getRecord(key);\n                if (!record) continue;\n                const hasLaravelLocation = record.locations.some((loc) => {\n                    const fsPath = loc.uri.fsPath.replace(/\\\\/g, '/');\n                    return fsPath.includes('/lang/') || fsPath.includes('/resources/lang/');\n                });\n                if (hasLaravelLocation) {\n                    validKeysSet.add(key);\n                }\n            }\n        } else {\n            for (const key of allKeys) {\n                if (!key) continue;\n                validKeysSet.add(key);\n            }\n        }\n        const missingKeys: Array<{ key: string; range: vscode.Range; hasVariables: boolean }> = [];\n\n        for (const { key, range, hasVariables } of keyMatches) {\n            if (!validKeysSet.has(key)) {\n                missingKeys.push({ key, range, hasVariables });\n            }\n        }\n\n        if (missingKeys.length === 0) {\n            vscode.window.showInformationMessage(\n                'AI Localizer: All translation keys in this file are valid.',\n            );\n            return;\n        }\n\n        const progressMessage = `Found ${missingKeys.length} missing translation key(s). Fixing...`;\n        \n        let finalFixedKeys: string[] = [];\n\n        // Acquire lock for bulk key management\n        await operationLock.withGlobalLock(\n            'key-management',\n            'Bulk Fix Missing References',\n            async () => {\n                await vscode.window.withProgress(\n                    {\n                        location: vscode.ProgressLocation.Notification,\n                        title: 'AI Localizer: Bulk Fix Missing References',\n                        cancellable: false,\n                    },\n                    async (progress) => {\n                        progress.report({ message: progressMessage });\n\n                        const startTime = Date.now();\n                        const edit = new vscode.WorkspaceEdit();\n                        const cfg = vscode.workspace.getConfiguration('ai-localizer');\n                        const defaultLocale = cfg.get<string>('i18n.defaultLocale') || 'en';\n                        const rootName = deriveRootFromFile(folder!, documentUri);\n                        const batchUpdates = new Map<string, { value: string; rootName?: string }>();\n\n                        let fixedCount = 0;\n                        let createdCount = 0;\n\n                        // Clear old caches for fresh batch operation\n                        clearLocaleCaches();\n\n                        // Build prefix index for faster typo-fix candidate lookup\n                        const keysByPrefix = new Map<string, Array<{ key: string; leaf: string }>>();\n                        for (const candidate of allKeys) {\n                            if (!candidate) continue;\n                            const parts = candidate.split('.').filter(Boolean);\n                            if (!parts.length) continue;\n                            const prefix = parts.slice(0, -1).join('.');\n                            const leaf = parts[parts.length - 1] || '';\n                            if (!keysByPrefix.has(prefix)) {\n                                keysByPrefix.set(prefix, []);\n                            }\n                            keysByPrefix.get(prefix)!.push({ key: candidate, leaf });\n                        }\n\n                        // PHASE 1: Try to fix typos first (fast, no git needed)\n                        const keysNeedingRecovery: Array<{ key: string; range: vscode.Range; hasVariables: boolean; targetKey: string }> = [];\n                        \n                        for (const { key, range, hasVariables } of missingKeys) {\n                            const keyParts = key.split('.').filter(Boolean);\n                            const keyPrefix = keyParts.slice(0, -1).join('.');\n                            const keyLeaf = keyParts[keyParts.length - 1] || '';\n\n                            let bestKey: string | null = null;\n                            let bestScore = Number.POSITIVE_INFINITY;\n\n                            const candidates = keysByPrefix.get(keyPrefix) || [];\n                            for (const { key: candidateKey, leaf } of candidates) {\n                                const score = computeEditDistance(keyLeaf, leaf);\n                                if (score < bestScore) {\n                                    bestScore = score;\n                                    bestKey = candidateKey;\n                                }\n                            }\n\n                            if (bestKey) {\n                                const bestParts = bestKey.split('.').filter(Boolean);\n                                const bestLeaf = bestParts[bestParts.length - 1] || '';\n                                const maxLen = Math.max(bestLeaf.length, keyLeaf.length);\n                                if (maxLen > 0 && bestScore <= Math.max(2, Math.floor(maxLen / 4))) {\n                                    edit.replace(documentUri, range, bestKey);\n                                    fixedCount++;\n                                    continue;\n                                }\n                            }\n\n                            const normalizedKey = !isLaravelSource\n                                ? this.buildNormalizedMissingReferenceKey(folder!, documentUri, key)\n                                : null;\n                            const targetKey = normalizedKey || key;\n\n                            if (targetKey !== key && validKeysSet.has(targetKey)) {\n                                const collapsed = this.buildCollapsedTranslationExpressionEdit(\n                                    doc,\n                                    range,\n                                    key,\n                                    targetKey,\n                                );\n                                if (collapsed) {\n                                    edit.replace(documentUri, collapsed.range, collapsed.newText);\n                                } else {\n                                    edit.replace(documentUri, range, targetKey);\n                                }\n                                fixedCount++;\n                                continue;\n                            }\n\n                            const lineText = doc.lineAt(range.start.line).text;\n                            const inlineDefault = !isLaravelSource\n                                ? this.extractInlineDefaultForKeyFromLine(lineText, key)\n                                : null;\n\n                            if (inlineDefault && inlineDefault.trim()) {\n                                const value = inlineDefault.trim();\n                                const collapsed = this.buildCollapsedTranslationExpressionEdit(\n                                    doc,\n                                    range,\n                                    key,\n                                    targetKey,\n                                );\n                                if (collapsed) {\n                                    edit.replace(documentUri, collapsed.range, collapsed.newText);\n                                } else if (targetKey !== key) {\n                                    edit.replace(documentUri, range, targetKey);\n                                }\n                                batchUpdates.set(targetKey, { value, rootName });\n                                createdCount++;\n                                continue;\n                            }\n                            \n                            // Key needs recovery from git\n                            keysNeedingRecovery.push({ key, range, hasVariables, targetKey });\n                        }\n\n                        const keysNeedingReview: Array<{ key: string; generatedValue: string }> = [];\n                        let recoveredCount = 0;\n\n                        if (keysNeedingRecovery.length > 0) {\n                            progress.report({\n                                message: `Recovering ${keysNeedingRecovery.length} key(s) from git history...`,\n                            });\n\n                            const batchRecovery = getBatchRecoveryHandler(this.context, this.log);\n                            const extractRef = batchRecovery.getExtractCommitRef(folder!);\n\n                            const keysToRecover = keysNeedingRecovery.map((k) => k.key);\n                            const recoveryResults = await batchRecovery.recoverKeysBatch(\n                                folder!,\n                                keysToRecover,\n                                defaultLocale,\n                                {\n                                    daysBack: 365,\n                                    maxCommitsPerFile: 100,\n                                    extractRef,\n                                },\n                            );\n\n                            const unresolvedKeys: string[] = [];\n\n                            for (const { key, range, targetKey } of keysNeedingRecovery) {\n                                const result = recoveryResults.get(key);\n\n                                if (result && result.value) {\n                                    const collapsed = this.buildCollapsedTranslationExpressionEdit(\n                                        doc,\n                                        range,\n                                        key,\n                                        targetKey,\n                                    );\n                                    if (collapsed) {\n                                        edit.replace(documentUri, collapsed.range, collapsed.newText);\n                                    } else if (targetKey !== key) {\n                                        edit.replace(documentUri, range, targetKey);\n                                    }\n                                    batchUpdates.set(targetKey, { value: result.value, rootName });\n                                    createdCount++;\n                                    recoveredCount++;\n                                    continue;\n                                }\n\n                                let sourceRecovery: { value: string } | null = null;\n                                try {\n                                    sourceRecovery = await this.gitRecoveryHandler.recoverFromSourceFileHistory(\n                                        folder!,\n                                        documentUri.fsPath,\n                                        key,\n                                        defaultLocale,\n                                        365,\n                                        '[BulkMissingRef]',\n                                    );\n                                } catch {\n                                    sourceRecovery = null;\n                                }\n\n                                if (sourceRecovery && sourceRecovery.value) {\n                                    const collapsed = this.buildCollapsedTranslationExpressionEdit(\n                                        doc,\n                                        range,\n                                        key,\n                                        targetKey,\n                                    );\n                                    if (collapsed) {\n                                        edit.replace(documentUri, collapsed.range, collapsed.newText);\n                                    } else if (targetKey !== key) {\n                                        edit.replace(documentUri, range, targetKey);\n                                    }\n                                    batchUpdates.set(targetKey, { value: sourceRecovery.value, rootName });\n                                    createdCount++;\n                                    recoveredCount++;\n                                    continue;\n                                }\n\n                                unresolvedKeys.push(key);\n                            }\n\n                            let aiDefaults = new Map<string, string>();\n                            if (unresolvedKeys.length > 0) {\n                                try {\n                                    aiDefaults = await this.inferDefaultValuesForMissingKeysWithAI(\n                                        text,\n                                        unresolvedKeys,\n                                    );\n                                } catch {\n                                    aiDefaults = new Map<string, string>();\n                                }\n                            }\n\n                            for (const key of unresolvedKeys) {\n                                const aiValue = aiDefaults.get(key);\n                                if (aiValue && aiValue.trim()) {\n                                    const entry = keysNeedingRecovery.find((k) => k.key === key);\n                                    const targetKey = entry?.targetKey || key;\n                                    if (entry && entry.targetKey !== key) {\n                                        edit.replace(documentUri, entry.range, entry.targetKey);\n                                    }\n                                    batchUpdates.set(targetKey, { value: aiValue.trim(), rootName });\n                                    createdCount++;\n                                    continue;\n                                }\n\n                                const keyParts = key.split('.').filter(Boolean);\n                                const lastSegment = keyParts[keyParts.length - 1] || '';\n                                let label = buildLabelFromKeySegment(lastSegment) || key;\n\n                                if (/last[_\\s]+(\\d+)\\b/i.test(lastSegment) && !/\\bdays?\\b/i.test(label)) {\n                                    const replaced = label.replace(/last\\s+(\\d+)\\b/i, 'last $1 days');\n                                    label = replaced !== label ? replaced : `${label} days`;\n                                }\n\n                                const entry = keysNeedingRecovery.find((k) => k.key === key);\n                                const targetKey = entry?.targetKey || key;\n                                if (entry && entry.targetKey !== key) {\n                                    edit.replace(documentUri, entry.range, entry.targetKey);\n                                }\n                                batchUpdates.set(targetKey, { value: label, rootName });\n                                createdCount++;\n                                keysNeedingReview.push({ key: targetKey, generatedValue: label });\n                            }\n                        }\n\n                        // PHASE 3: Apply edits and write batch updates\n                        if (edit.size > 0) {\n                            const applied = await vscode.workspace.applyEdit(edit);\n                            if (applied) {\n                                await doc.save();\n                            }\n                        }\n\n                        if (batchUpdates.size > 0) {\n                            try {\n                                if (isLaravelSource) {\n                                    for (const [key, { value }] of batchUpdates.entries()) {\n                                        await setLaravelTranslationValue(folder!, defaultLocale, key, value);\n                                    }\n                                } else {\n                                    await setTranslationValuesBatch(folder!, defaultLocale, batchUpdates);\n                                }\n                            } catch (applyErr) {\n                                this.log?.appendLine(\n                                    `[BulkFixMissingRefs] Failed to write ${batchUpdates.size} batch update(s): ${String(applyErr)}`,\n                                );\n                                throw applyErr;\n                            }\n                        }\n\n                        // PHASE 4: Sync keys to other locales\n                        if (batchUpdates.size > 0) {\n                            progress.report({ message: 'Syncing to other locales...' });\n                            try {\n                                const syncService = getGranularSyncService(this.context);\n                                const keysToSync = Array.from(batchUpdates.keys());\n                                await syncService.syncKeys(folder!, keysToSync, { verbose: false });\n                                this.log?.appendLine(`[BulkFixMissingRefs] Synced ${keysToSync.length} keys to other locales`);\n                            } catch (syncErr) {\n                                this.log?.appendLine(`[BulkFixMissingRefs] Locale sync warning: ${String(syncErr)}`);\n                            }\n                        }\n\n                        if (keysNeedingReview.length > 0) {\n                            await this.generateReviewReport(folder!, documentUri, keysNeedingReview);\n                        }\n\n                        finalFixedKeys = Array.from(batchUpdates.keys());\n\n                        const elapsed = Date.now() - startTime;\n                        const recoveryRate = keysNeedingRecovery.length > 0 \n                            ? Math.round((recoveredCount / keysNeedingRecovery.length) * 100) \n                            : 100;\n                        \n                        let message = `Fixed ${fixedCount} typo(s), created ${createdCount} key(s) (${recoveryRate}% recovered from git) in ${elapsed}ms.`;\n                        if (keysNeedingReview.length > 0) {\n                            message += ` ${keysNeedingReview.length} key(s) need review.`;\n                        }\n                        \n                        this.log?.appendLine(`[BulkFixMissingRefs] ${message}`);\n                        vscode.window.showInformationMessage(`AI Localizer: ${message}`);\n                    },\n                );\n            }\n        );\n\n        // Refresh diagnostics outside the key-management lock to avoid thrashing\n        if (finalFixedKeys.length > 0) {\n            try {\n                // Invalidate stale report entries\n                await vscode.commands.executeCommand(\n                    'ai-localizer.i18n.invalidateReportKeys',\n                    finalFixedKeys,\n                );\n\n                // Trigger rescan to refresh diagnostics\n                await vscode.commands.executeCommand('ai-localizer.i18n.rescan');\n\n                // Also refresh diagnostics for the current file\n                await vscode.commands.executeCommand(\n                    'ai-localizer.i18n.refreshFileDiagnostics',\n                    documentUri,\n                    finalFixedKeys,\n                );\n            } catch (refreshErr) {\n                this.log?.appendLine(\n                    `[BulkFixMissingRefs] Diagnostics refresh warning: ${String(refreshErr)}`,\n                );\n            }\n        }\n    }\n\n    private async inferDefaultValuesForMissingKeysWithAI(\n        fileText: string,\n        keys: string[],\n    ): Promise<Map<string, string>> {\n        const result = new Map<string, string>();\n        if (!this.translationService || !keys.length) {\n            return result;\n        }\n\n        let apiKey = '';\n        try {\n            apiKey = await this.translationService.getApiKey();\n        } catch {\n            apiKey = '';\n        }\n\n        if (!apiKey) {\n            return result;\n        }\n\n        const uniqueKeys = Array.from(new Set(keys.filter((k) => typeof k === 'string' && k.trim())));\n        if (!uniqueKeys.length) {\n            return result;\n        }\n\n        const snippetLimit = 12000;\n        let context = fileText || '';\n        if (context.length > snippetLimit) {\n            context = context.slice(0, snippetLimit);\n        }\n\n        const keyList = uniqueKeys.join('\\n');\n        const questionLines = [\n            'We have an i18n system using t(\"keyPath\") calls in a React/TypeScript codebase.',\n            'For each key below, guess a concise, natural-sounding English UI text suitable for the default locale (en).',\n            'Respond with one key per line in this exact format:',\n            '<key>\\t<value>',\n            'Do not include any other commentary or explanation.',\n            '',\n            'Keys:',\n            keyList,\n        ];\n        const question = questionLines.join('\\n');\n\n        let answer: string;\n        try {\n            answer = await this.translationService.askQuestion(question, context);\n        } catch {\n            return result;\n        }\n\n        if (!answer) {\n            return result;\n        }\n\n        const wanted = new Set(uniqueKeys);\n        const lines = answer.split(/\\r?\\n/).map((l) => l.trim()).filter(Boolean);\n        for (const line of lines) {\n            const idx = line.indexOf('\\t');\n            if (idx <= 0) {\n                continue;\n            }\n            const key = line.slice(0, idx).trim();\n            const value = line.slice(idx + 1).trim();\n            if (!key || !value || !wanted.has(key)) {\n                continue;\n            }\n            result.set(key, value);\n        }\n\n        return result;\n    }\n\n    /**\n     * Generate a JSON report for keys that couldn't be recovered from git\n     */\n    private async generateReviewReport(\n        folder: vscode.WorkspaceFolder,\n        sourceUri: vscode.Uri,\n        keysNeedingReview: Array<{ key: string; generatedValue: string }>,\n    ): Promise<void> {\n        if (keysNeedingReview.length === 0) return;\n\n        const scriptsDir = vscode.Uri.joinPath(folder.uri, 'scripts');\n        const reportUri = vscode.Uri.joinPath(scriptsDir, '.i18n-review-generated.json');\n\n        try {\n            // Ensure scripts directory exists\n            try {\n                await vscode.workspace.fs.createDirectory(scriptsDir);\n            } catch {\n                // Directory might already exist\n            }\n\n            // Load existing report if any\n            let existingReport: any = { files: [] };\n            try {\n                const data = await vscode.workspace.fs.readFile(reportUri);\n                existingReport = JSON.parse(sharedDecoder.decode(data));\n            } catch {\n                // No existing report\n            }\n\n            const relativePath = path.relative(folder.uri.fsPath, sourceUri.fsPath).replace(/\\\\/g, '/');\n            const timestamp = new Date().toISOString();\n\n            // Find or create file entry\n            let fileEntry = existingReport.files?.find((f: any) => f.file === relativePath);\n            if (!fileEntry) {\n                fileEntry = { file: relativePath, issues: [] };\n                if (!existingReport.files) {\n                    existingReport.files = [];\n                }\n                existingReport.files.push(fileEntry);\n            }\n\n            // Add new issues (avoid duplicates) and keep compact fields\n            fileEntry.issues = Array.isArray(fileEntry.issues) ? fileEntry.issues : [];\n            const existingKeys = new Set(fileEntry.issues.map((i: any) => i.key));\n            for (const { key, generatedValue } of keysNeedingReview) {\n                if (existingKeys.has(key)) continue;\n                fileEntry.issues.push({\n                    key,\n                    value: generatedValue,\n                });\n            }\n\n            // Rewrite in compact form: only file and key/value pairs\n            const compact = {\n                files: existingReport.files.map((f: any) => ({\n                    file: f.file,\n                    issues: Array.isArray(f.issues)\n                        ? f.issues.map((i: any) => ({ key: i.key, value: i.value ?? i.generatedValue ?? '' }))\n                        : [],\n                })),\n            };\n\n            const payload = JSON.stringify(compact, null, 2) + '\\n';\n            await vscode.workspace.fs.writeFile(reportUri, sharedEncoder.encode(payload));\n\n            this.log?.appendLine(\n                `[BulkFixMissingRefs] Generated review report (compact): ${keysNeedingReview.length} keys added to ${reportUri.fsPath}`,\n            );\n        } catch (err) {\n            this.log?.appendLine(`[BulkFixMissingRefs] Failed to generate review report: ${String(err)}`);\n        }\n    }\n\n    /**\n     * Delete a key from multiple locale files with guard\n     */\n    async deleteKeyFromLocaleFiles(\n        keyPath: string,\n        uris: vscode.Uri[],\n        defaultValue?: string,\n    ): Promise<number> {\n        if (!uris.length) return 0;\n\n        const changedUris: vscode.Uri[] = [];\n\n        for (const uri of uris) {\n            try {\n                const doc = await vscode.workspace.openTextDocument(uri);\n                if (doc.languageId !== 'json' && doc.languageId !== 'jsonc') {\n                    continue;\n                }\n\n                let root: any = await readJsonFile(uri) || {};\n                if (!root || typeof root !== 'object' || Array.isArray(root)) root = {};\n\n                const currentValue = getNestedValue(root, keyPath);\n                const valueToRestore = defaultValue || (typeof currentValue === 'string' ? currentValue : '');\n\n                if (valueToRestore) {\n                    const allowed = await this.guardDeleteDefaultLocaleKey(uri, keyPath, valueToRestore);\n                    if (!allowed) continue;\n                }\n\n                if (!deleteKeyPathInObject(root, keyPath)) {\n                    continue;\n                }\n\n                await writeJsonFile(uri, root);\n                changedUris.push(uri);\n            } catch {\n                // Ignore failures for individual locale files\n            }\n        }\n\n        for (const uri of changedUris) {\n            try {\n                await this.i18nIndex.updateFile(uri);\n                await vscode.commands.executeCommand(\n                    'ai-localizer.i18n.refreshFileDiagnostics',\n                    uri,\n                    [keyPath],\n                );\n            } catch {\n                // Ignore failures during diagnostics refresh\n            }\n        }\n\n        return changedUris.length;\n    }\n\n    /**\n     * Guard: Prevent deletion of default locale keys that are used in components\n     */\n    async guardDeleteDefaultLocaleKey(\n        localeUri: vscode.Uri,\n        keyPath: string,\n        defaultValue: string,\n    ): Promise<boolean> {\n        const folder = vscode.workspace.getWorkspaceFolder(localeUri);\n        if (!folder) return true;\n\n        const cfg = vscode.workspace.getConfiguration('ai-localizer');\n        const defaultLocale = cfg.get<string>('i18n.defaultLocale') || 'en';\n\n        const localePath = localeUri.fsPath.toLowerCase();\n        const isDefaultLocale = localePath.includes(`/${defaultLocale}/`) ||\n            localePath.includes(`/${defaultLocale}.json`);\n\n        if (!isDefaultLocale) return true;\n\n        await this.i18nIndex.ensureInitialized();\n        const record = this.i18nIndex.getRecord(keyPath);\n        const isUsed = record && record.locations.length > 0;\n\n        if (!isUsed) return true;\n\n        const message = `Key \"${keyPath}\" is used in ${record.locations.length} component(s). Deleting it will cause missing translations.`;\n        const choice = await vscode.window.showWarningMessage(\n            message,\n            { modal: true },\n            'Delete Anyway',\n            'Cancel',\n        );\n\n        if (choice !== 'Delete Anyway') return false;\n\n        // Show restore option after 5 seconds\n        const guardKey = `${localeUri.toString()}:${keyPath}`;\n        const timeout = setTimeout(async () => {\n            this.deletionGuardPending.delete(guardKey);\n            const restoreChoice = await vscode.window.showInformationMessage(\n                `Key \"${keyPath}\" was deleted. You can restore it from git history.`,\n                'Restore from Git History',\n                'Dismiss',\n            );\n            if (restoreChoice === 'Restore from Git History') {\n                await this.restoreDeletedKey(localeUri, keyPath, defaultValue, folder);\n            }\n        }, 5000);\n\n        this.deletionGuardPending.set(guardKey, {\n            key: keyPath,\n            value: defaultValue,\n            timeout,\n        });\n\n        return true;\n    }\n\n    /**\n     * Restore a deleted key, trying git history first if value is not provided\n     */\n    private async restoreDeletedKey(\n        localeUri: vscode.Uri,\n        keyPath: string,\n        value: string,\n        folder: vscode.WorkspaceFolder,\n    ): Promise<void> {\n        try {\n            let restoreValue = value;\n\n            if (!restoreValue || !restoreValue.trim()) {\n                const historyResult = await findKeyInHistory(folder, localeUri.fsPath, keyPath, 30);\n                if (historyResult && historyResult.value) {\n                    restoreValue = historyResult.value;\n                } else if (this.context) {\n                    const extractRef = CommitTracker.getExtractCommitRef(this.context, folder);\n                    if (extractRef) {\n                        const content = await getFileContentAtCommit(\n                            folder,\n                            localeUri.fsPath,\n                            extractRef.commitHash,\n                        );\n                        if (content) {\n                            try {\n                                const json = JSON.parse(content);\n                                const recovered = getNestedValue(json, keyPath);\n                                if (recovered && typeof recovered === 'string') {\n                                    restoreValue = recovered;\n                                }\n                            } catch {\n                                // Invalid JSON\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (!restoreValue || !restoreValue.trim()) {\n                vscode.window.showWarningMessage(\n                    `AI Localizer: Could not recover value for key \"${keyPath}\" from git history.`,\n                );\n                return;\n            }\n\n            let root: any = await readJsonFile(localeUri) || {};\n\n            setNestedValue(root, keyPath, restoreValue);\n            await writeJsonFile(localeUri, root);\n\n            await this.i18nIndex.updateFile(localeUri);\n            vscode.window.showInformationMessage(`AI Localizer: Restored key \"${keyPath}\".`);\n        } catch (err) {\n            console.error('AI Localizer: Failed to restore deleted key:', err);\n            vscode.window.showErrorMessage('AI Localizer: Failed to restore deleted key.');\n        }\n    }\n}\n\n\n\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\untranslated\\handlers\\reportHandler.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'readJsonFile' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":52},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":127,"column":21,"nodeType":"BlockStatement","messageId":"unexpected","endLine":127,"endColumn":23,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[4682,4682],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":242,"column":17,"nodeType":"BlockStatement","messageId":"unexpected","endLine":242,"endColumn":19,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[9566,9566],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":283,"column":17,"nodeType":"BlockStatement","messageId":"unexpected","endLine":283,"endColumn":19,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[11643,11643],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":314,"column":21,"nodeType":"BlockStatement","messageId":"unexpected","endLine":314,"endColumn":23,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[13125,13125],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":378,"column":48,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":378,"endColumn":49,"suggestions":[{"messageId":"removeEscape","fix":{"range":[15498,15499],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[15498,15498],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\-.","line":378,"column":50,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":378,"endColumn":51,"suggestions":[{"messageId":"removeEscape","fix":{"range":[15500,15501],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[15500,15500],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":668,"column":21,"nodeType":"BlockStatement","messageId":"unexpected","endLine":668,"endColumn":23,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[28033,28033],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\r\nimport * as path from 'path';\r\nimport { I18nIndex } from '../../../core/i18nIndex';\r\nimport { TranslationService } from '../../../services/translationService';\r\nimport { setTranslationValuesBatch } from '../../../core/i18nFs';\r\nimport { pickWorkspaceFolder } from '../../../core/workspace';\r\nimport { sharedDecoder, sharedEncoder, readJsonFile, writeJsonFile } from '../utils/jsonUtils';\r\n\r\nexport class ReportHandler {\r\n    constructor(\r\n        private i18nIndex: I18nIndex,\r\n        private translationService: TranslationService,\r\n        private getRootNameForRecord: (record: any) => string,\r\n    ) {}\r\n\r\n    /**\r\n     * Open the untranslated report file\r\n     */\r\n    async openReport(): Promise<void> {\r\n        const active = vscode.window.activeTextEditor;\r\n        let folder = active\r\n            ? vscode.workspace.getWorkspaceFolder(active.document.uri) ?? undefined\r\n            : undefined;\r\n\r\n        if (!folder) {\r\n            folder = await pickWorkspaceFolder();\r\n        }\r\n        if (!folder) {\r\n            vscode.window.showInformationMessage('AI Localizer: No workspace folder available.');\r\n            return;\r\n        }\r\n\r\n        const reportUri = vscode.Uri.file(\r\n            path.join(folder.uri.fsPath, 'scripts', '.i18n-untranslated-report.json'),\r\n        );\r\n\r\n        try {\r\n            const doc = await vscode.workspace.openTextDocument(reportUri);\r\n            await vscode.window.showTextDocument(doc, { preview: false });\r\n        } catch {\r\n            vscode.window.showInformationMessage(\r\n                'AI Localizer: Untranslated report not found. Run the fix-untranslated script first.',\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply AI fixes from the untranslated report\r\n     */\r\n    async applyAiFixes(\r\n        pruneReportsCallback: (folder: vscode.WorkspaceFolder, fixed: Array<{ locale: string; keyPath: string }>) => Promise<void>,\r\n    ): Promise<void> {\r\n        const active = vscode.window.activeTextEditor;\r\n        let folder = active\r\n            ? vscode.workspace.getWorkspaceFolder(active.document.uri) ?? undefined\r\n            : undefined;\r\n\r\n        if (!folder) {\r\n            folder = await pickWorkspaceFolder();\r\n        }\r\n\r\n        if (!folder) {\r\n            vscode.window.showInformationMessage('AI Localizer: No workspace folder available.');\r\n            return;\r\n        }\r\n\r\n        const reportUri = vscode.Uri.file(\r\n            path.join(folder.uri.fsPath, 'scripts', '.i18n-untranslated-report.json'),\r\n        );\r\n\r\n        let raw: string;\r\n\r\n        try {\r\n            const data = await vscode.workspace.fs.readFile(reportUri);\r\n            raw = sharedDecoder.decode(data);\r\n        } catch {\r\n            vscode.window.showInformationMessage(\r\n                'AI Localizer: Untranslated report not found. Run the fix-untranslated script before applying AI fixes.',\r\n            );\r\n            return;\r\n        }\r\n\r\n        let report: any;\r\n        try {\r\n            report = JSON.parse(raw);\r\n        } catch {\r\n            vscode.window.showErrorMessage('AI Localizer: Untranslated report is not valid JSON.');\r\n            return;\r\n        }\r\n\r\n        const issues = Array.isArray(report.issues) ? report.issues : [];\r\n        if (!issues.length) {\r\n            vscode.window.showInformationMessage('AI Localizer: No issues found in untranslated report.');\r\n            return;\r\n        }\r\n\r\n        let aiInstructions: string | undefined;\r\n        try {\r\n            const instructionsUri = vscode.Uri.file(\r\n                path.join(folder.uri.fsPath, 'scripts', '.i18n-untranslated-ai-instructions.txt'),\r\n            );\r\n            const instructionsData = await vscode.workspace.fs.readFile(instructionsUri);\r\n            aiInstructions = sharedDecoder.decode(instructionsData).trim() || undefined;\r\n        } catch {\r\n            // Instructions file is optional\r\n        }\r\n\r\n        try {\r\n            const updates = await this.translationService.getUntranslatedFixes(\r\n                issues,\r\n                aiInstructions,\r\n            );\r\n\r\n            if (!updates.length) {\r\n                vscode.window.showInformationMessage(\r\n                    'AI Localizer: No valid translation updates returned by AI.',\r\n                );\r\n                return;\r\n            }\r\n\r\n            try {\r\n                const previewDoc = await vscode.workspace.openTextDocument({\r\n                    language: 'json',\r\n                    content: JSON.stringify({ updates }, null, 2),\r\n                } as any);\r\n                await vscode.window.showTextDocument(previewDoc, { preview: false });\r\n            } catch {}\r\n\r\n            const choice = await vscode.window.showQuickPick(\r\n                [\r\n                    {\r\n                        label: 'Apply',\r\n                        description: `Write ${updates.length} translation updates to locale files`,\r\n                    },\r\n                    { label: 'Cancel', description: 'Discard AI suggestions' },\r\n                ],\r\n                { placeHolder: 'Apply AI translation suggestions from untranslated report?' },\r\n            );\r\n\r\n            if (!choice || choice.label !== 'Apply') {\r\n                return;\r\n            }\r\n\r\n            await this.i18nIndex.ensureInitialized();\r\n\r\n            const updatesByLocale = new Map<string, Map<string, { value: string; rootName?: string }>>();\r\n            for (const u of updates) {\r\n                const record = this.i18nIndex.getRecord(u.keyPath);\r\n                const rootName = record ? this.getRootNameForRecord(record) : 'common';\r\n\r\n                let localeUpdates = updatesByLocale.get(u.locale);\r\n                if (!localeUpdates) {\r\n                    localeUpdates = new Map();\r\n                    updatesByLocale.set(u.locale, localeUpdates);\r\n                }\r\n                localeUpdates.set(u.keyPath, { value: u.newValue, rootName });\r\n            }\r\n\r\n            let totalWritten = 0;\r\n            for (const [locale, batchUpdates] of updatesByLocale.entries()) {\r\n                const result = await setTranslationValuesBatch(folder, locale, batchUpdates);\r\n                totalWritten += result.written;\r\n            }\r\n\r\n            await pruneReportsCallback(\r\n                folder,\r\n                updates.map((u) => ({ locale: u.locale, keyPath: u.keyPath })),\r\n            );\r\n\r\n            vscode.window.showInformationMessage(\r\n                `AI Localizer: Applied ${totalWritten} AI translation updates.`,\r\n            );\r\n\r\n            // Rescan to refresh index and diagnostics after applying AI fixes\r\n            try {\r\n                await vscode.commands.executeCommand('ai-localizer.i18n.rescan');\r\n            } catch {\r\n                // Ignore rescan failures; updates are already written\r\n            }\r\n        } catch (err) {\r\n            console.error('Failed to apply AI fixes:', err);\r\n            vscode.window.showErrorMessage(`AI Localizer: Failed to apply AI fixes. ${err}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prune fixed items from untranslated reports\r\n     */\r\n    async pruneUntranslatedReports(\r\n        folder: vscode.WorkspaceFolder,\r\n        fixed: Array<{ locale: string; keyPath: string }>,\r\n    ): Promise<void> {\r\n        if (!fixed.length) return;\r\n\r\n        const keySet = new Set<string>();\r\n        for (const item of fixed) {\r\n            if (!item || !item.locale || !item.keyPath) continue;\r\n            keySet.add(`${item.locale}::${item.keyPath}`);\r\n        }\r\n        if (!keySet.size) return;\r\n\r\n        const remainingCompactKeys = new Set<string>();\r\n        let remainingCompactKnown = false;\r\n\r\n        let prunedUntranslatedIssues = 0;\r\n        let prunedCompactEntries = 0;\r\n\r\n        const scriptsDir = vscode.Uri.joinPath(folder.uri, 'scripts');\r\n\r\n        // Combined untranslated/style report\r\n        try {\r\n            const combinedUri = vscode.Uri.joinPath(scriptsDir, '.i18n-untranslated-report.json');\r\n            const data = await vscode.workspace.fs.readFile(combinedUri);\r\n            const raw = sharedDecoder.decode(data);\r\n            const report: any = JSON.parse(raw);\r\n            const issues: any[] = Array.isArray(report.issues) ? report.issues : [];\r\n            if (issues.length) {\r\n                const filtered = issues.filter((issue: any) => {\r\n                    if (!issue || typeof issue.locale !== 'string' || typeof issue.keyPath !== 'string') {\r\n                        return true;\r\n                    }\r\n                    const key = `${issue.locale}::${issue.keyPath}`;\r\n                    return !keySet.has(key);\r\n                });\r\n                if (filtered.length !== issues.length) {\r\n                    report.issues = filtered;\r\n                    await writeJsonFile(combinedUri, report);\r\n                }\r\n\r\n                const remainingIssues: any[] = Array.isArray(report.issues) ? report.issues : [];\r\n                for (const issue of remainingIssues) {\r\n                    if (!issue || issue.issueType !== 'untranslated' || typeof issue.locale !== 'string') {\r\n                        continue;\r\n                    }\r\n                    const locale = issue.locale as string;\r\n                    const localeFile = typeof issue.localeFile === 'string' ? issue.localeFile : '';\r\n                    if (!locale) continue;\r\n                    remainingCompactKeys.add(`${locale}::${localeFile}`);\r\n                }\r\n                remainingCompactKnown = true;\r\n            }\r\n        } catch {}\r\n\r\n        // Untranslated-only grouped report\r\n        try {\r\n            const untranslatedUri = vscode.Uri.joinPath(scriptsDir, '.i18n-untranslated-untranslated.json');\r\n            const data = await vscode.workspace.fs.readFile(untranslatedUri);\r\n            const raw = sharedDecoder.decode(data);\r\n            const report: any = JSON.parse(raw);\r\n            const files: any[] = Array.isArray(report.files) ? report.files : [];\r\n            let changed = false;\r\n\r\n            const newFiles = files\r\n                .map((entry: any) => {\r\n                    if (!entry || typeof entry.locale !== 'string' || !Array.isArray(entry.issues)) {\r\n                        return entry;\r\n                    }\r\n                    const locale = entry.locale;\r\n                    const beforeCount = entry.issues.length;\r\n                    const filteredIssues = entry.issues.filter((issue: any) => {\r\n                        const keyPath = issue && typeof issue.keyPath === 'string' ? issue.keyPath : null;\r\n                        if (!keyPath) return true;\r\n                        const key = `${locale}::${keyPath}`;\r\n                        return !keySet.has(key);\r\n                    });\r\n                    if (filteredIssues.length !== beforeCount) {\r\n                        changed = true;\r\n                        prunedUntranslatedIssues += beforeCount - filteredIssues.length;\r\n                    }\r\n                    const result = filteredIssues.length ? { ...entry, issues: filteredIssues } : null;\r\n                    if (result && remainingCompactKnown) {\r\n                        const localeFile = typeof result.localeFile === 'string' ? result.localeFile : '';\r\n                        remainingCompactKeys.add(`${locale}::${localeFile}`);\r\n                    }\r\n                    return result;\r\n                })\r\n                .filter((entry: any) => !!entry);\r\n\r\n            if (changed) {\r\n                report.files = newFiles;\r\n                await writeJsonFile(untranslatedUri, report);\r\n            }\r\n        } catch {}\r\n\r\n        // Compact untranslated report\r\n        if (remainingCompactKnown) {\r\n            try {\r\n                const compactUri = vscode.Uri.joinPath(scriptsDir, '.i18n-untranslated-compact.json');\r\n                const data = await vscode.workspace.fs.readFile(compactUri);\r\n                const raw = sharedDecoder.decode(data);\r\n                const report: any = JSON.parse(raw);\r\n                const files: any[] = Array.isArray(report.files) ? report.files : [];\r\n\r\n                const newFiles = files\r\n                    .map((entry: any) => {\r\n                        if (!entry || typeof entry.locale !== 'string') {\r\n                            return entry;\r\n                        }\r\n                        const locale = entry.locale as string;\r\n                        const localeFile = typeof entry.localeFile === 'string' ? entry.localeFile : '';\r\n                        const key = `${locale}::${localeFile}`;\r\n                        if (!remainingCompactKeys.has(key)) {\r\n                            return null;\r\n                        }\r\n                        return entry;\r\n                    })\r\n                    .filter((entry: any) => !!entry);\r\n\r\n                if (newFiles.length !== files.length) {\r\n                    prunedCompactEntries += files.length - newFiles.length;\r\n                    report.files = newFiles;\r\n                    await writeJsonFile(compactUri, report);\r\n                }\r\n            } catch {}\r\n        }\r\n\r\n        if (prunedUntranslatedIssues > 0 || prunedCompactEntries > 0) {\r\n            const parts: string[] = [];\r\n            if (prunedUntranslatedIssues > 0) {\r\n                parts.push(\r\n                    `${prunedUntranslatedIssues} untranslated issue${prunedUntranslatedIssues === 1 ? '' : 's'}`,\r\n                );\r\n            }\r\n            if (prunedCompactEntries > 0) {\r\n                parts.push(\r\n                    `${prunedCompactEntries} compact entr${prunedCompactEntries === 1 ? 'y' : 'ies'}`,\r\n                );\r\n            }\r\n            const summary = parts.join(', ');\r\n            vscode.window.showInformationMessage(\r\n                `AI Localizer: Pruned ${summary} from untranslated reports.`,\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Review selection for untranslated keys\r\n     */\r\n    async reviewSelection(\r\n        applyQuickFix: (documentUri: vscode.Uri, key: string, locales: string[]) => Promise<void>,\r\n    ): Promise<void> {\r\n        try {\r\n            const editor = vscode.window.activeTextEditor;\r\n            if (!editor) {\r\n                vscode.window.showInformationMessage('AI Localizer: No active editor.');\r\n                return;\r\n            }\r\n\r\n            const document = editor.document;\r\n            const langId = document.languageId;\r\n            const isCode =\r\n                langId === 'javascript' ||\r\n                langId === 'typescript' ||\r\n                langId === 'javascriptreact' ||\r\n                langId === 'typescriptreact' ||\r\n                langId === 'vue' ||\r\n                langId === 'blade' ||\r\n                langId === 'php';\r\n\r\n            if (!isCode) {\r\n                vscode.window.showInformationMessage(\r\n                    'AI Localizer: Selection review only applies to JS/TS, Vue, and Blade/PHP files.',\r\n                );\r\n                return;\r\n            }\r\n\r\n            const selection = editor.selection;\r\n            if (selection.isEmpty) {\r\n                vscode.window.showInformationMessage(\r\n                    'AI Localizer: Please select the code containing i18n keys to review.',\r\n                );\r\n                return;\r\n            }\r\n\r\n            await this.i18nIndex.ensureInitialized();\r\n\r\n            const selectionText = document.getText(selection);\r\n            const keyRegex = /['\"`]([A-Za-z0-9_\\.\\-]+)['\"`]/g;\r\n            const keysInSelection = new Set<string>();\r\n\r\n            let match: RegExpExecArray | null;\r\n            // eslint-disable-next-line no-cond-assign\r\n            while ((match = keyRegex.exec(selectionText)) !== null) {\r\n                const key = match[1];\r\n                if (key) {\r\n                    keysInSelection.add(key);\r\n                }\r\n            }\r\n\r\n            if (!keysInSelection.size) {\r\n                vscode.window.showInformationMessage(\r\n                    'AI Localizer: No known i18n keys found in the current selection.',\r\n                );\r\n                return;\r\n            }\r\n\r\n            const unresolvedByKey = new Map<string, Set<string>>();\r\n            const allDiagnostics = vscode.languages.getDiagnostics();\r\n\r\n            for (const entry of allDiagnostics) {\r\n                const diags = entry[1];\r\n                if (!diags || !diags.length) continue;\r\n\r\n                for (const d of diags) {\r\n                    if (String(d.code) !== 'ai-i18n.untranslated') continue;\r\n                    const { parseUntranslatedDiagnostic } = await import('../utils/diagnosticParser');\r\n                    const parsed = parseUntranslatedDiagnostic(String(d.message || ''));\r\n                    if (!parsed || !parsed.key || !parsed.locales || !parsed.locales.length) continue;\r\n                    if (!keysInSelection.has(parsed.key)) continue;\r\n                    let set = unresolvedByKey.get(parsed.key);\r\n                    if (!set) {\r\n                        set = new Set<string>();\r\n                        unresolvedByKey.set(parsed.key, set);\r\n                    }\r\n                    for (const locale of parsed.locales) {\r\n                        if (locale) set.add(locale);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!unresolvedByKey.size) {\r\n                vscode.window.showInformationMessage(\r\n                    'AI Localizer: No untranslated diagnostics found for keys in the current selection.',\r\n                );\r\n                return;\r\n            }\r\n\r\n            let totalIssues = 0;\r\n            for (const set of unresolvedByKey.values()) {\r\n                totalIssues += set.size;\r\n            }\r\n\r\n            const choice = await vscode.window.showQuickPick(\r\n                [\r\n                    {\r\n                        label: `Translate ${totalIssues} value(s) for ${unresolvedByKey.size} key(s)`,\r\n                        description:\r\n                            'Use AI to translate missing or untranslated locales for all keys in this selection.',\r\n                    },\r\n                    {\r\n                        label: 'Cancel',\r\n                        description: 'Do not change translations for this selection.',\r\n                    },\r\n                ],\r\n                {\r\n                    placeHolder:\r\n                        'AI Localizer: Apply AI translations for i18n issues in this selection?',\r\n                },\r\n            );\r\n\r\n            if (!choice || choice.label === 'Cancel') return;\r\n\r\n            let translatedRequests = 0;\r\n            for (const [key, localeSet] of unresolvedByKey.entries()) {\r\n                const locales = Array.from(localeSet);\r\n                if (!locales.length) continue;\r\n                await applyQuickFix(document.uri, key, locales);\r\n                translatedRequests += locales.length;\r\n            }\r\n\r\n            if (translatedRequests > 0) {\r\n                vscode.window.showInformationMessage(\r\n                    `AI Localizer: Requested AI translations for ${translatedRequests} value(s) across ${unresolvedByKey.size} key(s) in this selection.`,\r\n                );\r\n            }\r\n        } catch (err) {\r\n            console.error('AI Localizer: Failed to review selection for i18n issues:', err);\r\n            vscode.window.showErrorMessage(\r\n                'AI Localizer: Failed to review selection for i18n issues.',\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Show workspace health report\r\n     */\r\n    async showHealthReport(): Promise<void> {\r\n        try {\r\n            const allDiagnostics = vscode.languages.getDiagnostics();\r\n            const codeTotals = new Map<string, number>();\r\n            const fileTotals = new Map<string, { uri: vscode.Uri; count: number; byCode: Map<string, number> }>();\r\n\r\n            for (const [uri, diags] of allDiagnostics) {\r\n                if (!diags || !diags.length) continue;\r\n                const fileKey = uri.toString();\r\n                let fileEntry = fileTotals.get(fileKey);\r\n                if (!fileEntry) {\r\n                    fileEntry = { uri, count: 0, byCode: new Map<string, number>() };\r\n                    fileTotals.set(fileKey, fileEntry);\r\n                }\r\n\r\n                for (const d of diags) {\r\n                    const rawCode = d.code;\r\n                    const code = typeof rawCode === 'string' || typeof rawCode === 'number'\r\n                        ? String(rawCode)\r\n                        : '';\r\n                    if (!code || !code.startsWith('ai-i18n.')) continue;\r\n\r\n                    const prevGlobal = codeTotals.get(code) || 0;\r\n                    codeTotals.set(code, prevGlobal + 1);\r\n\r\n                    fileEntry.count += 1;\r\n                    const prevFile = fileEntry.byCode.get(code) || 0;\r\n                    fileEntry.byCode.set(code, prevFile + 1);\r\n                }\r\n            }\r\n\r\n            if (!codeTotals.size || !fileTotals.size) {\r\n                vscode.window.showInformationMessage(\r\n                    'AI Localizer: No i18n diagnostics found for this workspace.',\r\n                );\r\n                return;\r\n            }\r\n\r\n            const labelForCode = (code: string): string => {\r\n                if (code === 'ai-i18n.untranslated') return 'Missing/untranslated';\r\n                if (code === 'ai-i18n.invalid') return 'Invalid/non-translatable default value';\r\n                if (code === 'ai-i18n.placeholders') return 'Placeholder mismatch';\r\n                if (code === 'ai-i18n.style') return 'Style suggestion';\r\n                return code;\r\n            };\r\n\r\n            const globalLines: string[] = [];\r\n            globalLines.push('# AI i18n – Workspace Health Report');\r\n            globalLines.push('');\r\n            globalLines.push(`Generated at ${new Date().toISOString()}`);\r\n            globalLines.push('');\r\n\r\n            globalLines.push('## Overall issue counts');\r\n            globalLines.push('');\r\n            globalLines.push('| Issue type | Count |');\r\n            globalLines.push('| --- | ---: |');\r\n            const sortedCodes = Array.from(codeTotals.entries()).sort((a, b) => b[1] - a[1]);\r\n            for (const [code, count] of sortedCodes) {\r\n                const label = labelForCode(code);\r\n                globalLines.push(`| ${label} | ${count} |`);\r\n            }\r\n            globalLines.push('');\r\n\r\n            const sortedFiles = Array.from(fileTotals.values()).sort((a, b) => b.count - a.count);\r\n            globalLines.push('## Files with i18n issues');\r\n            globalLines.push('');\r\n            globalLines.push('| File | Total | Missing/untranslated | Invalid | Placeholders | Style |');\r\n            globalLines.push('| --- | ---: | ---: | ---: | ---: | ---: |');\r\n            const maxFiles = 100;\r\n            for (let i = 0; i < sortedFiles.length && i < maxFiles; i += 1) {\r\n                const entry = sortedFiles[i];\r\n                const missing = entry.byCode.get('ai-i18n.untranslated') || 0;\r\n                const invalid = entry.byCode.get('ai-i18n.invalid') || 0;\r\n                const placeholders = entry.byCode.get('ai-i18n.placeholders') || 0;\r\n                const style = entry.byCode.get('ai-i18n.style') || 0;\r\n                const rel = vscode.workspace.asRelativePath(entry.uri);\r\n                globalLines.push(\r\n                    `| ${rel} | ${entry.count} | ${missing} | ${invalid} | ${placeholders} | ${style} |`,\r\n                );\r\n            }\r\n\r\n            if (sortedFiles.length > maxFiles) {\r\n                globalLines.push('');\r\n                globalLines.push(\r\n                    `Showing top ${maxFiles} file(s) by issue count out of ${sortedFiles.length} total.`,\r\n                );\r\n            }\r\n\r\n            const content = globalLines.join('\\n');\r\n            const doc = await vscode.workspace.openTextDocument({\r\n                language: 'markdown',\r\n                content,\r\n            } as any);\r\n            await vscode.window.showTextDocument(doc, { preview: false });\r\n        } catch (err) {\r\n            console.error('AI Localizer: Failed to generate workspace health report:', err);\r\n            vscode.window.showErrorMessage('AI Localizer: Failed to generate workspace health report.');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate auto-ignore patterns from constant-like values\r\n     */\r\n    async generateAutoIgnore(folderArg?: vscode.WorkspaceFolder): Promise<void> {\r\n        try {\r\n            let folder = folderArg;\r\n            if (!folder) {\r\n                const active = vscode.window.activeTextEditor;\r\n                folder = active\r\n                    ? vscode.workspace.getWorkspaceFolder(active.document.uri) ?? undefined\r\n                    : undefined;\r\n\r\n                if (!folder) {\r\n                    folder = await pickWorkspaceFolder();\r\n                }\r\n            }\r\n\r\n            if (!folder) {\r\n                vscode.window.showInformationMessage('AI Localizer: No workspace folder available.');\r\n                return;\r\n            }\r\n\r\n            await this.i18nIndex.ensureInitialized();\r\n\r\n            const allKeys = this.i18nIndex.getAllKeys();\r\n            if (!allKeys.length) {\r\n                vscode.window.showInformationMessage(\r\n                    'AI Localizer: No translation keys found to analyze for auto-ignore.',\r\n                );\r\n                return;\r\n            }\r\n\r\n            const candidates = new Set<string>();\r\n            const cfg = vscode.workspace.getConfiguration('ai-localizer');\r\n            const globalDefaultLocale = cfg.get<string>('i18n.defaultLocale') || 'en';\r\n\r\n            for (const key of allKeys) {\r\n                const record = this.i18nIndex.getRecord(key);\r\n                if (!record) continue;\r\n                const defaultLocale = record.defaultLocale || globalDefaultLocale;\r\n                const baseValue = record.locales.get(defaultLocale);\r\n                if (typeof baseValue !== 'string') continue;\r\n                const base = baseValue.trim();\r\n                if (!base) continue;\r\n\r\n                const normalized = base.replace(/\\s+/g, ' ');\r\n                const words = normalized.split(/\\s+/).filter(Boolean);\r\n                const wordCount = words.length;\r\n                const isTokenLike =\r\n                    wordCount <= 3 &&\r\n                    normalized.length <= 24 &&\r\n                    !/[.!?]/.test(normalized);\r\n\r\n                if (!isTokenLike) continue;\r\n\r\n                const nonDefaultLocales = Array.from(record.locales.keys()).filter(\r\n                    (l) => l !== defaultLocale,\r\n                );\r\n                if (!nonDefaultLocales.length) continue;\r\n\r\n                let sameCount = 0;\r\n                for (const locale of nonDefaultLocales) {\r\n                    const v = record.locales.get(locale);\r\n                    if (typeof v === 'string' && v.trim() === base) {\r\n                        sameCount += 1;\r\n                    }\r\n                }\r\n\r\n                const requiredSame = 1;\r\n                if (sameCount < requiredSame) continue;\r\n\r\n                candidates.add(normalized);\r\n            }\r\n\r\n            if (!candidates.size) {\r\n                vscode.window.showInformationMessage(\r\n                    'AI Localizer: No constant-like values found to add to auto-ignore.',\r\n                );\r\n                return;\r\n            }\r\n\r\n            const scriptsDir = vscode.Uri.joinPath(folder.uri, 'scripts');\r\n            const autoUri = vscode.Uri.joinPath(scriptsDir, '.i18n-auto-ignore.json');\r\n            let existing: any = {};\r\n            try {\r\n                const data = await vscode.workspace.fs.readFile(autoUri);\r\n                const raw = sharedDecoder.decode(data);\r\n                const parsed = JSON.parse(raw);\r\n                if (parsed && typeof parsed === 'object') {\r\n                    existing = parsed;\r\n                }\r\n            } catch {}\r\n\r\n            const existingExact = new Set<string>(\r\n                Array.isArray(existing.exact) ? existing.exact.map((v: any) => String(v)) : [],\r\n            );\r\n            const newValues: string[] = [];\r\n            for (const value of candidates) {\r\n                if (!existingExact.has(value)) {\r\n                    existingExact.add(value);\r\n                    newValues.push(value);\r\n                }\r\n            }\r\n\r\n            if (!newValues.length) {\r\n                vscode.window.showInformationMessage(\r\n                    'AI Localizer: No new auto-ignore patterns to add (all are already present).',\r\n                );\r\n                return;\r\n            }\r\n\r\n            const choice = await vscode.window.showQuickPick(\r\n                [\r\n                    {\r\n                        label: 'Apply',\r\n                        description: `Add ${newValues.length} auto-ignore pattern(s) to scripts/.i18n-auto-ignore.json`,\r\n                    },\r\n                    { label: 'Cancel', description: 'Do not change auto-ignore patterns' },\r\n                ],\r\n                { placeHolder: 'Generate AI i18n auto-ignore patterns from constant-like values?' },\r\n            );\r\n\r\n            if (!choice || choice.label !== 'Apply') {\r\n                return;\r\n            }\r\n\r\n            existing.exact = Array.from(existingExact).sort();\r\n            if (!Array.isArray(existing.exactInsensitive)) {\r\n                existing.exactInsensitive = [];\r\n            }\r\n            if (!Array.isArray(existing.contains)) {\r\n                existing.contains = [];\r\n            }\r\n\r\n            const payload = `${JSON.stringify(existing, null, 2)}\\n`;\r\n            await vscode.workspace.fs.createDirectory(scriptsDir);\r\n            await vscode.workspace.fs.writeFile(autoUri, sharedEncoder.encode(payload));\r\n\r\n            vscode.window.showInformationMessage(\r\n                `AI Localizer: Updated scripts/.i18n-auto-ignore.json with ${newValues.length} pattern(s).`,\r\n            );\r\n\r\n            await vscode.commands.executeCommand('ai-localizer.i18n.rescan');\r\n        } catch (err) {\r\n            console.error('AI Localizer: Failed to generate auto-ignore patterns:', err);\r\n            vscode.window.showErrorMessage('AI Localizer: Failed to generate auto-ignore patterns.');\r\n        }\r\n    }\r\n}\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\untranslated\\handlers\\styleHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\untranslated\\handlers\\translationHandler.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":373,"column":70,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":373,"endColumn":77},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":378,"column":85,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":378,"endColumn":92},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":901,"column":97,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":901,"endColumn":104},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":918,"column":82,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":918,"endColumn":89}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\nimport * as path from 'path';\nimport { I18nIndex } from '../../../core/i18nIndex';\nimport { inferJsonLocaleFromUri } from '../../../core/i18nPath';\nimport { TranslationService } from '../../../services/translationService';\nimport { setLaravelTranslationValue, setTranslationValuesBatch } from '../../../core/i18nFs';\nimport { getGranularSyncService } from '../../../services/granularSyncService';\nimport { pickWorkspaceFolder } from '../../../core/workspace';\nimport { operationLock, OperationType } from '../utils/operationLock';\n\nexport interface TranslationItem {\n    key: string;\n    defaultValue: string;\n    defaultLocale: string;\n}\n\nexport class TranslationHandler {\n    constructor(\n        private i18nIndex: I18nIndex,\n        private translationService: TranslationService,\n        private context?: vscode.ExtensionContext,\n    ) {}\n\n    /**\n     * Check if operation can proceed, showing warning if blocked\n     */\n    private async canProceed(operationType: OperationType, description: string): Promise<boolean> {\n        if (!operationLock.isOperationRunning()) {\n            return true;\n        }\n        const current = operationLock.getCurrentOperation();\n        if (current?.type === operationType) {\n            return true;\n        }\n        const blockingMsg = operationLock.getBlockingOperationMessage();\n        vscode.window.showWarningMessage(\n            `AI Localizer: Cannot start \"${description}\" - ${blockingMsg}. Please wait for it to complete.`\n        );\n        return false;\n    }\n\n    /**\n     * Get root name from a translation record\n     */\n    getRootNameForRecord(record: any): string {\n        if (!record || !Array.isArray(record.locations) || !record.locations.length) {\n            return 'common';\n        }\n        const defaultLocale = record.defaultLocale;\n        let location = record.locations.find((loc: any) => loc && loc.locale === defaultLocale);\n        if (!location) {\n            location = record.locations[0];\n        }\n        if (!location || !location.uri) {\n            return 'common';\n        }\n        const base = path.basename(location.uri.fsPath, '.json');\n        if (!base) {\n            return 'common';\n        }\n        return base.toLowerCase();\n    }\n\n    private isLaravelRecord(record: any): boolean {\n        if (!record || !Array.isArray(record.locations)) {\n            return false;\n        }\n        for (const loc of record.locations) {\n            const uri: vscode.Uri | undefined = loc && loc.uri;\n            if (!uri) {\n                continue;\n            }\n            const fsPath = uri.fsPath.replace(/\\\\/g, '/').toLowerCase();\n            if (fsPath.includes('/lang/') || fsPath.includes('/resources/lang/')) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private isLaravelLocaleFileUri(uri: vscode.Uri): boolean {\n        const fsPath = uri.fsPath.replace(/\\\\/g, '/').toLowerCase();\n        if (!fsPath.endsWith('.php')) {\n            return false;\n        }\n        return fsPath.includes('/lang/') || fsPath.includes('/resources/lang/');\n    }\n\n    /**\n     * Apply quick fix for untranslated key\n     */\n    async applyQuickFix(\n        documentUri: vscode.Uri,\n        key: string,\n        locales: string[],\n    ): Promise<void> {\n        let folder = vscode.workspace.getWorkspaceFolder(documentUri) ?? undefined;\n        if (!folder) {\n            folder = await pickWorkspaceFolder();\n        }\n        if (!folder) {\n            vscode.window.showInformationMessage('AI Localizer: No workspace folder available.');\n            return;\n        }\n\n        const syncService = getGranularSyncService(this.context);\n        await syncService.syncKeys(folder, [key]);\n\n        await this.i18nIndex.ensureInitialized();\n        const record = this.i18nIndex.getRecord(key);\n        if (!record) {\n            vscode.window.showInformationMessage(\n                `AI Localizer: No translation record found for key ${key}.`,\n            );\n            return;\n        }\n\n        const defaultLocale = record.defaultLocale;\n        const defaultValue = record.locales.get(defaultLocale);\n        if (typeof defaultValue !== 'string' || !defaultValue.trim()) {\n            vscode.window.showInformationMessage(\n                `AI Localizer: Default locale value not found for key ${key}.`,\n            );\n            return;\n        }\n\n        const targetLocales = locales.filter((l) => l && l !== defaultLocale);\n        if (!targetLocales.length) {\n            vscode.window.showInformationMessage(\n                'AI Localizer: No target locales to translate for this key.',\n            );\n            return;\n        }\n\n        const rootName = this.getRootNameForRecord(record);\n        const isLaravel = this.isLaravelRecord(record);\n\n        // Sync missing keys with placeholder values for JSON-based locales only\n        const placeholderUpdates = new Map<string, Map<string, { value: string; rootName?: string }>>();\n        if (!isLaravel) {\n            for (const locale of targetLocales) {\n                const current = record.locales.get(locale);\n                if (typeof current !== 'string' || !current.trim()) {\n                    let localeUpdates = placeholderUpdates.get(locale);\n                    if (!localeUpdates) {\n                        localeUpdates = new Map();\n                        placeholderUpdates.set(locale, localeUpdates);\n                    }\n                    localeUpdates.set(key, { value: defaultValue, rootName });\n                }\n            }\n\n            for (const [locale, updates] of placeholderUpdates.entries()) {\n                await setTranslationValuesBatch(folder, locale, updates);\n            }\n        }\n\n        const translations = await this.translationService.translateToLocales(\n            defaultValue,\n            defaultLocale,\n            targetLocales,\n            'text',\n            true,\n        );\n\n        if (!translations || translations.size === 0) {\n            const choice = await vscode.window.showInformationMessage(\n                'AI Localizer: No translations were generated for this quick fix (check API key and settings).',\n                'Open OpenAI API Key Settings',\n                'Dismiss',\n            );\n            if (choice === 'Open OpenAI API Key Settings') {\n                await vscode.commands.executeCommand('ai-localizer.setOpenAiApiKeySecret');\n            }\n            return;\n        }\n\n        // Write AI translations\n        if (isLaravel) {\n            for (const [locale, newValue] of translations.entries()) {\n                await setLaravelTranslationValue(folder, locale, key, newValue);\n            }\n        } else {\n            const translationUpdates = new Map<string, Map<string, { value: string; rootName?: string }>>();\n            for (const [locale, newValue] of translations.entries()) {\n                let localeUpdates = translationUpdates.get(locale);\n                if (!localeUpdates) {\n                    localeUpdates = new Map();\n                    translationUpdates.set(locale, localeUpdates);\n                }\n                localeUpdates.set(key, { value: newValue, rootName });\n            }\n\n            for (const [locale, updates] of translationUpdates.entries()) {\n                await setTranslationValuesBatch(folder, locale, updates);\n            }\n        }\n\n        vscode.window.showInformationMessage(\n            `AI Localizer: Applied AI translations for ${key} in ${translations.size} locale(s).`,\n        );\n    }\n\n    /**\n     * Translate all untranslated keys in a locale file\n     */\n    async translateAllUntranslatedInFile(\n        documentUri: vscode.Uri,\n        pruneReportsCallback: (folder: vscode.WorkspaceFolder, fixed: Array<{ locale: string; keyPath: string }>) => Promise<void>,\n    ): Promise<void> {\n        const targetUri = documentUri || vscode.window.activeTextEditor?.document.uri;\n        if (!targetUri) {\n            vscode.window.showInformationMessage(\n                'AI Localizer: No active document to translate.',\n            );\n            return;\n        }\n\n        // Check if another operation is blocking\n        if (!(await this.canProceed('translation-file', 'Translate All in File'))) {\n            return;\n        }\n\n        const doc = await vscode.workspace.openTextDocument(targetUri);\n        const isJsonFile = doc.languageId === 'json' || doc.languageId === 'jsonc';\n        const isLaravelLocaleFile = this.isLaravelLocaleFileUri(targetUri);\n        if (!isJsonFile && !isLaravelLocaleFile) {\n            vscode.window.showInformationMessage(\n                'AI Localizer: Bulk translate only applies to locale JSON or Laravel lang files.',\n            );\n            return;\n        }\n\n        let folder = vscode.workspace.getWorkspaceFolder(targetUri) ?? undefined;\n        if (!folder) {\n            folder = await pickWorkspaceFolder();\n        }\n        if (!folder) {\n            vscode.window.showInformationMessage('AI Localizer: No workspace folder available.');\n            return;\n        }\n\n        const syncService = getGranularSyncService(this.context);\n        await syncService.syncFile(folder, targetUri);\n\n        await this.i18nIndex.ensureInitialized();\n\n        const fileInfo = this.i18nIndex.getKeysForFile(targetUri);\n        const cfg = vscode.workspace.getConfiguration('ai-localizer');\n        const globalDefaultLocale = cfg.get<string>('i18n.defaultLocale') || 'en';\n\n        const fileLocale: string | null = fileInfo?.locale || inferJsonLocaleFromUri(targetUri);\n\n        if (!fileLocale) {\n            vscode.window.showInformationMessage(\n                'AI Localizer: Could not determine locale for this file.',\n            );\n            return;\n        }\n\n        if (fileLocale === globalDefaultLocale) {\n            await this.translateMissingLocalesFromDefaultFile(\n                folder,\n                targetUri,\n                fileInfo,\n                globalDefaultLocale,\n                pruneReportsCallback,\n            );\n            return;\n        }\n\n        const targetLocale: string = fileLocale;\n        const keysToTranslate: TranslationItem[] = [];\n        const keysInFile = fileInfo?.keys || [];\n\n        for (const key of keysInFile) {\n            const record = this.i18nIndex.getRecord(key);\n            if (!record) continue;\n\n            const defaultLocale = record.defaultLocale || globalDefaultLocale;\n            if (targetLocale === defaultLocale) continue;\n\n            const defaultValue = record.locales.get(defaultLocale);\n            if (typeof defaultValue !== 'string' || !defaultValue.trim()) continue;\n\n            const currentValue = record.locales.get(targetLocale);\n            const needsTranslation =\n                !currentValue ||\n                !currentValue.trim() ||\n                currentValue.trim() === defaultValue.trim();\n\n            if (needsTranslation) {\n                keysToTranslate.push({ key, defaultValue, defaultLocale });\n            }\n        }\n\n        if (!keysToTranslate.length) {\n            vscode.window.showInformationMessage(\n                `AI Localizer: No untranslated keys found for locale ${targetLocale}.`,\n            );\n            return;\n        }\n\n        const choice = await vscode.window.showQuickPick(\n            [\n                {\n                    label: `Translate ${keysToTranslate.length} key(s)`,\n                    description: `Use AI to translate ${keysToTranslate.length} untranslated key(s) to ${targetLocale}`,\n                },\n                { label: 'Cancel', description: 'Do not translate' },\n            ],\n            {\n                placeHolder: `AI Localizer: Translate ${keysToTranslate.length} untranslated key(s) in this file?`,\n            },\n        );\n        if (!choice || choice.label === 'Cancel') {\n            return;\n        }\n\n        // Acquire lock for file translation\n        const result = await operationLock.withGlobalLock(\n            'translation-file',\n            `Translating ${vscode.workspace.asRelativePath(targetUri)}`,\n            async () => {\n                let translatedCount = 0;\n                const fixed: { locale: string; keyPath: string }[] = [];\n                const relPath = vscode.workspace.asRelativePath(targetUri);\n                const progressTitle = `AI Localizer: Translating ${targetLocale} (${relPath})...`;\n\n                await vscode.window.withProgress(\n                    {\n                        location: vscode.ProgressLocation.Notification,\n                        title: progressTitle,\n                        cancellable: true,\n                    },\n                    async (progress, token) => {\n                        if (token.isCancellationRequested) return;\n\n                        const batchItems = keysToTranslate.map((item) => ({\n                            id: item.key,\n                            text: item.defaultValue,\n                            defaultLocale: item.defaultLocale,\n                        }));\n\n                        const translations = await this.translationService.translateBatchToLocale(\n                            batchItems,\n                            targetLocale,\n                            'text',\n                            true,\n                        );\n\n                        if (!translations || translations.size === 0 || token.isCancellationRequested) {\n                            return;\n                        }\n\n                        const batchUpdates = new Map<string, { value: string; rootName?: string }>();\n                        for (const item of keysToTranslate) {\n                            if (token.isCancellationRequested) break;\n                            const newValue = translations.get(item.key);\n                            if (!newValue) continue;\n                            const record = this.i18nIndex.getRecord(item.key);\n                            const rootName = record ? this.getRootNameForRecord(record) : 'common';\n                            batchUpdates.set(item.key, { value: newValue, rootName });\n                        }\n\n                        if (batchUpdates.size > 0 && !token.isCancellationRequested) {\n                            progress.report({\n                                message: `Writing ${batchUpdates.size} translation(s) to ${targetLocale}...`,\n                            });\n\n                            if (isLaravelLocaleFile) {\n                                for (const [fullKey, { value }] of batchUpdates.entries()) {\n                                    await setLaravelTranslationValue(folder!, targetLocale, fullKey, value);\n                                    translatedCount += 1;\n                                    fixed.push({ locale: targetLocale, keyPath: fullKey });\n                                }\n                            } else {\n                                const writeResult = await setTranslationValuesBatch(folder!, targetLocale, batchUpdates);\n                                translatedCount = writeResult.written;\n\n                                for (const [key] of batchUpdates.entries()) {\n                                    fixed.push({ locale: targetLocale, keyPath: key });\n                                }\n\n                                if (writeResult.errors.length > 0) {\n                                    console.error('AI Localizer: Some translations failed to write:', writeResult.errors);\n                                }\n                            }\n                        }\n                    },\n                );\n\n                return { fixed, translatedCount };\n            }\n        );\n\n        if (!result) {\n            return;\n        }\n\n        const { fixed, translatedCount } = result;\n\n        if (fixed.length > 0) {\n            await pruneReportsCallback(folder, fixed);\n        }\n\n        if (translatedCount > 0) {\n            vscode.window.showInformationMessage(\n                `AI Localizer: Translated ${translatedCount} key(s) in ${targetLocale}.`,\n            );\n\n            // Rescan to refresh index and diagnostics after bulk translation\n            try {\n                await vscode.commands.executeCommand('ai-localizer.i18n.rescan');\n            } catch {\n                // Ignore rescan failures; translations are already written\n            }\n        } else {\n            const apiChoice = await vscode.window.showInformationMessage(\n                'AI Localizer: No translations were generated (check API key and settings).',\n                'Open OpenAI API Key Settings',\n                'Dismiss',\n            );\n            if (apiChoice === 'Open OpenAI API Key Settings') {\n                await vscode.commands.executeCommand('ai-localizer.setOpenAiApiKeySecret');\n            }\n        }\n    }\n\n    /**\n     * Translate missing locales from default file\n     */\n    private async translateMissingLocalesFromDefaultFile(\n        folder: vscode.WorkspaceFolder,\n        documentUri: vscode.Uri,\n        fileInfo: { locale: string; keys: string[] } | null,\n        globalDefaultLocale: string,\n        pruneReportsCallback: (folder: vscode.WorkspaceFolder, fixed: Array<{ locale: string; keyPath: string }>) => Promise<void>,\n    ): Promise<void> {\n        const isLaravelDefaultFile = this.isLaravelLocaleFileUri(documentUri);\n        const keysInFile = fileInfo?.keys || [];\n        if (!keysInFile.length) {\n            vscode.window.showInformationMessage(\n                'AI Localizer: No translation keys found in this file.',\n            );\n            return;\n        }\n\n        const missingPerLocale = new Map<string, TranslationItem[]>();\n\n        // Primary source of truth: current untranslated diagnostics for this file\n        const fileDiagnostics = vscode.languages.getDiagnostics(documentUri);\n        if (fileDiagnostics && fileDiagnostics.length) {\n            try {\n                const { parseUntranslatedDiagnostic } = await import('../utils/diagnosticParser');\n\n                for (const d of fileDiagnostics) {\n                    if (String(d.code) !== 'ai-i18n.untranslated') continue;\n\n                    const parsed = parseUntranslatedDiagnostic(String(d.message || ''));\n                    if (!parsed || !parsed.key || !parsed.locales || !parsed.locales.length) continue;\n\n                    const key = parsed.key;\n                    if (!keysInFile.includes(key)) continue;\n\n                    const record = this.i18nIndex.getRecord(key);\n                    if (!record) continue;\n\n                    const defaultLocale = record.defaultLocale || globalDefaultLocale;\n                    const defaultValue = record.locales.get(defaultLocale);\n                    if (typeof defaultValue !== 'string' || !defaultValue.trim()) continue;\n\n                    for (const locale of parsed.locales) {\n                        if (!locale || locale === defaultLocale) continue;\n\n                        let list = missingPerLocale.get(locale);\n                        if (!list) {\n                            list = [];\n                            missingPerLocale.set(locale, list);\n                        }\n                        list.push({ key, defaultValue, defaultLocale });\n                    }\n                }\n            } catch {\n                // If diagnostic parsing fails for any reason, fall back to index-based detection below\n            }\n        }\n\n        // Fallback when no untranslated diagnostics were found: infer missing locales from index\n        if (!missingPerLocale.size) {\n            const allLocales = this.i18nIndex.getAllLocales();\n\n            for (const key of keysInFile) {\n                const record = this.i18nIndex.getRecord(key);\n                if (!record) continue;\n\n                const defaultLocale = record.defaultLocale || globalDefaultLocale;\n                const defaultValue = record.locales.get(defaultLocale);\n                if (typeof defaultValue !== 'string' || !defaultValue.trim()) continue;\n                const trimmedDefault = defaultValue.trim();\n\n                for (const locale of allLocales) {\n                    if (!locale || locale === defaultLocale) continue;\n                    const currentValue = record.locales.get(locale);\n                    const current = typeof currentValue === 'string' ? currentValue.trim() : '';\n                    const needsTranslation = !current || current === trimmedDefault;\n                    if (!needsTranslation) continue;\n\n                    let list = missingPerLocale.get(locale);\n                    if (!list) {\n                        list = [];\n                        missingPerLocale.set(locale, list);\n                    }\n                    list.push({ key, defaultValue, defaultLocale });\n                }\n            }\n        }\n\n        if (!missingPerLocale.size) {\n            vscode.window.showInformationMessage(\n                'AI Localizer: No untranslated keys found for non-default locales in this file.',\n            );\n            return;\n        }\n\n        const localeEntries = Array.from(missingPerLocale.entries());\n        let selectedLocales: string[];\n        let translateAll = false;\n\n        if (localeEntries.length === 1) {\n            selectedLocales = [localeEntries[0][0]];\n        } else {\n            const totalKeys = localeEntries.reduce((sum, [, list]) => sum + list.length, 0);\n            const items: Array<vscode.QuickPickItem & { locale?: string; isAll?: boolean }> = [\n                {\n                    label: `$(globe) All locales (${localeEntries.length} locales, ${totalKeys} keys)`,\n                    description: `Translate all missing keys for all ${localeEntries.length} locales at once`,\n                    isAll: true,\n                },\n                { label: '---', kind: vscode.QuickPickItemKind.Separator },\n                ...localeEntries.map(([locale, list]) => {\n                    const count = list.length;\n                    return {\n                        label: `${locale} (${count} key${count === 1 ? '' : 's'})`,\n                        description: undefined,\n                        locale,\n                    };\n                }),\n            ];\n\n            const choice = await vscode.window.showQuickPick(items, {\n                placeHolder:\n                    'AI Localizer: Select target locale(s) to translate missing keys for this file',\n            });\n            if (!choice) return;\n\n            if ((choice as any).isAll) {\n                translateAll = true;\n                selectedLocales = localeEntries.map(([locale]) => locale);\n            } else {\n                const selectedLocale = (choice as any).locale;\n                if (!selectedLocale) return;\n                selectedLocales = [selectedLocale];\n            }\n        }\n\n        const totalKeysToTranslate = translateAll\n            ? localeEntries.reduce((sum, [, list]) => sum + list.length, 0)\n            : missingPerLocale.get(selectedLocales[0])?.length || 0;\n\n        const confirmLabel = translateAll\n            ? `Translate all ${totalKeysToTranslate} key(s) to ${selectedLocales.length} locale(s)`\n            : `Translate ${totalKeysToTranslate} key(s) to ${selectedLocales[0]}`;\n\n        const confirm = await vscode.window.showQuickPick(\n            [\n                {\n                    label: confirmLabel,\n                    description: translateAll\n                        ? `Use AI to translate missing keys for all ${selectedLocales.length} locales`\n                        : `Use AI to translate ${totalKeysToTranslate} untranslated key(s) to ${selectedLocales[0]}`,\n                },\n                { label: 'Cancel', description: 'Do not translate' },\n            ],\n            { placeHolder: `AI Localizer: ${confirmLabel}?` },\n        );\n        if (!confirm || confirm.label === 'Cancel') return;\n\n        // Acquire lock for bulk translation\n        const result = await operationLock.withGlobalLock(\n            'translation-file',\n            `Translating from ${vscode.workspace.asRelativePath(documentUri)}`,\n            async () => {\n                const relPath = vscode.workspace.asRelativePath(documentUri);\n                let totalTranslatedCount = 0;\n                const fixed: { locale: string; keyPath: string }[] = [];\n\n                await vscode.window.withProgress(\n                    {\n                        location: vscode.ProgressLocation.Notification,\n                        title: translateAll\n                            ? `AI Localizer: Translating ${selectedLocales.length} locale(s) (${relPath})...`\n                            : `AI Localizer: Translating ${selectedLocales[0]} (${relPath})...`,\n                        cancellable: true,\n                    },\n                    async (progress, token) => {\n                        for (let i = 0; i < selectedLocales.length; i++) {\n                            if (token.isCancellationRequested) break;\n\n                            const selectedLocale = selectedLocales[i];\n                            const keysToTranslate = missingPerLocale.get(selectedLocale) || [];\n                            if (!keysToTranslate.length) continue;\n\n                            progress.report({\n                                message: `Translating ${selectedLocale} (${i + 1}/${selectedLocales.length}): ${keysToTranslate.length} key(s)...`,\n                                increment: (100 / selectedLocales.length) * (i === 0 ? 0 : 1),\n                            });\n\n                            const batchItems = keysToTranslate.map((item) => ({\n                                id: item.key,\n                                text: item.defaultValue,\n                                defaultLocale: item.defaultLocale,\n                            }));\n\n                            const translations = await this.translationService.translateBatchToLocale(\n                                batchItems,\n                                selectedLocale,\n                                'text',\n                                true,\n                            );\n\n                            if (!translations || translations.size === 0 || token.isCancellationRequested) {\n                                continue;\n                            }\n\n                            const batchUpdates = new Map<string, { value: string; rootName?: string }>();\n                            for (const item of keysToTranslate) {\n                                if (token.isCancellationRequested) break;\n                                const newValue = translations.get(item.key);\n                                if (!newValue) continue;\n                                const record = this.i18nIndex.getRecord(item.key);\n                                const rootName = record ? this.getRootNameForRecord(record) : 'common';\n                                batchUpdates.set(item.key, { value: newValue, rootName });\n                            }\n\n                            if (batchUpdates.size > 0 && !token.isCancellationRequested) {\n                                progress.report({\n                                    message: `Writing ${batchUpdates.size} translation(s) to ${selectedLocale}...`,\n                                    increment: (100 / selectedLocales.length) * 0.5,\n                                });\n\n                                if (isLaravelDefaultFile) {\n                                    for (const [fullKey, { value }] of batchUpdates.entries()) {\n                                        await setLaravelTranslationValue(folder, selectedLocale, fullKey, value);\n                                        totalTranslatedCount += 1;\n                                        fixed.push({ locale: selectedLocale, keyPath: fullKey });\n                                    }\n                                } else {\n                                    const writeResult = await setTranslationValuesBatch(folder, selectedLocale, batchUpdates);\n                                    totalTranslatedCount += writeResult.written;\n\n                                    for (const [key] of batchUpdates.entries()) {\n                                        fixed.push({ locale: selectedLocale, keyPath: key });\n                                    }\n\n                                    if (writeResult.errors.length > 0) {\n                                        console.error(\n                                            `AI Localizer: Some translations failed to write for ${selectedLocale}:`,\n                                            writeResult.errors,\n                                        );\n                                    }\n                                }\n                            }\n\n                            progress.report({ increment: (100 / selectedLocales.length) * 0.5 });\n                        }\n                    },\n                );\n\n                return { fixed, totalTranslatedCount, selectedLocales, translateAll };\n            }\n        );\n\n        if (!result) {\n            return;\n        }\n\n        const { fixed, totalTranslatedCount, selectedLocales: selLocales, translateAll: transAll } = result;\n\n        if (fixed.length > 0) {\n            await pruneReportsCallback(folder, fixed);\n        }\n\n        if (totalTranslatedCount > 0) {\n            const localeSummary = transAll\n                ? `${totalTranslatedCount} key(s) across ${selLocales.length} locale(s)`\n                : `${totalTranslatedCount} key(s) in ${selLocales[0]}`;\n            vscode.window.showInformationMessage(`AI Localizer: Translated ${localeSummary}.`);\n\n            // Rescan to refresh index and diagnostics after bulk translation from default file\n            try {\n                await vscode.commands.executeCommand('ai-localizer.i18n.rescan');\n            } catch {\n                // Ignore rescan failures; translations are already written\n            }\n        } else {\n            const apiChoice = await vscode.window.showInformationMessage(\n                'AI Localizer: No translations were generated (check API key and settings).',\n                'Open OpenAI API Key Settings',\n                'Dismiss',\n            );\n            if (apiChoice === 'Open OpenAI API Key Settings') {\n                await vscode.commands.executeCommand('ai-localizer.setOpenAiApiKeySecret');\n            }\n        }\n    }\n\n    /**\n     * Translate all untranslated keys in the entire project\n     */\n    async translateAllUntranslatedInProject(\n        pruneReportsCallback: (folder: vscode.WorkspaceFolder, fixed: Array<{ locale: string; keyPath: string }>) => Promise<void>,\n        generateAutoIgnoreCallback: (folder: vscode.WorkspaceFolder) => Promise<void>,\n    ): Promise<void> {\n        const folders = vscode.workspace.workspaceFolders || [];\n        if (!folders.length) {\n            vscode.window.showInformationMessage('AI Localizer: No workspace folder available.');\n            return;\n        }\n\n        // Check if another operation is blocking\n        if (!(await this.canProceed('translation-project', 'Fix All i18n Issues in Project'))) {\n            return;\n        }\n\n        let folder: vscode.WorkspaceFolder | undefined;\n        if (folders.length === 1) {\n            folder = folders[0];\n        } else {\n            folder = await pickWorkspaceFolder();\n        }\n\n        if (!folder) {\n            vscode.window.showInformationMessage('AI Localizer: No workspace folder available.');\n            return;\n        }\n\n        await vscode.commands.executeCommand('ai-localizer.i18n.runSyncScript');\n        await this.i18nIndex.ensureInitialized();\n\n        const cfg = vscode.workspace.getConfiguration('ai-localizer');\n        const globalDefaultLocale = cfg.get<string>('i18n.defaultLocale') || 'en';\n\n        const allKeys = this.i18nIndex.getAllKeys();\n        if (!allKeys.length) {\n            vscode.window.showInformationMessage(\n                'AI Localizer: No translation keys found to translate.',\n            );\n            return;\n        }\n\n        const allLocales = this.i18nIndex.getAllLocales();\n        if (!allLocales.length) {\n            vscode.window.showInformationMessage(\n                'AI Localizer: No locales detected in this workspace.',\n            );\n            return;\n        }\n\n        const missingPerLocale = new Map<string, TranslationItem[]>();\n        const sampleFileByLocale = new Map<string, vscode.Uri>();\n\n        for (const key of allKeys) {\n            const record = this.i18nIndex.getRecord(key);\n            if (!record) continue;\n\n            const defaultLocale = record.defaultLocale || globalDefaultLocale;\n            const defaultValue = record.locales.get(defaultLocale);\n            if (typeof defaultValue !== 'string' || !defaultValue.trim()) continue;\n            const base = defaultValue.trim();\n\n            for (const locale of allLocales) {\n                if (!locale || locale === defaultLocale) continue;\n                const currentValue = record.locales.get(locale);\n                const current = typeof currentValue === 'string' ? currentValue.trim() : '';\n                const needsTranslation = !current || current === base;\n                if (!needsTranslation) continue;\n\n                if (!sampleFileByLocale.has(locale) && record.locations && record.locations.length) {\n                    const locEntry = record.locations.find((l) => l.locale === locale) || record.locations[0];\n                    if (locEntry) {\n                        sampleFileByLocale.set(locale, locEntry.uri);\n                    }\n                }\n\n                let list = missingPerLocale.get(locale);\n                if (!list) {\n                    list = [];\n                    missingPerLocale.set(locale, list);\n                }\n                list.push({ key, defaultValue, defaultLocale });\n            }\n        }\n\n        if (!missingPerLocale.size) {\n            vscode.window.showInformationMessage(\n                'AI Localizer: No untranslated keys found for non-default locales in this workspace.',\n            );\n            return;\n        }\n\n        let totalKeys = 0;\n        for (const list of missingPerLocale.values()) {\n            totalKeys += list.length;\n        }\n\n        const confirm = await vscode.window.showQuickPick(\n            [\n                {\n                    label: `Translate ${totalKeys} key(s)`,\n                    description: `Use AI to translate ${totalKeys} untranslated key(s) across ${missingPerLocale.size} locale(s)`,\n                },\n                { label: 'Cancel', description: 'Do not translate' },\n            ],\n            {\n                placeHolder: `AI Localizer: Translate ${totalKeys} untranslated key(s) across all locales in this workspace?`,\n            },\n        );\n\n        if (!confirm || confirm.label === 'Cancel') return;\n\n        // Acquire global lock for the entire project translation operation\n        const result = await operationLock.withGlobalLock(\n            'translation-project',\n            'Fix All i18n Issues in Project',\n            async () => {\n                const localeEntries = Array.from(missingPerLocale.entries());\n                const maxConcurrent = 4;\n                let completedLocales = 0;\n                let translatedTotal = 0;\n                const fixed: { locale: string; keyPath: string }[] = [];\n\n                await vscode.window.withProgress(\n                    {\n                        location: vscode.ProgressLocation.Notification,\n                        title: 'AI Localizer: Translating all locales...',\n                        cancellable: true,\n                    },\n                    async (progress, token) => {\n                        if (token.isCancellationRequested) return;\n\n                        let index = 0;\n                        let lastReported = 0;\n\n                        const worker = async () => {\n                            while (true) {\n                                const current = index;\n                                index += 1;\n                                if (current >= localeEntries.length || token.isCancellationRequested) {\n                                    break;\n                                }\n\n                                const [locale, items] = localeEntries[current];\n\n                                try {\n                                    const batchItems = items.map((item) => ({\n                                        id: item.key,\n                                        text: item.defaultValue,\n                                        defaultLocale: item.defaultLocale,\n                                    }));\n\n                                    const translations = await this.translationService.translateBatchToLocale(\n                                        batchItems,\n                                        locale,\n                                        'text',\n                                        true,\n                                    );\n\n                                    if (!translations || translations.size === 0 || token.isCancellationRequested) {\n                                        continue;\n                                    }\n\n                                    const jsonBatchUpdates = new Map<string, { value: string; rootName?: string }>();\n                                    const laravelUpdates = new Map<string, string>();\n                                    for (const item of items) {\n                                        if (token.isCancellationRequested) break;\n                                        const newValue = translations.get(item.key);\n                                        if (!newValue) continue;\n                                        const record = this.i18nIndex.getRecord(item.key);\n                                        const isLaravel = record && this.isLaravelRecord(record);\n                                        if (isLaravel) {\n                                            laravelUpdates.set(item.key, newValue);\n                                        } else {\n                                            const rootName = record ? this.getRootNameForRecord(record) : 'common';\n                                            jsonBatchUpdates.set(item.key, { value: newValue, rootName });\n                                        }\n                                    }\n\n                                    if (!token.isCancellationRequested) {\n                                        if (jsonBatchUpdates.size > 0) {\n                                            const writeResult = await setTranslationValuesBatch(folder!, locale, jsonBatchUpdates);\n                                            translatedTotal += writeResult.written;\n\n                                            for (const [key] of jsonBatchUpdates.entries()) {\n                                                fixed.push({ locale, keyPath: key });\n                                            }\n\n                                            if (writeResult.errors.length > 0) {\n                                                console.error(\n                                                    `AI Localizer: Some translations failed to write for ${locale}:`,\n                                                    writeResult.errors,\n                                                );\n                                            }\n                                        }\n\n                                        if (laravelUpdates.size > 0) {\n                                            for (const [fullKey, value] of laravelUpdates.entries()) {\n                                                await setLaravelTranslationValue(folder!, locale, fullKey, value);\n                                                translatedTotal += 1;\n                                                fixed.push({ locale, keyPath: fullKey });\n                                            }\n                                        }\n                                    }\n                                } catch (err) {\n                                    console.error(`AI Localizer: Failed to translate keys for locale ${locale}:`, err);\n                                } finally {\n                                    completedLocales += 1;\n                                    const percent = (completedLocales / localeEntries.length) * 100;\n                                    const sampleUri = sampleFileByLocale.get(locale);\n                                    const fileLabel = sampleUri\n                                        ? vscode.workspace.asRelativePath(sampleUri, false)\n                                        : undefined;\n                                    const baseMsg = `${completedLocales} of ${localeEntries.length} locale(s)`;\n                                    const message = fileLabel\n                                        ? `${baseMsg} — ${locale} (${fileLabel})`\n                                        : `${baseMsg} — ${locale}`;\n                                    progress.report({\n                                        message,\n                                        increment: percent - lastReported,\n                                    });\n                                    lastReported = percent;\n                                }\n                            }\n                        };\n\n                        const workers: Promise<void>[] = [];\n                        const workerCount = Math.min(maxConcurrent, localeEntries.length);\n                        for (let i = 0; i < workerCount; i += 1) {\n                            workers.push(worker());\n                        }\n                        await Promise.all(workers);\n                    },\n                );\n\n                return { fixed, translatedTotal };\n            },\n        );\n\n        if (!result) {\n            return;\n        }\n\n        const { fixed, translatedTotal } = result;\n\n        if (fixed.length > 0) {\n            await pruneReportsCallback(folder, fixed);\n        }\n\n        if (translatedTotal > 0) {\n            vscode.window.showInformationMessage(\n                `AI Localizer: Translated ${translatedTotal} key(s) across ${missingPerLocale.size} locale(s).`,\n            );\n            await generateAutoIgnoreCallback(folder);\n\n            // Rescan once after project-wide bulk translation completes\n            try {\n                await vscode.commands.executeCommand('ai-localizer.i18n.rescan');\n            } catch {\n                // Ignore rescan failures; translations are already written\n            }\n        } else {\n            const apiChoice = await vscode.window.showInformationMessage(\n                'AI Localizer: No translations were generated (check API key and settings).',\n                'Open OpenAI API Key Settings',\n                'Dismiss',\n            );\n            if (apiChoice === 'Open OpenAI API Key Settings') {\n                await vscode.commands.executeCommand('ai-localizer.setOpenAiApiKeySecret');\n            }\n        }\n    }\n\n    /**\n     * Fix placeholder mismatch by re-translating the value\n     */\n    async fixPlaceholderMismatch(documentUri: vscode.Uri, key: string, locale: string): Promise<void> {\n        let folder = vscode.workspace.getWorkspaceFolder(documentUri) ?? undefined;\n        if (!folder) {\n            folder = await pickWorkspaceFolder();\n        }\n        if (!folder) {\n            vscode.window.showInformationMessage('AI Localizer: No workspace folder available.');\n            return;\n        }\n\n        await this.i18nIndex.ensureInitialized();\n        const record = this.i18nIndex.getRecord(key);\n        if (!record) {\n            vscode.window.showInformationMessage(\n                `AI Localizer: No translation record found for key ${key}.`,\n            );\n            return;\n        }\n\n        const defaultLocale = record.defaultLocale;\n        const defaultValue = record.locales.get(defaultLocale);\n        if (typeof defaultValue !== 'string' || !defaultValue.trim()) {\n            vscode.window.showInformationMessage(\n                `AI Localizer: Default locale value not found for key ${key}.`,\n            );\n            return;\n        }\n\n        const translations = await this.translationService.translateToLocales(\n            defaultValue,\n            defaultLocale,\n            [locale],\n            'text',\n            true,\n        );\n\n        if (!translations || translations.size === 0) {\n            const choice = await vscode.window.showInformationMessage(\n                'AI Localizer: No translation generated (check API key and settings).',\n                'Open OpenAI API Key Settings',\n                'Dismiss',\n            );\n            if (choice === 'Open OpenAI API Key Settings') {\n                await vscode.commands.executeCommand('ai-localizer.setOpenAiApiKeySecret');\n            }\n            return;\n        }\n\n        const newValue = translations.get(locale);\n        if (newValue) {\n            const { setTranslationValue } = await import('../../../core/i18nFs');\n            const rootName = this.getRootNameForRecord(record);\n            await setTranslationValue(folder, locale, key, newValue, { rootName });\n\n            vscode.window.showInformationMessage(\n                `AI Localizer: Fixed placeholder mismatch for ${key} in ${locale}.`,\n            );\n        }\n    }\n}\n\n\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\untranslated\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'documentUri' is defined but never used. Allowed unused args must match /^_/u.","line":92,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":92,"endColumn":51}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\r\nimport { I18nIndex } from '../../core/i18nIndex';\r\nimport { TranslationService } from '../../services/translationService';\r\nimport { ProjectConfigService } from '../../services/projectConfigService';\r\n\r\nimport {\r\n    GitRecoveryHandler,\r\n    TranslationHandler,\r\n    KeyManagementHandler,\r\n    CleanupHandler,\r\n    StyleHandler,\r\n    ReportHandler,\r\n} from './handlers';\r\n\r\n/**\r\n * Commands for handling untranslated strings\r\n * This is a facade class that delegates to specialized handlers\r\n */\r\nexport class UntranslatedCommands {\r\n    private gitRecoveryHandler: GitRecoveryHandler;\r\n    private translationHandler: TranslationHandler;\r\n    private keyManagementHandler: KeyManagementHandler;\r\n    private cleanupHandler: CleanupHandler;\r\n    private styleHandler: StyleHandler;\r\n    private reportHandler: ReportHandler;\r\n\r\n    constructor(\r\n        private i18nIndex: I18nIndex,\r\n        private translationService: TranslationService,\r\n        private projectConfigService: ProjectConfigService,\r\n        private context?: vscode.ExtensionContext,\r\n        private log?: vscode.OutputChannel,\r\n    ) {\r\n        // Initialize handlers\r\n        this.gitRecoveryHandler = new GitRecoveryHandler(context, log);\r\n        \r\n        this.translationHandler = new TranslationHandler(\r\n            i18nIndex,\r\n            translationService,\r\n            context,\r\n        );\r\n        \r\n        this.keyManagementHandler = new KeyManagementHandler(\r\n            i18nIndex,\r\n            this.gitRecoveryHandler,\r\n            translationService,\r\n            context,\r\n            log,\r\n        );\r\n        \r\n        this.cleanupHandler = new CleanupHandler(\r\n            i18nIndex,\r\n            (keyPath, uris, defaultValue) => this.keyManagementHandler.deleteKeyFromLocaleFiles(keyPath, uris, defaultValue),\r\n        );\r\n        \r\n        this.styleHandler = new StyleHandler(i18nIndex);\r\n        \r\n        this.reportHandler = new ReportHandler(\r\n            i18nIndex,\r\n            translationService,\r\n            (record) => this.translationHandler.getRootNameForRecord(record),\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Cleanup all pending guard timeouts. Call on extension deactivation.\r\n     */\r\n    dispose(): void {\r\n        this.keyManagementHandler.dispose();\r\n    }\r\n\r\n    // ==================== Report Operations ====================\r\n\r\n    async openReport(): Promise<void> {\r\n        return this.reportHandler.openReport();\r\n    }\r\n\r\n    async applyAiFixes(): Promise<void> {\r\n        return this.reportHandler.applyAiFixes(\r\n            (folder, fixed) => this.reportHandler.pruneUntranslatedReports(folder, fixed),\r\n        );\r\n    }\r\n\r\n    async showHealthReport(): Promise<void> {\r\n        return this.reportHandler.showHealthReport();\r\n    }\r\n\r\n    async generateAutoIgnore(folderArg?: vscode.WorkspaceFolder): Promise<void> {\r\n        return this.reportHandler.generateAutoIgnore(folderArg);\r\n    }\r\n\r\n    async reviewSelection(documentUri?: vscode.Uri): Promise<void> {\r\n        return this.reportHandler.reviewSelection(\r\n            (uri, key, locales) => this.translationHandler.applyQuickFix(uri, key, locales),\r\n        );\r\n    }\r\n\r\n    // ==================== Translation Operations ====================\r\n\r\n    async applyQuickFix(\r\n        documentUri: vscode.Uri,\r\n        key: string,\r\n        locales: string[],\r\n    ): Promise<void> {\r\n        return this.translationHandler.applyQuickFix(documentUri, key, locales);\r\n    }\r\n\r\n    async translateAllUntranslatedInFile(documentUri?: vscode.Uri): Promise<void> {\r\n        const targetUri = documentUri || vscode.window.activeTextEditor?.document.uri;\r\n        if (!targetUri) {\r\n            vscode.window.showInformationMessage('AI Localizer: No active document to translate.');\r\n            return;\r\n        }\r\n        return this.translationHandler.translateAllUntranslatedInFile(\r\n            targetUri,\r\n            (folder, fixed) => this.reportHandler.pruneUntranslatedReports(folder, fixed),\r\n        );\r\n    }\r\n\r\n    async translateAllUntranslatedInProject(): Promise<void> {\r\n        return this.translationHandler.translateAllUntranslatedInProject(\r\n            (folder, fixed) => this.reportHandler.pruneUntranslatedReports(folder, fixed),\r\n            (folder) => this.reportHandler.generateAutoIgnore(folder),\r\n        );\r\n    }\r\n\r\n    async fixPlaceholderMismatch(documentUri: vscode.Uri, key: string, locale: string): Promise<void> {\r\n        return this.translationHandler.fixPlaceholderMismatch(documentUri, key, locale);\r\n    }\r\n\r\n    // ==================== Key Management Operations ====================\r\n\r\n    async fixMissingKeyReference(\r\n        documentUri: vscode.Uri,\r\n        position: { line: number; character: number },\r\n        key: string,\r\n    ): Promise<void> {\r\n        return this.keyManagementHandler.fixMissingKeyReference(documentUri, position, key);\r\n    }\r\n\r\n    async addKeyToIgnoreList(folderUri: vscode.Uri, key: string): Promise<void> {\r\n        return this.keyManagementHandler.addKeyToIgnoreList(folderUri, key);\r\n    }\r\n\r\n    async bulkFixMissingKeyReferences(documentUri: vscode.Uri): Promise<void> {\r\n        return this.keyManagementHandler.bulkFixMissingKeyReferences(documentUri);\r\n    }\r\n\r\n    async guardDeleteDefaultLocaleKey(\r\n        localeUri: vscode.Uri,\r\n        keyPath: string,\r\n        defaultValue: string,\r\n    ): Promise<boolean> {\r\n        return this.keyManagementHandler.guardDeleteDefaultLocaleKey(localeUri, keyPath, defaultValue);\r\n    }\r\n\r\n    // ==================== Cleanup Operations ====================\r\n\r\n    async cleanupUnusedInFile(documentUri?: vscode.Uri): Promise<void> {\r\n        return this.cleanupHandler.cleanupUnusedInFile(documentUri);\r\n    }\r\n\r\n    async removeUnusedKeyInFile(documentUri: vscode.Uri, keyPath: string): Promise<void> {\r\n        return this.cleanupHandler.removeUnusedKeyInFile(documentUri, keyPath);\r\n    }\r\n\r\n    async restoreInvalidInFile(documentUri?: vscode.Uri): Promise<void> {\r\n        return this.cleanupHandler.restoreInvalidInFile(documentUri);\r\n    }\r\n\r\n    async removeInvalidKeyInFile(documentUri: vscode.Uri, keyPath: string): Promise<void> {\r\n        return this.cleanupHandler.removeInvalidKeyInFile(documentUri, keyPath);\r\n    }\r\n\r\n    async restoreInvalidKeyInCode(\r\n        documentUri: vscode.Uri,\r\n        position: { line: number; character: number },\r\n        key: string,\r\n    ): Promise<void> {\r\n        return this.cleanupHandler.restoreInvalidKeyInCode(documentUri, position, key);\r\n    }\r\n\r\n    // ==================== Style Operations ====================\r\n\r\n    async applyStyleSuggestionQuickFix(\r\n        documentUri: vscode.Uri,\r\n        key: string,\r\n        locale: string,\r\n        suggested: string,\r\n    ): Promise<void> {\r\n        return this.styleHandler.applyStyleSuggestionQuickFix(documentUri, key, locale, suggested);\r\n    }\r\n\r\n    async applyAllStyleSuggestionsInFile(documentUri?: vscode.Uri): Promise<void> {\r\n        return this.styleHandler.applyAllStyleSuggestionsInFile(documentUri);\r\n    }\r\n\r\n    async fixAllIssuesInFile(documentUri?: vscode.Uri): Promise<void> {\r\n        return this.styleHandler.fixAllIssuesInFile(documentUri);\r\n    }\r\n}\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\untranslated\\utils\\FrameworkCodeGenerator.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'range' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":22,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":22,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isJsLike' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":25,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":25,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'document' is defined but never used. Allowed unused args must match /^_/u.","line":132,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":132,"endColumn":55}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Framework-specific code generation utility\r\n * Extracted from ConvertSelectionCommand to improve organization and reusability\r\n */\r\n\r\nimport * as vscode from 'vscode';\r\nimport { TemplateLiteralProcessor, TemplateInfo } from './TemplateLiteralProcessor';\r\n\r\nexport interface CodeGenerationOptions {\r\n    document: vscode.TextDocument;\r\n    range: vscode.Range;\r\n    key: string;\r\n    templateInfo?: TemplateInfo | null;\r\n    isJsSource?: boolean;\r\n}\r\n\r\nexport class FrameworkCodeGenerator {\r\n    /**\r\n     * Generate framework-specific replacement code\r\n     */\r\n    static generateReplacement(options: CodeGenerationOptions): string {\r\n        const { document, range, key, templateInfo, isJsSource } = options;\r\n        const langId = document.languageId;\r\n\r\n        const isJsLike = ['javascript', 'typescript', 'javascriptreact', 'typescriptreact'].includes(langId);\r\n        const isVueLike = langId === 'vue';\r\n        const isBladeLike = langId === 'blade' || langId === 'php';\r\n\r\n        if (isBladeLike) {\r\n            return `{{ __('${key}') }}`;\r\n        }\r\n\r\n        if (isVueLike) {\r\n            return `{{$t('${key}')}}`;\r\n        }\r\n\r\n        // JavaScript/TypeScript\r\n        let replacement = `t('${key}')`;\r\n        if (isJsSource && templateInfo && templateInfo.placeholders.length > 0) {\r\n            const argsObject = templateInfo.placeholders\r\n                .map(p => `${p.name}: ${p.expression}`)\r\n                .join(', ');\r\n            if (argsObject.length > 0) {\r\n                replacement = `t('${key}', { ${argsObject} })`;\r\n            }\r\n        }\r\n\r\n        return replacement;\r\n    }\r\n\r\n    /**\r\n     * Create workspace edit for framework-specific replacement\r\n     */\r\n    static createEdit(options: CodeGenerationOptions): vscode.WorkspaceEdit {\r\n        const edit = new vscode.WorkspaceEdit();\r\n        const replacement = this.generateReplacement(options);\r\n        edit.replace(options.document.uri, options.range, replacement);\r\n        return edit;\r\n    }\r\n\r\n    /**\r\n     * Add import statement if needed for JavaScript/TypeScript files\r\n     */\r\n    static addImportIfNeeded(\r\n        document: vscode.TextDocument,\r\n        edit: vscode.WorkspaceEdit,\r\n        tImportPath: string = '@/i18n'\r\n    ): void {\r\n        const langId = document.languageId;\r\n        const isJsLike = ['javascript', 'typescript', 'javascriptreact', 'typescriptreact'].includes(langId);\r\n        const isVueLike = langId === 'vue';\r\n        const isBladeLike = langId === 'blade' || langId === 'php';\r\n\r\n        // Only add imports for JS-like files (excluding Vue and Blade)\r\n        if (!isJsLike || isVueLike || isBladeLike) {\r\n            return;\r\n        }\r\n\r\n        const fullText = document.getText();\r\n        const hasTImport =\r\n            fullText.includes(`import { t } from '${tImportPath}'`) ||\r\n            fullText.includes(`import { t } from \"${tImportPath}\"`);\r\n\r\n        if (!hasTImport) {\r\n            const importLine = `import { t } from '${tImportPath}';\\n`;\r\n            const insertPos = this.findImportInsertPosition(document);\r\n            edit.insert(document.uri, insertPos, importLine);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find the best position to insert import statement\r\n     */\r\n    private static findImportInsertPosition(document: vscode.TextDocument): vscode.Position {\r\n        let lastImportLine = -1;\r\n        let firstCodeLine = -1;\r\n\r\n        for (let i = 0; i < document.lineCount; i++) {\r\n            const lineText = document.lineAt(i).text;\r\n            const trimmed = lineText.trim();\r\n\r\n            // Skip empty lines and comments\r\n            if (\r\n                !trimmed ||\r\n                trimmed.startsWith('//') ||\r\n                trimmed.startsWith('/*') ||\r\n                trimmed.startsWith('*')\r\n            ) {\r\n                continue;\r\n            }\r\n\r\n            if (trimmed.startsWith('import ') || trimmed.startsWith('import{')) {\r\n                lastImportLine = i;\r\n            } else if (firstCodeLine === -1) {\r\n                firstCodeLine = i;\r\n            }\r\n        }\r\n\r\n        // Insert after last import, or before first code line, or at the beginning\r\n        if (lastImportLine >= 0) {\r\n            return new vscode.Position(lastImportLine + 1, 0);\r\n        } else if (firstCodeLine >= 0) {\r\n            return new vscode.Position(firstCodeLine, 0);\r\n        }\r\n\r\n        return new vscode.Position(0, 0);\r\n    }\r\n\r\n    /**\r\n     * Get framework-specific import path\r\n     */\r\n    static getImportPath(document: vscode.TextDocument): string {\r\n        const config = vscode.workspace.getConfiguration('ai-localizer');\r\n        return config.get<string>('i18n.tImportPath') || '@/i18n';\r\n    }\r\n\r\n    /**\r\n     * Check if file needs import handling\r\n     */\r\n    static needsImportHandling(document: vscode.TextDocument): boolean {\r\n        const langId = document.languageId;\r\n        const isJsLike = ['javascript', 'typescript', 'javascriptreact', 'typescriptreact'].includes(langId);\r\n        const isVueLike = langId === 'vue';\r\n        const isBladeLike = langId === 'blade' || langId === 'php';\r\n        \r\n        return isJsLike && !isVueLike && !isBladeLike;\r\n    }\r\n\r\n    /**\r\n     * Analyze template literal for JS source files\r\n     */\r\n    static analyzeTemplateLiteral(document: vscode.TextDocument, range: vscode.Range): TemplateInfo | null {\r\n        const rawLiteral = document.getText(range);\r\n        return TemplateLiteralProcessor.analyze(rawLiteral);\r\n    }\r\n\r\n    /**\r\n     * Validate generated code for common issues\r\n     */\r\n    static validateGeneratedCode(code: string, framework: string): { isValid: boolean; issues: string[] } {\r\n        const issues: string[] = [];\r\n\r\n        if (!code || typeof code !== 'string') {\r\n            issues.push('Generated code is empty or invalid');\r\n            return { isValid: false, issues };\r\n        }\r\n\r\n        // Framework-specific validation\r\n        switch (framework) {\r\n            case 'vue':\r\n                if (!code.includes('{$t(')) {\r\n                    issues.push('Vue code should use {$t()} syntax');\r\n                }\r\n                break;\r\n            case 'blade':\r\n                if (!code.includes('{{ __(')) {\r\n                    issues.push('Blade code should use {{ __() }} syntax');\r\n                }\r\n                break;\r\n            case 'js':\r\n            case 'ts':\r\n            case 'jsx':\r\n            case 'tsx':\r\n                if (!code.includes('t(')) {\r\n                    issues.push('JS/TS code should use t() function');\r\n                }\r\n                break;\r\n        }\r\n\r\n        return { isValid: issues.length === 0, issues };\r\n    }\r\n\r\n    /**\r\n     * Get framework name from document\r\n     */\r\n    static getFrameworkName(document: vscode.TextDocument): string {\r\n        const langId = document.languageId;\r\n        \r\n        switch (langId) {\r\n            case 'vue': return 'vue';\r\n            case 'blade': return 'blade';\r\n            case 'php': return 'blade';\r\n            case 'javascript': return 'js';\r\n            case 'typescript': return 'ts';\r\n            case 'javascriptreact': return 'jsx';\r\n            case 'typescriptreact': return 'tsx';\r\n            default: return 'unknown';\r\n        }\r\n    }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\untranslated\\utils\\SelectionStringDetector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\untranslated\\utils\\StringPatterns.ts","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":84,"column":53,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":84,"endColumn":54,"suggestions":[{"messageId":"removeEscape","fix":{"range":[2691,2692],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[2691,2691],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Shared regex patterns for string detection across different frameworks\r\n * Eliminates duplication between selection commands and parsers\r\n */\r\n\r\nexport const STRING_PATTERNS = {\r\n    // JSX expression strings: {'text'} or {\"text\"}\r\n    jsxExpr: /\\{\\s*(['\"])((?:\\\\.|(?!\\1)[\\s\\S])+?)\\1\\s*\\}/g,\r\n    \r\n    // Object property values: \"description: `some text`\" or \"title: 'some text'\"\r\n    property: /^\\s*(?:[\\w$]+|['\"][^'\"]+['\"])\\s*:\\s*(['\"`])([\\s\\S]+?)\\1\\s*,?\\s*$/s,\r\n    \r\n    // Generic string literals (single and double quotes)\r\n    generic: /(['\"])((?:\\\\.|(?!\\1)[\\s\\S])+?)\\1/g,\r\n    \r\n    // Template literals (backticks)\r\n    template: /`([^`]+)`/g,\r\n    \r\n    // Blade array items: 'key' => 'value'\r\n    bladeArray: /^\\s*(['\"])([^'\"]+)\\1\\s*=>\\s*(['\"])([\\s\\S]+?)\\3\\s*,?\\s*$/s,\r\n    \r\n    // Alpine.js x-text string literals\r\n    alpineText: /(['\"])([^'\"\\\\]*(?:\\\\.[^'\"\\\\]*)*)\\1/g,\r\n    \r\n    // Alpine.js ternary expressions\r\n    alpineTernary: /\\?\\s*(['\"])([^'\"\\\\]*(?:\\\\.[^'\"\\\\]*)*)\\1\\s*:\\s*(['\"])([^'\"\\\\]*(?:\\\\.[^'\"\\\\]*)*)\\3/g,\r\n    \r\n    // Blade expressions for placeholder replacement\r\n    bladeExpr: [\r\n        /\\{\\{\\s*[^}]+\\s*\\}\\}/g,\r\n        /\\{!!\\s*[^}]+\\s*!!\\}/g\r\n    ],\r\n    \r\n    // Template literal interpolations\r\n    interpolation: /\\$\\{([^}]*)\\}/g,\r\n    \r\n    // Module import/export patterns (to skip)\r\n    moduleSpec: [\r\n        /^\\s*import\\s+[\\s\\S]*?from\\s*['\"][^'\"]+['\"]/,\r\n        /^\\s*import\\s*\\(\\s*['\"][^'\"]+['\"]\\s*\\)/,\r\n        /^\\s*export\\s+[\\s\\S]*?from\\s*['\"][^'\"]+['\"]/,\r\n        /\\brequire\\s*\\(\\s*['\"][^'\"]+['\"]\\s*\\)/\r\n    ],\r\n    \r\n    // I18n patterns (to skip)\r\n    i18nPatterns: [\r\n        /\\$?t\\s*\\(\\s*['\"][^'\"]+['\"]\\s*\\)/,\r\n        /i18n\\.t\\s*\\(\\s*['\"][^'\"]+['\"]\\s*\\)/,\r\n        /useI18n\\(\\)\\.t\\s*\\(\\s*['\"][^'\"]+['\"]\\s*\\)/\r\n    ]\r\n};\r\n\r\n/**\r\n * Framework-specific text preprocessing\r\n */\r\nexport const FRAMEWORK_PREPROCESSORS = {\r\n    vue: (text: string) => {\r\n        // Wrap in template tags if needed for Vue parser\r\n        if (!text.includes('<template>') && !text.includes('<script>') && !text.includes('<style>')) {\r\n            return `<template>${text}</template>`;\r\n        }\r\n        return text;\r\n    },\r\n    jsx: (text: string) => text, // No preprocessing needed\r\n    blade: (text: string) => text, // No preprocessing needed\r\n    generic: (text: string) => text\r\n};\r\n\r\n/**\r\n * Check if text looks like code (should be avoided for full selection)\r\n */\r\nexport const CODE_PATTERNS = [\r\n    /[:;{}<>]|=>|\\bfunction\\b|\\breturn\\b/,\r\n    /^\\s*import\\s/,\r\n    /^\\s*export\\s/,\r\n    /^\\s*const\\s/,\r\n    /^\\s*let\\s/,\r\n    /^\\s*var\\s/\r\n];\r\n\r\n/**\r\n * Punctuation-only patterns to skip\r\n */\r\nexport const PUNCTUATION_ONLY = /^[.,;:!?'\"()[\\]{}<>\\/\\\\|@#$%^&*+=~`-]+$/;\r\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\untranslated\\utils\\TemplateLiteralProcessor.ts","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":128,"column":64,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":128,"endColumn":65,"suggestions":[{"messageId":"removeEscape","fix":{"range":[4651,4652],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[4651,4651],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Consolidated template literal processing utility\r\n * Combines logic from analyzeTemplateLiteral and extractStaticPartsFromTemplate\r\n */\r\n\r\nexport interface TemplateInfo {\r\n    baseText: string;\r\n    placeholders: Array<{ name: string; expression: string }>;\r\n}\r\n\r\nexport interface StaticPart {\r\n    text: string;\r\n    offset: number;\r\n}\r\n\r\nexport class TemplateLiteralProcessor {\r\n    /**\r\n     * Analyze a template literal and extract base text with placeholders\r\n     * Combines the logic from analyzeTemplateLiteral method\r\n     */\r\n    static analyze(rawLiteral: string): TemplateInfo | null {\r\n        if (!rawLiteral || rawLiteral.length < 2 || rawLiteral[0] !== '`' || rawLiteral[rawLiteral.length - 1] !== '`') {\r\n            return null;\r\n        }\r\n\r\n        const inner = rawLiteral.slice(1, -1);\r\n        const placeholders: Array<{ name: string; expression: string }> = [];\r\n        let baseText = '';\r\n        let lastIndex = 0;\r\n        const usedNames = new Set<string>();\r\n\r\n        const interpolationRegex = /\\$\\{([^}]*)\\}/g;\r\n        let match: RegExpExecArray | null;\r\n        \r\n        while ((match = interpolationRegex.exec(inner)) !== null) {\r\n            const expr = match[1].trim();\r\n            baseText += inner.slice(lastIndex, match.index);\r\n\r\n            if (expr.length > 0) {\r\n                let name: string | null = null;\r\n\r\n                // Handle .length patterns\r\n                const lengthMatch = expr.match(/([A-Za-z_][A-Za-z0-9_]*)\\s*\\.length\\s*$/);\r\n                if (lengthMatch && lengthMatch[1]) {\r\n                    const base = lengthMatch[1];\r\n                    name = /count$/i.test(base) ? base : `${base}Count`;\r\n                }\r\n\r\n                // Handle identifier patterns\r\n                if (!name) {\r\n                    const idMatch = expr.match(/([A-Za-z_][A-Za-z0-9_]*)\\s*$/);\r\n                    if (idMatch && idMatch[1]) {\r\n                        name = idMatch[1];\r\n                    }\r\n                }\r\n\r\n                // Generate fallback name\r\n                if (!name) {\r\n                    name = `value${placeholders.length + 1}`;\r\n                }\r\n\r\n                // Ensure unique name\r\n                let uniqueName = name;\r\n                let counter = 2;\r\n                while (usedNames.has(uniqueName)) {\r\n                    uniqueName = `${name}${counter}`;\r\n                    counter += 1;\r\n                }\r\n                usedNames.add(uniqueName);\r\n\r\n                placeholders.push({ name: uniqueName, expression: expr });\r\n                baseText += `{${uniqueName}}`;\r\n            }\r\n\r\n            lastIndex = interpolationRegex.lastIndex;\r\n        }\r\n\r\n        baseText += inner.slice(lastIndex);\r\n        return { baseText, placeholders };\r\n    }\r\n\r\n    /**\r\n     * Extract static text parts from a template literal, excluding interpolations\r\n     * Combines the logic from extractStaticPartsFromTemplate method\r\n     */\r\n    static extractStaticParts(template: string): StaticPart[] {\r\n        const parts: StaticPart[] = [];\r\n        \r\n        // Split by ${...} interpolations\r\n        const segments = template.split(/\\$\\{[^}]*\\}/);\r\n        let currentOffset = 0;\r\n        \r\n        for (let i = 0; i < segments.length; i++) {\r\n            const segment = segments[i];\r\n            if (segment.trim().length > 0) {\r\n                parts.push({ text: segment, offset: currentOffset });\r\n            }\r\n            \r\n            // Move offset forward by segment length + interpolation length\r\n            currentOffset += segment.length;\r\n            if (i < segments.length - 1) {\r\n                // Find the interpolation that was removed\r\n                const remainingTemplate = template.substring(currentOffset);\r\n                const interpolationMatch = remainingTemplate.match(/^\\$\\{[^}]*\\}/);\r\n                if (interpolationMatch) {\r\n                    currentOffset += interpolationMatch[0].length;\r\n                }\r\n            }\r\n        }\r\n        \r\n        return parts;\r\n    }\r\n\r\n    /**\r\n     * Get combined static text from template literal\r\n     * Useful for validation and translatability checks\r\n     */\r\n    static getCombinedStaticText(template: string): string {\r\n        const staticParts = this.extractStaticParts(template);\r\n        return staticParts.map(p => p.text).join(' ').trim();\r\n    }\r\n\r\n    /**\r\n     * Check if template literal has meaningful static content\r\n     */\r\n    static hasTranslatableContent(template: string): boolean {\r\n        const combinedText = this.getCombinedStaticText(template);\r\n        return combinedText.length > 0 && !/^[.,;:!?'\"()[\\]{}<>\\/\\\\|@#$%^&*+=~`-]+$/.test(combinedText);\r\n    }\r\n\r\n    /**\r\n     * Create replacement string for template literal with placeholders\r\n     */\r\n    static createReplacement(baseText: string, placeholders: Array<{ name: string; expression: string }>): string {\r\n        if (placeholders.length === 0) {\r\n            return `'${baseText}'`;\r\n        }\r\n\r\n        const argsObject = placeholders\r\n            .map(p => `${p.name}: ${p.expression}`)\r\n            .join(', ');\r\n        \r\n        return `t('${baseText}', { ${argsObject} })`;\r\n    }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\untranslated\\utils\\TranslationKeyGenerator.ts","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":50,"column":15,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":50,"endColumn":16,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1515,1516],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1515,1515],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Translation key generation utility\r\n * Extracted from ConvertSelectionCommand to improve organization and reusability\r\n */\r\n\r\nimport { slugifyForKey } from '../../../core/i18nIndex';\r\n\r\nexport interface KeyGenerationOptions {\r\n    kind: string;\r\n    namespace: string;\r\n    sourceText: string;\r\n}\r\n\r\nexport class TranslationKeyGenerator {\r\n    /**\r\n     * Generate a translation key based on source text and context\r\n     */\r\n    static generateKey(options: KeyGenerationOptions): string {\r\n        const { kind, namespace, sourceText } = options;\r\n        \r\n        let baseNamespace = namespace;\r\n        if (this.isCommonShortText(sourceText)) {\r\n            baseNamespace = 'Commons';\r\n        }\r\n        \r\n        const slug = slugifyForKey(sourceText);\r\n        return `${baseNamespace}.${kind}.${slug}`;\r\n    }\r\n\r\n    /**\r\n     * Determine if text should use Commons namespace\r\n     * Common short text gets special namespace treatment\r\n     */\r\n    private static isCommonShortText(text: string): boolean {\r\n        const trimmed = String(text || '').trim();\r\n        if (!trimmed) {\r\n            return false;\r\n        }\r\n        const cleaned = trimmed.replace(/\\s+/g, ' ').trim();\r\n        if (/[.!?]/.test(cleaned)) {\r\n            return false;\r\n        }\r\n        const words = cleaned.split(' ').filter((w) => !!w);\r\n        if (!words.length || words.length > 2) {\r\n            return false;\r\n        }\r\n        if (cleaned.length > 24) {\r\n            return false;\r\n        }\r\n        if (/[\\/_]/.test(cleaned)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get available text kinds for user selection\r\n     */\r\n    static getTextKinds(): Array<{ label: string; description: string }> {\r\n        return [\r\n            { label: 'text', description: 'Generic UI text (default)' },\r\n            { label: 'heading', description: 'Headings and titles' },\r\n            { label: 'button', description: 'Buttons and primary actions' },\r\n            { label: 'label', description: 'Field labels and chips' },\r\n            { label: 'placeholder', description: 'Input placeholders' },\r\n            { label: 'toast', description: 'Toast and notification messages' },\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * Infer kind from tag name (for context-aware key generation)\r\n     */\r\n    static inferKindFromTag(tagName: string): string {\r\n        if (!tagName) return 'text';\r\n        const lower = tagName.toLowerCase();\r\n\r\n        const tagKinds: Record<string, string> = {\r\n            // Headings\r\n            'h1': 'heading', 'h2': 'heading', 'h3': 'heading',\r\n            'h4': 'heading', 'h5': 'heading', 'h6': 'heading',\r\n            'title': 'heading',\r\n            \r\n            // Buttons and actions\r\n            'button': 'button',\r\n            'a': 'button', 'link': 'button',\r\n            \r\n            // Labels and form elements\r\n            'label': 'label', 'span': 'label',\r\n            'div': 'text', 'p': 'text',\r\n            \r\n            // Inputs\r\n            'textarea': 'placeholder', 'input': 'placeholder',\r\n            'select': 'placeholder', 'option': 'label',\r\n            \r\n            // Tables\r\n            'th': 'heading', 'td': 'text',\r\n            'caption': 'text',\r\n            \r\n            // Lists\r\n            'li': 'text', 'dt': 'heading', 'dd': 'text',\r\n            \r\n            // Media\r\n            'img': 'text', 'figure': 'text', 'figcaption': 'text',\r\n            \r\n            // Semantic HTML5\r\n            'header': 'heading', 'footer': 'text',\r\n            'nav': 'button', 'aside': 'text',\r\n            'article': 'heading', 'section': 'heading',\r\n            'main': 'heading',\r\n            \r\n            // Forms\r\n            'form': 'text', 'fieldset': 'heading',\r\n            'legend': 'heading',\r\n            \r\n            // Interactive\r\n            'summary': 'button', 'details': 'text',\r\n        };\r\n\r\n        return tagKinds[lower] || 'text';\r\n    }\r\n\r\n    /**\r\n     * Infer kind from attribute name\r\n     */\r\n    static inferKindFromAttr(attrName: string): string {\r\n        if (!attrName) return 'text';\r\n        const lower = attrName.toLowerCase();\r\n\r\n        const attrKinds: Record<string, string> = {\r\n            // Text content\r\n            'title': 'heading', 'alt': 'text', 'label': 'label',\r\n            'placeholder': 'placeholder', 'value': 'text',\r\n            \r\n            // ARIA attributes\r\n            'aria-label': 'label', 'aria-placeholder': 'placeholder',\r\n            'aria-description': 'text', 'aria-title': 'heading',\r\n            \r\n            // Common attributes\r\n            'tooltip': 'text', 'hint': 'text', 'help': 'text',\r\n            'description': 'text', 'summary': 'text',\r\n            \r\n            // Form attributes\r\n            'name': 'label', 'id': 'text', 'class': 'text',\r\n            \r\n            // Link attributes\r\n            'href': 'text', 'src': 'text', 'data-*': 'text'\r\n        };\r\n\r\n        return attrKinds[lower] || 'text';\r\n    }\r\n\r\n    /**\r\n     * Validate generated key for common issues\r\n     */\r\n    static validateKey(key: string): { isValid: boolean; issues: string[] } {\r\n        const issues: string[] = [];\r\n\r\n        if (!key || typeof key !== 'string') {\r\n            issues.push('Key must be a non-empty string');\r\n            return { isValid: false, issues };\r\n        }\r\n\r\n        if (key.length > 200) {\r\n            issues.push('Key is too long (max 200 characters)');\r\n        }\r\n\r\n        if (!/^[a-zA-Z0-9._-]+$/.test(key)) {\r\n            issues.push('Key contains invalid characters (only letters, numbers, dots, hyphens, underscores allowed)');\r\n        }\r\n\r\n        if (key.startsWith('.') || key.endsWith('.')) {\r\n            issues.push('Key cannot start or end with a dot');\r\n        }\r\n\r\n        if (key.includes('..')) {\r\n            issues.push('Key cannot contain consecutive dots');\r\n        }\r\n\r\n        const parts = key.split('.');\r\n        if (parts.length < 2) {\r\n            issues.push('Key should have at least namespace and kind parts (e.g., \"Commons.button.save\")');\r\n        }\r\n\r\n        if (parts.length > 5) {\r\n            issues.push('Key has too many parts (max 5 parts recommended)');\r\n        }\r\n\r\n        return { isValid: issues.length === 0, issues };\r\n    }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\untranslated\\utils\\commentParser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\untranslated\\utils\\diagnosticParser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\untranslated\\utils\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\untranslated\\utils\\jsonUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\untranslated\\utils\\localeCache.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":75,"column":13,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":75,"endColumn":44,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[2601,2602],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":225,"column":37,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":225,"endColumn":72},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":228,"column":63,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":228,"endColumn":77,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[9475,9476],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":279,"column":20,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":279,"endColumn":58},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":418,"column":33,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":418,"endColumn":66,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[16675,16676],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":480,"column":12,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":480,"endColumn":36}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\r\nimport * as path from 'path';\r\nimport { TextDecoder } from 'util';\r\nimport { execFile } from 'child_process';\r\nimport { promisify } from 'util';\r\n\r\nconst execFileAsync = promisify(execFile);\r\nconst sharedDecoder = new TextDecoder('utf-8');\r\n\r\nconst GIT_TIMEOUT_MS = 30000;\r\nconst GIT_MAX_BUFFER = 10 * 1024 * 1024;\r\n\r\nexport interface LocaleFileInfo {\r\n    uri: vscode.Uri;\r\n    path: string;\r\n    relativePath: string;\r\n    locale: string;\r\n    fileName: string;\r\n}\r\n\r\nexport interface CachedLocaleContent {\r\n    json: Record<string, any>;\r\n    raw: string;\r\n}\r\n\r\nexport interface GitCommitHistory {\r\n    commits: Array<{ hash: string; date: Date; message: string }>;\r\n    lastFetched: number;\r\n}\r\n\r\n/**\r\n * High-performance locale file cache for bulk operations.\r\n * Pre-loads and caches locale files, git history, and content at commits.\r\n */\r\nexport class LocaleCache {\r\n    private localeFilesCache = new Map<string, LocaleFileInfo[]>();\r\n    private headContentCache = new Map<string, CachedLocaleContent>();\r\n    private commitContentCache = new Map<string, Record<string, any> | null>();\r\n    private gitHistoryCache = new Map<string, GitCommitHistory>();\r\n    private sourceFileKeyIndex = new Map<string, Set<string>>();\r\n    private initialized = false;\r\n    private initPromise: Promise<void> | null = null;\r\n\r\n    constructor(\r\n        private folder: vscode.WorkspaceFolder,\r\n        private log?: vscode.OutputChannel,\r\n    ) {}\r\n\r\n    /**\r\n     * Initialize the cache by pre-loading all locale files and their contents\r\n     */\r\n    async initialize(defaultLocale: string, daysBack: number = 120): Promise<void> {\r\n        if (this.initialized) return;\r\n        if (this.initPromise) return this.initPromise;\r\n\r\n        this.initPromise = this.doInitialize(defaultLocale, daysBack);\r\n        await this.initPromise;\r\n        this.initialized = true;\r\n    }\r\n\r\n    private async doInitialize(defaultLocale: string, daysBack: number): Promise<void> {\r\n        const startTime = Date.now();\r\n        this.log?.appendLine(`[LocaleCache] Initializing cache for ${this.folder.name}...`);\r\n\r\n        // Discover all locale files\r\n        const localeFiles = await this.discoverAllLocaleFiles();\r\n        this.log?.appendLine(`[LocaleCache] Found ${localeFiles.length} locale files`);\r\n\r\n        // Group by locale\r\n        for (const file of localeFiles) {\r\n            const key = file.locale;\r\n            if (!this.localeFilesCache.has(key)) {\r\n                this.localeFilesCache.set(key, []);\r\n            }\r\n            this.localeFilesCache.get(key)!.push(file);\r\n        }\r\n\r\n        // Pre-load HEAD content for ALL locale files (needed for cross-locale search)\r\n        // Start with default locale for priority, then load others\r\n        const defaultLocaleFiles = this.localeFilesCache.get(defaultLocale) || [];\r\n        await this.preloadHeadContent(defaultLocaleFiles);\r\n        \r\n        // Load remaining locales in parallel\r\n        const otherLocaleFiles = localeFiles.filter(f => f.locale !== defaultLocale);\r\n        await this.preloadHeadContent(otherLocaleFiles);\r\n\r\n        // Pre-fetch git history for all locale files (batched)\r\n        await this.preloadGitHistory(localeFiles, daysBack);\r\n\r\n        const elapsed = Date.now() - startTime;\r\n        this.log?.appendLine(`[LocaleCache] Initialization complete in ${elapsed}ms`);\r\n    }\r\n\r\n    /**\r\n     * Discover all locale files in the project\r\n     */\r\n    private async discoverAllLocaleFiles(): Promise<LocaleFileInfo[]> {\r\n        const files: LocaleFileInfo[] = [];\r\n        const basePaths = [\r\n            path.join('resources', 'js', 'i18n', 'auto'),\r\n            path.join('src', 'i18n'),\r\n            path.join('src', 'locales'),\r\n            'locales',\r\n            'i18n',\r\n        ];\r\n\r\n        for (const basePath of basePaths) {\r\n            const baseUri = vscode.Uri.file(path.join(this.folder.uri.fsPath, basePath));\r\n            try {\r\n                const entries = await vscode.workspace.fs.readDirectory(baseUri);\r\n                for (const [name, type] of entries) {\r\n                    if (type === vscode.FileType.Directory) {\r\n                        // Locale directory (e.g., /en/, /fr/)\r\n                        const localeDir = vscode.Uri.joinPath(baseUri, name);\r\n                        try {\r\n                            const localeEntries = await vscode.workspace.fs.readDirectory(localeDir);\r\n                            for (const [fileName, fileType] of localeEntries) {\r\n                                if (fileType === vscode.FileType.File && fileName.endsWith('.json')) {\r\n                                    const fileUri = vscode.Uri.joinPath(localeDir, fileName);\r\n                                    const relativePath = path.relative(this.folder.uri.fsPath, fileUri.fsPath).replace(/\\\\/g, '/');\r\n                                    files.push({\r\n                                        uri: fileUri,\r\n                                        path: fileUri.fsPath,\r\n                                        relativePath,\r\n                                        locale: name,\r\n                                        fileName,\r\n                                    });\r\n                                }\r\n                            }\r\n                        } catch {\r\n                            // Directory access failed\r\n                        }\r\n                    } else if (type === vscode.FileType.File && name.endsWith('.json')) {\r\n                        // Single locale file (e.g., en.json)\r\n                        const locale = name.replace('.json', '');\r\n                        const fileUri = vscode.Uri.joinPath(baseUri, name);\r\n                        const relativePath = path.relative(this.folder.uri.fsPath, fileUri.fsPath).replace(/\\\\/g, '/');\r\n                        files.push({\r\n                            uri: fileUri,\r\n                            path: fileUri.fsPath,\r\n                            relativePath,\r\n                            locale,\r\n                            fileName: name,\r\n                        });\r\n                    }\r\n                }\r\n            } catch {\r\n                // Base path doesn't exist\r\n            }\r\n        }\r\n\r\n        return files;\r\n    }\r\n\r\n    /**\r\n     * Pre-load HEAD content for locale files in parallel\r\n     */\r\n    private async preloadHeadContent(files: LocaleFileInfo[]): Promise<void> {\r\n        const batchSize = 10;\r\n        for (let i = 0; i < files.length; i += batchSize) {\r\n            const batch = files.slice(i, i + batchSize);\r\n            await Promise.all(batch.map(async (file) => {\r\n                try {\r\n                    const data = await vscode.workspace.fs.readFile(file.uri);\r\n                    const raw = sharedDecoder.decode(data);\r\n                    const json = JSON.parse(raw);\r\n                    this.headContentCache.set(file.path, { json, raw });\r\n                } catch {\r\n                    // File read failed\r\n                }\r\n            }));\r\n        }\r\n        this.log?.appendLine(`[LocaleCache] Pre-loaded ${this.headContentCache.size} locale files from HEAD`);\r\n    }\r\n\r\n    /**\r\n     * Pre-fetch git history for all locale files using a single batched command\r\n     */\r\n    private async preloadGitHistory(files: LocaleFileInfo[], daysBack: number): Promise<void> {\r\n        if (files.length === 0) return;\r\n\r\n        try {\r\n            // Get all file histories in a single git log call\r\n            const relativePaths = files.map(f => f.relativePath);\r\n            const { stdout } = await execFileAsync(\r\n                'git',\r\n                [\r\n                    'log',\r\n                    `--since=${daysBack} days ago`,\r\n                    '-n', '100',\r\n                    '--format=%H|%ai|%s',\r\n                    '--name-only',\r\n                    '--',\r\n                    ...relativePaths,\r\n                ],\r\n                {\r\n                    cwd: this.folder.uri.fsPath,\r\n                    timeout: GIT_TIMEOUT_MS,\r\n                    maxBuffer: GIT_MAX_BUFFER,\r\n                },\r\n            );\r\n\r\n            // Parse the batched output\r\n            const lines = stdout.split('\\n');\r\n            let currentCommit: { hash: string; date: Date; message: string } | null = null;\r\n\r\n            for (const line of lines) {\r\n                if (line.includes('|')) {\r\n                    const [hash, dateStr, ...messageParts] = line.split('|');\r\n                    if (hash && dateStr) {\r\n                        currentCommit = {\r\n                            hash: hash.trim(),\r\n                            date: new Date(dateStr.trim()),\r\n                            message: messageParts.join('|').trim(),\r\n                        };\r\n                    }\r\n                } else if (line.trim() && currentCommit) {\r\n                    // This is a file path\r\n                    const filePath = line.trim();\r\n                    const fullPath = path.join(this.folder.uri.fsPath, filePath);\r\n                    \r\n                    if (!this.gitHistoryCache.has(fullPath)) {\r\n                        this.gitHistoryCache.set(fullPath, { commits: [], lastFetched: Date.now() });\r\n                    }\r\n                    const history = this.gitHistoryCache.get(fullPath)!;\r\n                    \r\n                    // Avoid duplicates\r\n                    if (!history.commits.find(c => c.hash === currentCommit!.hash)) {\r\n                        history.commits.push({ ...currentCommit });\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.log?.appendLine(`[LocaleCache] Pre-fetched git history for ${this.gitHistoryCache.size} files`);\r\n        } catch (err) {\r\n            this.log?.appendLine(`[LocaleCache] Git history batch fetch failed: ${String(err)}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all locale files for a specific locale\r\n     */\r\n    getLocaleFiles(locale: string): LocaleFileInfo[] {\r\n        return this.localeFilesCache.get(locale) || [];\r\n    }\r\n\r\n    /**\r\n     * Get all locale files across all locales\r\n     */\r\n    getAllLocaleFiles(): LocaleFileInfo[] {\r\n        const files: LocaleFileInfo[] = [];\r\n        for (const localeFiles of this.localeFilesCache.values()) {\r\n            files.push(...localeFiles);\r\n        }\r\n        return files;\r\n    }\r\n\r\n    /**\r\n     * Get cached HEAD content for a file\r\n     */\r\n    getHeadContent(filePath: string): CachedLocaleContent | null {\r\n        return this.headContentCache.get(filePath) || null;\r\n    }\r\n\r\n    /**\r\n     * Get cached git history for a file\r\n     */\r\n    getGitHistory(filePath: string): GitCommitHistory | null {\r\n        return this.gitHistoryCache.get(filePath) || null;\r\n    }\r\n\r\n    /**\r\n     * Get file content at a specific commit (with caching)\r\n     */\r\n    async getContentAtCommit(filePath: string, commitHash: string): Promise<Record<string, any> | null> {\r\n        const cacheKey = `${filePath}:${commitHash}`;\r\n        \r\n        if (this.commitContentCache.has(cacheKey)) {\r\n            return this.commitContentCache.get(cacheKey)!;\r\n        }\r\n\r\n        try {\r\n            const relativePath = path.relative(this.folder.uri.fsPath, filePath).replace(/\\\\/g, '/');\r\n            const { stdout } = await execFileAsync(\r\n                'git',\r\n                ['show', `${commitHash}:${relativePath}`],\r\n                {\r\n                    cwd: this.folder.uri.fsPath,\r\n                    timeout: GIT_TIMEOUT_MS,\r\n                    maxBuffer: GIT_MAX_BUFFER,\r\n                },\r\n            );\r\n            \r\n            const json = JSON.parse(stdout);\r\n            this.commitContentCache.set(cacheKey, json);\r\n            return json;\r\n        } catch {\r\n            this.commitContentCache.set(cacheKey, null);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Search for a key in all cached HEAD content\r\n     */\r\n    findKeyInHeadContent(keyPath: string, keyVariations: string[]): { value: string; file: LocaleFileInfo } | null {\r\n        for (const [filePath, content] of this.headContentCache.entries()) {\r\n            for (const keyVariant of keyVariations) {\r\n                const value = this.getNestedValue(content.json, keyVariant);\r\n                if (value && typeof value === 'string') {\r\n                    const file = this.getAllLocaleFiles().find(f => f.path === filePath);\r\n                    if (file) {\r\n                        return { value, file };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Search for a key in git history across all cached files\r\n     */\r\n    async findKeyInHistoryBatch(\r\n        keyPath: string,\r\n        keyVariations: string[],\r\n        maxCommitsPerFile: number = 10,\r\n    ): Promise<{ value: string; source: string; commitHash: string } | null> {\r\n        const allFiles = this.getAllLocaleFiles();\r\n        \r\n        // Try each file's history\r\n        for (const file of allFiles) {\r\n            const history = this.gitHistoryCache.get(file.path);\r\n            if (!history || history.commits.length === 0) continue;\r\n\r\n            // Only check first N commits per file for performance\r\n            const commitsToCheck = history.commits.slice(0, maxCommitsPerFile);\r\n            \r\n            for (const commit of commitsToCheck) {\r\n                const json = await this.getContentAtCommit(file.path, commit.hash);\r\n                if (!json) continue;\r\n\r\n                for (const keyVariant of keyVariations) {\r\n                    const value = this.getNestedValue(json, keyVariant);\r\n                    if (value && typeof value === 'string') {\r\n                        return {\r\n                            value,\r\n                            source: `history:${commit.hash}`,\r\n                            commitHash: commit.hash,\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Build source file index for faster key lookups\r\n     */\r\n    async buildSourceFileKeyIndex(keys: string[]): Promise<void> {\r\n        if (keys.length === 0) return;\r\n        \r\n        const cfg = vscode.workspace.getConfiguration('ai-localizer');\r\n        const sourceGlobs = cfg.get<string[]>('i18n.sourceGlobs') || ['**/*.{ts,tsx,js,jsx,vue}'];\r\n        const excludeGlobs = cfg.get<string[]>('i18n.sourceExcludeGlobs') || [\r\n            '**/node_modules/**', '**/.git/**', '**/dist/**', '**/build/**',\r\n        ];\r\n        const exclude = excludeGlobs.length > 0 ? `{${excludeGlobs.join(',')}}` : undefined;\r\n\r\n        const seen = new Set<string>();\r\n        const uris: vscode.Uri[] = [];\r\n        const includes = sourceGlobs.length > 0 ? sourceGlobs : [];\r\n\r\n        for (const include of includes) {\r\n            try {\r\n                const pattern = new vscode.RelativePattern(this.folder, include);\r\n                const found = await vscode.workspace.findFiles(pattern, exclude, 500);\r\n                for (const uri of found) {\r\n                    const key = uri.toString();\r\n                    if (!seen.has(key)) {\r\n                        seen.add(key);\r\n                        uris.push(uri);\r\n                    }\r\n                }\r\n            } catch {\r\n                // Skip invalid glob patterns\r\n            }\r\n        }\r\n        \r\n        // Build search patterns for all keys\r\n        const keyPatterns = keys.map((key) => {\r\n            const escapedKey = key.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n            return {\r\n                key,\r\n                patterns: [\r\n                    new RegExp(`\\\\b\\\\$?t\\\\s*\\\\(\\\\s*(['\"\\`])${escapedKey}\\\\1\\\\s*(?:,|\\\\))`),\r\n                ],\r\n            };\r\n        });\r\n\r\n        // Read files and index which keys they contain\r\n        const batchSize = 20;\r\n        for (let i = 0; i < uris.length; i += batchSize) {\r\n            const batch = uris.slice(i, i + batchSize);\r\n            await Promise.all(batch.map(async (uri) => {\r\n                try {\r\n                    const data = await vscode.workspace.fs.readFile(uri);\r\n                    const content = sharedDecoder.decode(data);\r\n                    \r\n                    for (const { key, patterns } of keyPatterns) {\r\n                        for (const pattern of patterns) {\r\n                            if (pattern.test(content)) {\r\n                                if (!this.sourceFileKeyIndex.has(key)) {\r\n                                    this.sourceFileKeyIndex.set(key, new Set());\r\n                                }\r\n                                this.sourceFileKeyIndex.get(key)!.add(uri.fsPath);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                } catch {\r\n                    // Skip files that can't be read\r\n                }\r\n            }));\r\n        }\r\n        \r\n        this.log?.appendLine(`[LocaleCache] Built source file index for ${keys.length} keys, found ${this.sourceFileKeyIndex.size} with matches`);\r\n    }\r\n\r\n    /**\r\n     * Get source files that reference a key\r\n     */\r\n    getSourceFilesForKey(key: string): string[] {\r\n        const files = this.sourceFileKeyIndex.get(key);\r\n        return files ? Array.from(files) : [];\r\n    }\r\n\r\n    /**\r\n     * Get nested value from object using dot notation path\r\n     */\r\n    private getNestedValue(obj: any, path: string): any {\r\n        const segments = path.split('.').filter(Boolean);\r\n        let current = obj;\r\n        for (const segment of segments) {\r\n            if (!current || typeof current !== 'object' || Array.isArray(current)) {\r\n                return undefined;\r\n            }\r\n            if (!Object.prototype.hasOwnProperty.call(current, segment)) {\r\n                return undefined;\r\n            }\r\n            current = current[segment];\r\n        }\r\n        return current;\r\n    }\r\n\r\n    /**\r\n     * Clear all caches\r\n     */\r\n    clear(): void {\r\n        this.localeFilesCache.clear();\r\n        this.headContentCache.clear();\r\n        this.commitContentCache.clear();\r\n        this.gitHistoryCache.clear();\r\n        this.sourceFileKeyIndex.clear();\r\n        this.initialized = false;\r\n        this.initPromise = null;\r\n    }\r\n}\r\n\r\n// Singleton instance per workspace folder\r\nconst cacheInstances = new Map<string, LocaleCache>();\r\n\r\nexport function getLocaleCache(folder: vscode.WorkspaceFolder, log?: vscode.OutputChannel): LocaleCache {\r\n    const key = folder.uri.toString();\r\n    if (!cacheInstances.has(key)) {\r\n        cacheInstances.set(key, new LocaleCache(folder, log));\r\n    }\r\n    return cacheInstances.get(key)!;\r\n}\r\n\r\nexport function clearLocaleCaches(): void {\r\n    for (const cache of cacheInstances.values()) {\r\n        cache.clear();\r\n    }\r\n    cacheInstances.clear();\r\n}\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\untranslated\\utils\\operationLock.ts","messages":[{"ruleId":"@typescript-eslint/no-empty-function","severity":2,"message":"Unexpected empty constructor.","line":49,"column":27,"nodeType":"FunctionExpression","messageId":"unexpected","endLine":49,"endColumn":29},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":334,"column":32,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":334,"endColumn":49}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\r\n\r\n/**\r\n * Operation types for categorizing locks\r\n */\r\nexport type OperationType = \r\n    | 'translation-project'\r\n    | 'translation-file'\r\n    | 'cleanup-unused'\r\n    | 'cleanup-invalid'\r\n    | 'key-management'\r\n    | 'style-fix';\r\n\r\ninterface OperationState {\r\n    type: OperationType;\r\n    description: string;\r\n    startTime: number;\r\n    cancellationToken?: vscode.CancellationTokenSource;\r\n}\r\n\r\n/**\r\n * File-level lock entry\r\n */\r\ninterface FileLock {\r\n    uri: string;\r\n    holder: OperationType;\r\n    timestamp: number;\r\n}\r\n\r\n/**\r\n * Singleton class managing operation locks to prevent race conditions\r\n * between concurrent i18n operations that modify locale files.\r\n */\r\nclass OperationLockManager {\r\n    private static instance: OperationLockManager;\r\n    \r\n    private globalLock: OperationState | null = null;\r\n    private fileLocks = new Map<string, FileLock>();\r\n    private waitingOperations: Array<{\r\n        resolve: () => void;\r\n        reject: (err: Error) => void;\r\n        type: OperationType;\r\n    }> = [];\r\n    \r\n    private readonly lockTimeout = 300000; // 5 minutes max lock duration\r\n    private readonly fileWriteDelay = 50; // ms delay between consecutive file writes\r\n    private lastFileWrite = 0;\r\n\r\n    private constructor() {}\r\n\r\n    static getInstance(): OperationLockManager {\r\n        if (!OperationLockManager.instance) {\r\n            OperationLockManager.instance = new OperationLockManager();\r\n        }\r\n        return OperationLockManager.instance;\r\n    }\r\n\r\n    /**\r\n     * Check if a global operation is currently running\r\n     */\r\n    isOperationRunning(): boolean {\r\n        if (!this.globalLock) return false;\r\n        \r\n        // Auto-release stale locks\r\n        if (Date.now() - this.globalLock.startTime > this.lockTimeout) {\r\n            console.warn(`AI Localizer: Auto-releasing stale lock for ${this.globalLock.type}`);\r\n            this.releaseGlobalLock(this.globalLock.type);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get the current operation state if any\r\n     */\r\n    getCurrentOperation(): OperationState | null {\r\n        if (!this.isOperationRunning()) return null;\r\n        return this.globalLock;\r\n    }\r\n\r\n    /**\r\n     * Get human-readable description of the blocking operation\r\n     */\r\n    getBlockingOperationMessage(): string {\r\n        const op = this.getCurrentOperation();\r\n        if (!op) return '';\r\n        \r\n        const elapsed = Math.round((Date.now() - op.startTime) / 1000);\r\n        return `\"${op.description}\" is in progress (${elapsed}s elapsed)`;\r\n    }\r\n\r\n    /**\r\n     * Acquire global lock for a major operation.\r\n     * Returns true if lock acquired, false if another operation is running.\r\n     */\r\n    async acquireGlobalLock(\r\n        type: OperationType,\r\n        description: string,\r\n        options?: { \r\n            wait?: boolean; \r\n            timeout?: number;\r\n            cancellationToken?: vscode.CancellationTokenSource;\r\n        }\r\n    ): Promise<boolean> {\r\n        // Clean up stale locks first\r\n        this.cleanupStaleLocks();\r\n\r\n        if (!this.globalLock) {\r\n            this.globalLock = {\r\n                type,\r\n                description,\r\n                startTime: Date.now(),\r\n                cancellationToken: options?.cancellationToken,\r\n            };\r\n            return true;\r\n        }\r\n\r\n        // Same operation type can proceed (nested calls)\r\n        if (this.globalLock.type === type) {\r\n            return true;\r\n        }\r\n\r\n        if (!options?.wait) {\r\n            return false;\r\n        }\r\n\r\n        // Wait for lock to become available\r\n        const timeout = options.timeout || 30000;\r\n        return new Promise((resolve, reject) => {\r\n            const timeoutId = setTimeout(() => {\r\n                const idx = this.waitingOperations.findIndex(\r\n                    (w) => w.resolve === resolve\r\n                );\r\n                if (idx !== -1) {\r\n                    this.waitingOperations.splice(idx, 1);\r\n                }\r\n                reject(new Error(`Timeout waiting for lock: ${this.getBlockingOperationMessage()}`));\r\n            }, timeout);\r\n\r\n            this.waitingOperations.push({\r\n                resolve: () => {\r\n                    clearTimeout(timeoutId);\r\n                    this.globalLock = {\r\n                        type,\r\n                        description,\r\n                        startTime: Date.now(),\r\n                        cancellationToken: options?.cancellationToken,\r\n                    };\r\n                    resolve(true);\r\n                },\r\n                reject: (err) => {\r\n                    clearTimeout(timeoutId);\r\n                    reject(err);\r\n                },\r\n                type,\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Release global lock\r\n     */\r\n    releaseGlobalLock(type: OperationType): void {\r\n        if (this.globalLock?.type === type) {\r\n            this.globalLock = null;\r\n            \r\n            // Notify next waiting operation\r\n            const next = this.waitingOperations.shift();\r\n            if (next) {\r\n                setImmediate(() => next.resolve());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Acquire file-level lock for writing\r\n     */\r\n    async acquireFileLock(uri: vscode.Uri, holder: OperationType): Promise<boolean> {\r\n        const key = uri.toString();\r\n        const existing = this.fileLocks.get(key);\r\n        \r\n        if (existing) {\r\n            // Check if lock is stale (> 30 seconds)\r\n            if (Date.now() - existing.timestamp > 30000) {\r\n                console.warn(`AI Localizer: Releasing stale file lock for ${uri.fsPath}`);\r\n                this.fileLocks.delete(key);\r\n            } else if (existing.holder !== holder) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Throttle consecutive file writes to prevent overwhelming the file system\r\n        const now = Date.now();\r\n        const timeSinceLastWrite = now - this.lastFileWrite;\r\n        if (timeSinceLastWrite < this.fileWriteDelay) {\r\n            await new Promise(resolve => setTimeout(resolve, this.fileWriteDelay - timeSinceLastWrite));\r\n        }\r\n\r\n        this.fileLocks.set(key, {\r\n            uri: key,\r\n            holder,\r\n            timestamp: Date.now(),\r\n        });\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Release file-level lock\r\n     */\r\n    releaseFileLock(uri: vscode.Uri): void {\r\n        this.lastFileWrite = Date.now();\r\n        this.fileLocks.delete(uri.toString());\r\n    }\r\n\r\n    /**\r\n     * Execute a function with file lock protection\r\n     */\r\n    async withFileLock<T>(\r\n        uri: vscode.Uri,\r\n        holder: OperationType,\r\n        fn: () => Promise<T>\r\n    ): Promise<T> {\r\n        const acquired = await this.acquireFileLock(uri, holder);\r\n        if (!acquired) {\r\n            throw new Error(`Cannot acquire file lock for ${uri.fsPath}`);\r\n        }\r\n        try {\r\n            return await fn();\r\n        } finally {\r\n            this.releaseFileLock(uri);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Execute a function with global lock protection\r\n     */\r\n    async withGlobalLock<T>(\r\n        type: OperationType,\r\n        description: string,\r\n        fn: (token?: vscode.CancellationToken) => Promise<T>,\r\n        options?: {\r\n            showBlockingMessage?: boolean;\r\n            cancellable?: boolean;\r\n        }\r\n    ): Promise<T | null> {\r\n        const cancellationToken = options?.cancellable \r\n            ? new vscode.CancellationTokenSource() \r\n            : undefined;\r\n\r\n        const acquired = await this.acquireGlobalLock(type, description, {\r\n            cancellationToken,\r\n        });\r\n\r\n        if (!acquired) {\r\n            if (options?.showBlockingMessage !== false) {\r\n                const blockingMsg = this.getBlockingOperationMessage();\r\n                vscode.window.showWarningMessage(\r\n                    `AI Localizer: Cannot start \"${description}\" - ${blockingMsg}. Please wait for it to complete or cancel it.`\r\n                );\r\n            }\r\n            return null;\r\n        }\r\n\r\n        try {\r\n            return await fn(cancellationToken?.token);\r\n        } finally {\r\n            this.releaseGlobalLock(type);\r\n            cancellationToken?.dispose();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clean up stale locks\r\n     */\r\n    private cleanupStaleLocks(): void {\r\n        const now = Date.now();\r\n        \r\n        // Clean stale file locks\r\n        for (const [key, lock] of this.fileLocks.entries()) {\r\n            if (now - lock.timestamp > 30000) {\r\n                this.fileLocks.delete(key);\r\n            }\r\n        }\r\n\r\n        // Clean stale global lock\r\n        if (this.globalLock && now - this.globalLock.startTime > this.lockTimeout) {\r\n            console.warn(`AI Localizer: Auto-releasing stale global lock for ${this.globalLock.type}`);\r\n            this.globalLock = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force release all locks (emergency cleanup)\r\n     */\r\n    forceReleaseAll(): void {\r\n        this.globalLock = null;\r\n        this.fileLocks.clear();\r\n        \r\n        // Reject all waiting operations\r\n        for (const waiting of this.waitingOperations) {\r\n            waiting.reject(new Error('All locks force released'));\r\n        }\r\n        this.waitingOperations = [];\r\n    }\r\n\r\n    /**\r\n     * Get lock statistics for debugging\r\n     */\r\n    getStats(): { globalLock: OperationState | null; fileLockCount: number; waitingCount: number } {\r\n        return {\r\n            globalLock: this.globalLock,\r\n            fileLockCount: this.fileLocks.size,\r\n            waitingCount: this.waitingOperations.length,\r\n        };\r\n    }\r\n}\r\n\r\n// Export singleton instance\r\nexport const operationLock = OperationLockManager.getInstance();\r\n\r\n/**\r\n * Decorator/helper to wrap async operations with lock protection\r\n */\r\nexport function withOperationLock<T extends (...args: any[]) => Promise<any>>(\r\n    type: OperationType,\r\n    description: string | ((...args: Parameters<T>) => string),\r\n    options?: { showBlockingMessage?: boolean }\r\n) {\r\n    return function (\r\n        _target: any,\r\n        _propertyKey: string,\r\n        descriptor: TypedPropertyDescriptor<T>\r\n    ) {\r\n        const originalMethod = descriptor.value!;\r\n        \r\n        descriptor.value = async function (this: any, ...args: Parameters<T>) {\r\n            const desc = typeof description === 'function' \r\n                ? description(...args) \r\n                : description;\r\n\r\n            const result = await operationLock.withGlobalLock(\r\n                type,\r\n                desc,\r\n                () => originalMethod.apply(this, args),\r\n                options\r\n            );\r\n            \r\n            return result;\r\n        } as T;\r\n        \r\n        return descriptor;\r\n    };\r\n}\r\n\r\n/**\r\n * Check if operation can proceed, showing warning if blocked\r\n */\r\nexport async function canProceedWithOperation(\r\n    type: OperationType,\r\n    description: string\r\n): Promise<boolean> {\r\n    if (!operationLock.isOperationRunning()) {\r\n        return true;\r\n    }\r\n\r\n    const current = operationLock.getCurrentOperation();\r\n    if (current?.type === type) {\r\n        // Same operation type - allow nested calls\r\n        return true;\r\n    }\r\n\r\n    const blockingMsg = operationLock.getBlockingOperationMessage();\r\n    const choice = await vscode.window.showWarningMessage(\r\n        `AI Localizer: Cannot start \"${description}\" - ${blockingMsg}.`,\r\n        'Wait',\r\n        'Cancel'\r\n    );\r\n\r\n    return choice === 'Wait';\r\n}\r\n\r\n\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\commands\\untranslated\\utils\\textAnalysis.ts","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\-.","line":37,"column":41,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":37,"endColumn":42,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1107,1108],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1107,1107],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'hasSpaces' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":152,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":152,"endColumn":20}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Compute Levenshtein edit distance between two strings\n * Optimized with single-row DP array\n */\nexport function computeEditDistance(a: string, b: string): number {\n    const m = a.length;\n    const n = b.length;\n    if (!m) return n;\n    if (!n) return m;\n    const dp: number[] = [];\n    for (let j = 0; j <= n; j += 1) dp[j] = j;\n    for (let i = 1; i <= m; i += 1) {\n        let prev = dp[0];\n        dp[0] = i;\n        for (let j = 1; j <= n; j += 1) {\n            const temp = dp[j];\n            if (a[i - 1] === b[j - 1]) {\n                dp[j] = prev;\n            } else {\n                const add = dp[j - 1] + 1;\n                const del = dp[j] + 1;\n                const sub = prev + 1;\n                dp[j] = add < del ? (add < sub ? add : sub) : del < sub ? del : sub;\n            }\n            prev = temp;\n        }\n    }\n    return dp[n];\n}\n\n/**\n * Build a human-readable label from a key segment\n * e.g., \"user_profile\" -> \"User profile\"\n */\nexport function buildLabelFromKeySegment(segment: string): string {\n    if (!segment) return '';\n    const replaced = segment.replace(/[_\\-]+/g, ' ');\n    const parts = replaced.split(/\\s+/).filter(Boolean);\n    if (!parts.length) return '';\n    return parts\n        .map((p, index) => {\n            const lower = p.toLowerCase();\n            if (index === 0) {\n                return lower.charAt(0).toUpperCase() + lower.slice(1);\n            }\n            return lower;\n        })\n        .join(' ');\n}\n\n/**\n * Check if a string looks like CSS classes (Tailwind, etc.)\n */\nexport function looksLikeCssClasses(str: string): boolean {\n    const trimmed = str.trim();\n    if (!trimmed) return false;\n\n    const cssPatterns = [\n        /^[a-z]+-[a-z0-9-]+(\\s+[a-z]+-[a-z0-9-]+)*$/i,\n        /\\b(flex|grid|block|inline|hidden|absolute|relative|fixed)\\b/,\n        /\\b(w-|h-|p-|m-|px-|py-|mx-|my-|pt-|pb-|pl-|pr-|mt-|mb-|ml-|mr-)/,\n        /\\b(text-|bg-|border-|rounded|shadow|overflow|cursor|opacity)/,\n        /\\b(sm:|md:|lg:|xl:|2xl:|hover:|focus:|active:|dark:)/,\n        /\\b(justify-|items-|self-|gap-|space-)/,\n        /\\b(font-|leading-|tracking-)/,\n        /\\b(z-\\d|top-|bottom-|left-|right-)/,\n        /^[a-z][a-z0-9]*(-[a-z0-9]+)+(\\s|$)/,\n    ];\n\n    for (const pattern of cssPatterns) {\n        if (pattern.test(trimmed)) {\n            return true;\n        }\n    }\n\n    const tokens = trimmed.split(/\\s+/);\n    if (tokens.length >= 2) {\n        const cssLikeTokens = tokens.filter(t =>\n            /^[a-z][a-z0-9]*(-[a-z0-9]+)+$/i.test(t) ||\n            /^(sm|md|lg|xl|2xl|hover|focus|dark):/.test(t)\n        );\n        if (cssLikeTokens.length / tokens.length >= 0.5) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Check if a string looks like a code identifier or technical pattern\n */\nexport function looksLikeCodePattern(str: string): boolean {\n    const trimmed = str.trim();\n    \n    // Identifiers with underscores or alphanumerics (case-insensitive)\n    // Covers snake_case, CONSTANT_CASE, and mixed-case with underscores (e.g., Error_Message)\n    if (/^[a-z_][a-z0-9_]*$/i.test(trimmed) && !trimmed.includes(' ')) return true;\n    if (/^[A-Z_][A-Z0-9_]*$/i.test(trimmed) && !trimmed.includes(' ')) return true;\n    \n    // camelCase or PascalCase identifiers (without spaces)\n    if (/^[a-z][a-zA-Z0-9]*$/.test(trimmed) && !trimmed.includes(' ')) return true;\n    \n    // File paths and URLs\n    if (/^(https?:|mailto:|tel:|\\/\\/|www\\.)/.test(trimmed)) return true;\n    if (/^[./\\\\]/.test(trimmed)) return true;\n    if (/\\.(ts|tsx|js|jsx|vue|json|css|scss|html|php|blade\\.php)$/i.test(trimmed)) return true;\n    \n    // Template expressions\n    if (/^\\$\\{.*\\}$/.test(trimmed)) return true;\n    if (/^\\{\\{.*\\}\\}$/.test(trimmed)) return true;\n    \n    // Intent/scheme patterns (Android) — anchor each alternative\n    if (/^(intent:|scheme=|#Intent)/.test(trimmed)) return true;\n    \n    // Event names\n    if (/^on[A-Z][a-zA-Z]*$/.test(trimmed)) return true;\n    \n    // HTML/JSX element names\n    if (/^[a-z]+-[a-z-]+$/.test(trimmed)) return true;\n    \n    // Pure numbers or hex colors\n    if (/^#[0-9a-fA-F]{3,8}$/.test(trimmed)) return true;\n    if (/^-?\\d+(\\.\\d+)?$/.test(trimmed)) return true;\n    \n    // JSON/object keys\n    if (/^[a-zA-Z_$][a-zA-Z0-9_$]*:$/.test(trimmed)) return true;\n    \n    // Import/export paths\n    if (/^@\\/|^\\.\\.?\\/|^~\\//.test(trimmed)) return true;\n    \n    return false;\n}\n\n/**\n * Check if a string looks like actual user-facing text\n */\nexport function looksLikeUserText(str: string): boolean {\n    const trimmed = str.trim();\n    if (!trimmed || trimmed.length < 2) return false;\n\n    // Must contain at least one letter\n    if (!/[a-zA-Z]/.test(trimmed)) return false;\n    \n    // Reject CSS classes\n    if (looksLikeCssClasses(trimmed)) return false;\n    \n    // Reject code patterns\n    if (looksLikeCodePattern(trimmed)) return false;\n\n    // Positive indicators\n    const hasSpaces = trimmed.includes(' ');\n    const startsWithCapital = /^[A-Z]/.test(trimmed);\n    const hasSentencePunctuation = /[.!?:]$/.test(trimmed);\n    const hasCommonWords = /\\b(the|and|or|to|is|are|was|has|have|this|that|your|our|please|click|tap|select|add|save|cancel|delete|edit|view|open|close|enter|submit|confirm|error|success|warning|loading|welcome|hello|hi|thanks|sorry|oops|done|next|back|continue|finish|start|stop|pause|play|search|find|filter|sort|show|hide|enable|disable|on|off|yes|no|ok|failed|try|again)\\b/i.test(trimmed);\n    const hasPlaceholder = /\\{[a-zA-Z_][a-zA-Z0-9_]*\\}/.test(trimmed);\n    const hasUserTextPattern = /[A-Z][a-z]+(\\s+[a-z]+)+/.test(trimmed);\n    \n    // Multi-word phrases are likely user text\n    const wordCount = trimmed.split(/\\s+/).filter(w => w.length > 0).length;\n    if (wordCount >= 2) return true;\n    \n    return startsWithCapital || hasSentencePunctuation || hasCommonWords || hasPlaceholder || hasUserTextPattern;\n}\n\n/**\n * Calculate text relevance score based on hint words\n */\nexport function calculateTextRelevanceScore(text: string, hintWords: string[]): number {\n    let score = 0;\n    const textLower = text.toLowerCase();\n\n    for (const hint of hintWords) {\n        if (textLower.includes(hint)) {\n            score += 10;\n        }\n    }\n\n    if (/^[A-Z]/.test(text)) score += 2;\n    if (/[.!?]$/.test(text)) score += 2;\n    if (text.includes(' ')) score += 1;\n    if (text.length >= 5 && text.length <= 100) score += 2;\n\n    return score;\n}\n\nfunction derivePlaceholderName(expr: string): string {\n    const tokens = expr\n        .trim()\n        .replace(/\\s+/g, ' ')\n        .split(/[^A-Za-z0-9_]+/)\n        .filter(Boolean);\n\n    if (tokens.length === 0) return 'value';\n    const candidate = tokens[tokens.length - 1].replace(/^\\d+/, '');\n    return (candidate || 'value').toLowerCase();\n}\n\n/**\n * Normalize a template literal by converting ${...} expressions to {placeholder}\n */\nexport function normalizeTemplateLiteral(content: string): string | null {\n    if (!content) return null;\n\n    const pieces: string[] = [];\n    let lastIndex = 0;\n    const exprPattern = /\\$\\{([^}]+)\\}/g;\n    let match;\n    let placeholderIndex = 1; // CRITICAL: Use generic value1, value2, etc. for consistency\n    const usedNames = new Set<string>();\n\n    while ((match = exprPattern.exec(content)) !== null) {\n        const staticText = content.slice(lastIndex, match.index);\n        if (staticText) {\n            pieces.push(staticText);\n        }\n\n        const expr = match[1] || '';\n\n        // Prefer a derived name from the expression when possible\n        let baseName = derivePlaceholderName(expr);\n        if (!baseName || baseName === 'value') {\n            // Fall back to generic value1, value2, etc. when we cannot infer a better name\n            baseName = `value${placeholderIndex}`;\n        }\n\n        // Ensure placeholder names are unique within this template\n        let uniqueName = baseName;\n        let counter = 2;\n        while (usedNames.has(uniqueName)) {\n            uniqueName = `${baseName}${counter}`;\n            counter += 1;\n        }\n        usedNames.add(uniqueName);\n\n        pieces.push(`{${uniqueName}}`);\n        placeholderIndex++;\n        lastIndex = match.index + match[0].length;\n    }\n\n    if (lastIndex < content.length) {\n        pieces.push(content.slice(lastIndex));\n    }\n\n    const normalized = pieces.join('').replace(/\\s+/g, ' ').trim();\n    if (!/[a-zA-Z]/.test(normalized)) return null;\n\n    // Drop placeholders to ensure there's real user-facing text\n    const withoutPlaceholders = normalized.replace(/\\{[a-zA-Z_][a-zA-Z0-9_]*\\}/g, ' ').trim();\n    if (!withoutPlaceholders || !/[a-zA-Z]/.test(withoutPlaceholders)) {\n        return null;\n    }\n\n    return normalized;\n}\n\n/**\n * Extract all user-facing text from source content with relevance scoring\n */\nexport function extractAllUserTextFromContent(\n    content: string,\n    hintWords: string[],\n): Array<{ text: string; score: number }> {\n    const candidates: Array<{ text: string; score: number }> = [];\n    const seenTexts = new Set<string>();\n\n    const addCandidate = (text: string, bonusScore: number = 0) => {\n        const trimmed = text.trim();\n        if (!trimmed || seenTexts.has(trimmed)) return;\n        if (!looksLikeUserText(trimmed)) return;\n        \n        seenTexts.add(trimmed);\n        const score = calculateTextRelevanceScore(trimmed, hintWords) + bonusScore;\n        candidates.push({ text: trimmed, score });\n    };\n\n    // 1. JSX text content between tags\n    const jsxTextPattern = />([^<>{]+)</g;\n    let match;\n    while ((match = jsxTextPattern.exec(content)) !== null) {\n        addCandidate(match[1], 2);\n    }\n\n    // 2. JSX text props with high priority\n    const propPatterns = [\n        /\\b(title|placeholder|alt|label|message|description|header|tooltip)\\s*=\\s*[\"']([^\"']+)[\"']/gi,\n        /\\b(aria-label|aria-description)\\s*=\\s*[\"']([^\"']+)[\"']/gi,\n        /\\b(buttonText|submitText|cancelText|confirmText|errorText|helperText)\\s*=\\s*[\"']([^\"']+)[\"']/gi,\n    ];\n    for (const pattern of propPatterns) {\n        pattern.lastIndex = 0;\n        while ((match = pattern.exec(content)) !== null) {\n            addCandidate(match[2], 5);\n        }\n    }\n\n    // 3. Vue template interpolations (non-expression)\n    const vueInterpolation = /\\{\\{\\s*['\"]([^'\"{}]+)['\"]\\s*\\}\\}/g;\n    while ((match = vueInterpolation.exec(content)) !== null) {\n        addCandidate(match[1], 4);\n    }\n\n    // 4. Template literals with text (not pure expressions)\n    const templateLiteralPattern = /`([^`]+)`/g;\n    while ((match = templateLiteralPattern.exec(content)) !== null) {\n        const normalized = normalizeTemplateLiteral(match[1]);\n        if (normalized) {\n            addCandidate(normalized, 4);\n        } else {\n            const raw = match[1].trim();\n            if (raw) {\n                addCandidate(raw, 1);\n            }\n        }\n    }\n\n    // 5. String literals (excluding className and style assignments)\n    const stringContexts = content.split('\\n');\n    for (const line of stringContexts) {\n        // Skip className/style lines\n        if (/className\\s*=|style\\s*=|styles\\.|classes\\./.test(line)) continue;\n        \n        // Extract double-quoted strings\n        const doubleQuoted = /\"([^\"\\\\]|\\\\.){3,}\"/g;\n        while ((match = doubleQuoted.exec(line)) !== null) {\n            const text = match[0].slice(1, -1).replace(/\\\\\"/g, '\"').replace(/\\\\n/g, ' ');\n            addCandidate(text, 0);\n        }\n        \n        // Extract single-quoted strings\n        const singleQuoted = /'([^'\\\\]|\\\\.){3,}'/g;\n        while ((match = singleQuoted.exec(line)) !== null) {\n            const text = match[0].slice(1, -1).replace(/\\\\'/g, \"'\").replace(/\\\\n/g, ' ');\n            addCandidate(text, 0);\n        }\n    }\n\n    // 6. Object property values that look like labels\n    const objectPropPattern = /(?:text|label|title|message|description|placeholder|content|header|tooltip|buttonText|errorMessage|successMessage):\\s*[\"']([^\"']+)[\"']/gi;\n    while ((match = objectPropPattern.exec(content)) !== null) {\n        addCandidate(match[1], 4);\n    }\n\n    // 7. Function call arguments that look like user text\n    const funcCallPattern = /(?:showMessage|showError|showSuccess|toast|alert|confirm|notify|setError|setMessage|setTitle)\\s*\\(\\s*[\"']([^\"']+)[\"']/gi;\n    while ((match = funcCallPattern.exec(content)) !== null) {\n        addCandidate(match[1], 6);\n    }\n\n    return candidates;\n}\n\n/**\n * Extract hardcoded string from a line of source code\n */\nexport function extractHardcodedStringFromLine(line: string, key: string): string | null {\n    const keyParts = key.split('.').filter(Boolean);\n    const keyHint = keyParts[keyParts.length - 1]?.toLowerCase() || '';\n\n    const hintWords = keyHint\n        .replace(/([a-z])([A-Z])/g, '$1 $2')\n        .replace(/[_-]/g, ' ')\n        .toLowerCase()\n        .split(/\\s+/)\n        .filter(w => w.length > 2);\n\n    // Skip lines that are className/style assignments\n    if (/className\\s*=|style\\s*=|styles\\[|classes\\[/.test(line)) {\n        return null;\n    }\n\n    const candidates: Array<{ text: string; score: number }> = [];\n\n    // Extract double-quoted strings\n    const doubleQuotePattern = /\"((?:[^\"\\\\]|\\\\.)*)\"/g;\n    let match;\n    while ((match = doubleQuotePattern.exec(line)) !== null) {\n        const str = match[1].replace(/\\\\\"/g, '\"').replace(/\\\\n/g, ' ').trim();\n        processCandidate(str, hintWords, candidates);\n    }\n\n    // Extract single-quoted strings\n    const singleQuotePattern = /'((?:[^'\\\\]|\\\\.)*)'/g;\n    while ((match = singleQuotePattern.exec(line)) !== null) {\n        const str = match[1].replace(/\\\\'/g, \"'\").replace(/\\\\n/g, ' ').trim();\n        processCandidate(str, hintWords, candidates);\n    }\n\n    // Extract JSX text content (between > and <)\n    const jsxTextPattern = />([^<>{]+)</g;\n    while ((match = jsxTextPattern.exec(line)) !== null) {\n        const str = match[1].trim();\n        if (str) {\n            processCandidate(str, hintWords, candidates, 3); // Bonus for JSX text\n        }\n    }\n\n    // Extract template literal static parts\n    const templatePattern = /`([^`]+)`/g;\n    while ((match = templatePattern.exec(line)) !== null) {\n        const normalized = normalizeTemplateLiteral(match[1]);\n        if (normalized) {\n            processCandidate(normalized, hintWords, candidates, 4);\n        } else {\n            const str = match[1].trim();\n            processCandidate(str, hintWords, candidates);\n        }\n    }\n\n    if (candidates.length === 0) return null;\n\n    candidates.sort((a, b) => {\n        if (b.score !== a.score) return b.score - a.score;\n        return b.text.length - a.text.length;\n    });\n\n    const best = candidates[0];\n    // Lower threshold but require at least some positive signal\n    if (best.score >= 3 || (candidates.length === 1 && looksLikeUserText(best.text))) {\n        return best.text;\n    }\n\n    return null;\n}\n\n/**\n * Process a candidate string and add to candidates list if valid\n */\nfunction processCandidate(\n    str: string,\n    hintWords: string[],\n    candidates: Array<{ text: string; score: number }>,\n    bonusScore: number = 0,\n): void {\n    if (!str || str.length < 2) return;\n    if (!looksLikeUserText(str)) return;\n\n    let score = bonusScore;\n    const strLower = str.toLowerCase();\n\n    // Score based on hint word matches\n    for (const hintWord of hintWords) {\n        if (strLower.includes(hintWord)) {\n            score += 10;\n        }\n    }\n\n    // Bonus for sentence-like structure\n    if (/^[A-Z]/.test(str)) score += 2;\n    if (/[.!?:]$/.test(str)) score += 2;\n    if (str.includes(' ')) score += 2;\n    \n    // Bonus for appropriate length\n    if (str.length >= 5 && str.length <= 150) score += 2;\n    \n    // Bonus for word count (multi-word phrases are more likely user text)\n    const wordCount = str.split(/\\s+/).filter(w => w.length > 0).length;\n    if (wordCount >= 2) score += 3;\n    if (wordCount >= 3) score += 2;\n    \n    // Bonus for containing common UI words\n    if (/\\b(please|click|tap|select|enter|submit|cancel|save|delete|edit|view|loading|error|success|warning)\\b/i.test(str)) {\n        score += 3;\n    }\n\n    // Penalty for looking like code\n    if (/^\\w+\\(/.test(str) || /^[a-z][a-zA-Z0-9]*$/.test(str)) {\n        score -= 5;\n    }\n\n    candidates.push({ text: str, score });\n}\n\n/**\n * Generate key path variations for searching\n */\nexport function getKeyPathVariations(key: string): string[] {\n    const variations: string[] = [key];\n    const parts = key.split('.').filter(Boolean);\n\n    if (parts.length > 1) {\n        variations.push(parts.slice(1).join('.'));\n        if (parts.length > 2) {\n            variations.push(parts.slice(2).join('.'));\n        }\n        variations.push(parts[parts.length - 1]);\n        if (parts.length > 2) {\n            variations.push(parts.slice(-2).join('.'));\n        }\n    }\n\n    return variations;\n}\n\n/**\n * Escape special regex characters in a string\n */\nexport function escapeRegExp(str: string): string {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\n/**\n * Extract hint words from a key for semantic matching\n */\nexport function extractHintWords(key: string): string[] {\n    const keyParts = key.split('.').filter(Boolean);\n    const lastPart = keyParts[keyParts.length - 1] || '';\n    return lastPart\n        .replace(/([a-z])([A-Z])/g, '$1 $2')\n        .replace(/[_-]/g, ' ')\n        .toLowerCase()\n        .split(/\\s+/)\n        .filter(w => w.length > 2);\n}\n\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\core\\autoMonitor.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'MIN_INTERVAL_BETWEEN_RUNS' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":19,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\r\nimport * as path from 'path';\r\nimport { isFileClean } from './gitMonitor';\r\nimport { runI18nScript } from './workspace';\r\nimport { getGranularSyncService } from '../services/granularSyncService';\r\n\r\ninterface MonitorState {\r\n    lastExtractTime: number;\r\n    lastRewriteTime: number;\r\n    lastPromptTime: number;\r\n    pendingFiles: Set<string>;\r\n    isProcessing: boolean;\r\n    promptDismissedThisSession: boolean;\r\n    outdatedScriptsChecked: boolean;\r\n}\r\n\r\nconst DEBOUNCE_DELAY = 5000; // 5 seconds - increased to reduce prompt frequency\r\nconst MIN_INTERVAL_BETWEEN_PROMPTS = 300000; // 5 minutes - minimum time between showing prompts\r\nconst MIN_INTERVAL_BETWEEN_RUNS = 30000; // 30 seconds - minimum time between actual runs\r\n\r\nexport class AutoMonitor {\r\n    private states = new Map<string, MonitorState>();\r\n    private disposables: vscode.Disposable[] = [];\r\n    private debounceTimers = new Map<string, NodeJS.Timeout>();\r\n\r\n    constructor() {\r\n        this.setupFileWatcher();\r\n        this.setupGitWatcher();\r\n        this.setupWorkspaceOpenHandler();\r\n    }\r\n\r\n    private setupFileWatcher(): void {\r\n        // Watch for file saves\r\n        const saveWatcher = vscode.workspace.onDidSaveTextDocument(async (document) => {\r\n            await this.handleFileSave(document);\r\n        });\r\n\r\n        this.disposables.push(saveWatcher);\r\n    }\r\n\r\n    private setupWorkspaceOpenHandler(): void {\r\n        // Check for outdated scripts when workspace is opened\r\n        const openHandler = vscode.workspace.onDidChangeWorkspaceFolders(async (event) => {\r\n            for (const folder of event.added) {\r\n                await this.checkForOutdatedScripts(folder);\r\n            }\r\n        });\r\n        \r\n        // Also check existing workspaces on startup\r\n        setTimeout(() => {\r\n            const folders = vscode.workspace.workspaceFolders || [];\r\n            for (const folder of folders) {\r\n                this.checkForOutdatedScripts(folder);\r\n            }\r\n        }, 2000); // Delay to allow VS Code to fully load\r\n        \r\n        this.disposables.push(openHandler);\r\n    }\r\n\r\n    private async checkForOutdatedScripts(folder: vscode.WorkspaceFolder): Promise<void> {\r\n        const folderKey = folder.uri.fsPath;\r\n        const state = this.getOrCreateState(folderKey);\r\n        \r\n        if (state.outdatedScriptsChecked) {\r\n            return; // Already checked for this folder in this session\r\n        }\r\n        \r\n        // Check if prompts are disabled for this project\r\n        const config = vscode.workspace.getConfiguration('i18nAI', folder.uri);\r\n        const promptsDisabled = config.get<boolean>('disablePrompts') || false;\r\n        \r\n        if (promptsDisabled) {\r\n            state.outdatedScriptsChecked = true;\r\n            return; // Prompts are disabled for this project\r\n        }\r\n        \r\n        state.outdatedScriptsChecked = true;\r\n        \r\n        try {\r\n            const outdatedScripts = await this.detectOutdatedScripts(folder);\r\n            if (outdatedScripts.length > 0) {\r\n                await this.promptToUpdateScripts(folder, outdatedScripts);\r\n            }\r\n        } catch (err) {\r\n            console.error('Failed to check for outdated scripts:', err);\r\n        }\r\n    }\r\n\r\n    private async detectOutdatedScripts(folder: vscode.WorkspaceFolder): Promise<string[]> {\r\n        const outdatedScripts: string[] = [];\r\n        \r\n        // Check package.json for old script patterns\r\n        const pkgUri = vscode.Uri.joinPath(folder.uri, 'package.json');\r\n        try {\r\n            const data = await vscode.workspace.fs.readFile(pkgUri);\r\n            const text = new TextDecoder('utf-8').decode(data);\r\n            const pkg = JSON.parse(text);\r\n            \r\n            if (!pkg.scripts) {\r\n                return outdatedScripts;\r\n            }\r\n\r\n            // Check for known outdated script patterns\r\n            const outdatedPatterns = [\r\n                { name: 'extract-i18n.js', pattern: /extract-i18n\\.js/ },\r\n                { name: 'replace-i18n.js', pattern: /replace-i18n\\.js/ },\r\n                { name: 'cleanup-i18n-unused.js', pattern: /cleanup-i18n-unused\\.js/ },\r\n                { name: 'babel-extract-i18n.js', pattern: /babel-extract-i18n\\.js/ },\r\n                { name: 'oxc-extract-i18n.js', pattern: /oxc-extract-i18n\\.js/ },\r\n                { name: 'babel-replace-i18n.js', pattern: /babel-replace-i18n\\.js/ },\r\n                { name: 'oxc-replace-i18n.js', pattern: /oxc-replace-i18n\\.js/ },\r\n                { name: 'fix-i18n-parens-in-code.js', pattern: /fix-i18n-parens-in-code\\.js/ },\r\n                { name: 'restore-i18n-invalid.js', pattern: /restore-i18n-invalid\\.js/ },\r\n                { name: 'rewrite-i18n-blade.js', pattern: /rewrite-i18n-blade\\.js/ },\r\n                { name: 'fix-untranslated.js', pattern: /fix-untranslated\\.js/ }\r\n            ];\r\n\r\n            for (const scriptName in pkg.scripts) {\r\n                const scriptContent = pkg.scripts[scriptName];\r\n                if (typeof scriptContent === 'string') {\r\n                    for (const pattern of outdatedPatterns) {\r\n                        if (pattern.pattern.test(scriptContent)) {\r\n                            outdatedScripts.push(`${scriptName}: ${pattern.name}`);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } catch {\r\n            // No package.json or invalid JSON\r\n            return outdatedScripts;\r\n        }\r\n\r\n        // Also check for actual script files in /scripts directory\r\n        const scriptsDir = vscode.Uri.joinPath(folder.uri, 'scripts');\r\n        try {\r\n            const entries = await vscode.workspace.fs.readDirectory(scriptsDir);\r\n            for (const [name, type] of entries) {\r\n                if (type === vscode.FileType.File) {\r\n                    // Check if it's an outdated script file\r\n                    const outdatedFilePatterns = [\r\n                        'extract-i18n.js',\r\n                        'replace-i18n.js', \r\n                        'cleanup-i18n-unused.js',\r\n                        'babel-extract-i18n.js',\r\n                        'oxc-extract-i18n.js',\r\n                        'babel-replace-i18n.js',\r\n                        'oxc-replace-i18n.js',\r\n                        'fix-i18n-parens-in-code.js',\r\n                        'restore-i18n-invalid.js',\r\n                        'rewrite-i18n-blade.js',\r\n                        'fix-untranslated.js'\r\n                    ];\r\n                    \r\n                    if (outdatedFilePatterns.some(pattern => name.includes(pattern))) {\r\n                        outdatedScripts.push(`scripts/${name}`);\r\n                    }\r\n                }\r\n            }\r\n        } catch {\r\n            // No scripts directory or can't read it\r\n        }\r\n\r\n        return outdatedScripts;\r\n    }\r\n\r\n    private async promptToUpdateScripts(folder: vscode.WorkspaceFolder, outdatedScripts: string[]): Promise<void> {\r\n        const choice = await vscode.window.showInformationMessage(\r\n            `AI Localizer: Detected ${outdatedScripts.length} outdated i18n script(s) in your project: ${outdatedScripts.slice(0, 3).join(', ')}${outdatedScripts.length > 3 ? '...' : ''}`,\r\n            {\r\n                title: 'Update Scripts',\r\n                description: 'Update to the latest i18n scripts and fix package.json',\r\n                action: 'update'\r\n            },\r\n            {\r\n                title: 'Ignore',\r\n                description: 'Skip updating for now',\r\n                action: 'ignore'\r\n            }\r\n        );\r\n\r\n        if (choice?.action === 'update') {\r\n            try {\r\n                await vscode.commands.executeCommand('ai-localizer.i18n.configureProject');\r\n                vscode.window.showInformationMessage(\r\n                    'AI Localizer: Project configuration opened. Please update your scripts to use the latest version.'\r\n                );\r\n            } catch (err) {\r\n                vscode.window.showErrorMessage(\r\n                    `Failed to open project configuration: ${err}`\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    private setupGitWatcher(): void {\r\n        const gitExtension = vscode.extensions.getExtension('vscode.git');\r\n        if (!gitExtension) {\r\n            return;\r\n        }\r\n\r\n        // Monitor when git extension becomes active\r\n        if (!gitExtension.isActive) {\r\n            void gitExtension.activate().then(() => {\r\n                this.subscribeToGitChanges(gitExtension);\r\n            }, (err: unknown) => {\r\n                console.error('Failed to activate git extension:', err);\r\n            });\r\n        } else {\r\n            this.subscribeToGitChanges(gitExtension);\r\n        }\r\n    }\r\n\r\n    private subscribeToGitChanges(gitExtension: vscode.Extension<any>): void {\r\n        try {\r\n            const git = gitExtension.exports.getAPI(1);\r\n            \r\n            // Listen to repository state changes\r\n            git.repositories.forEach((repo: any) => {\r\n                const stateDisposable = repo.state.onDidChange(() => {\r\n                    this.handleGitStateChange(repo);\r\n                });\r\n                this.disposables.push(stateDisposable);\r\n            });\r\n\r\n            // Listen for new repositories\r\n            const repoDisposable = git.onDidOpenRepository((repo: any) => {\r\n                const stateDisposable = repo.state.onDidChange(() => {\r\n                    this.handleGitStateChange(repo);\r\n                });\r\n                this.disposables.push(stateDisposable);\r\n            });\r\n\r\n            this.disposables.push(repoDisposable);\r\n        } catch (err) {\r\n            console.error('Failed to subscribe to git changes:', err);\r\n        }\r\n    }\r\n\r\n    private async handleFileSave(document: vscode.TextDocument): Promise<void> {\r\n        const config = vscode.workspace.getConfiguration('ai-localizer');\r\n        const autoMonitorEnabled = config.get<boolean>('i18n.autoMonitor', true);\r\n        \r\n        if (!autoMonitorEnabled) {\r\n            return;\r\n        }\r\n\r\n        // Check if prompts are disabled for this project\r\n        const i18nConfig = vscode.workspace.getConfiguration('i18nAI', document.uri);\r\n        const promptsDisabled = i18nConfig.get<boolean>('disablePrompts') || false;\r\n        \r\n        if (promptsDisabled) {\r\n            return; // Prompts are disabled for this project\r\n        }\r\n\r\n        // Only monitor relevant file types\r\n        const langId = document.languageId;\r\n        const isRelevant = [\r\n            'javascript',\r\n            'typescript',\r\n            'javascriptreact',\r\n            'typescriptreact',\r\n            'vue',\r\n            'blade',\r\n            'php',\r\n        ].includes(langId);\r\n\r\n        if (!isRelevant) {\r\n            return;\r\n        }\r\n\r\n        const folder = vscode.workspace.getWorkspaceFolder(document.uri);\r\n        if (!folder) {\r\n            return;\r\n        }\r\n\r\n        // Check if file has translation-eligible content\r\n        const hasTranslatableContent = await this.hasTranslatableContent(document);\r\n        if (!hasTranslatableContent) {\r\n            return;\r\n        }\r\n\r\n        // Add to pending files\r\n        const folderKey = folder.uri.fsPath;\r\n        const state = this.getOrCreateState(folderKey);\r\n        state.pendingFiles.add(document.uri.fsPath);\r\n\r\n        // Debounce the processing\r\n        this.scheduleProcessing(folder);\r\n    }\r\n\r\n    private async handleGitStateChange(repo: any): Promise<void> {\r\n        const config = vscode.workspace.getConfiguration('ai-localizer');\r\n        const autoMonitorEnabled = config.get<boolean>('i18n.autoMonitor', true);\r\n        \r\n        if (!autoMonitorEnabled) {\r\n            return;\r\n        }\r\n\r\n        // Check if prompts are disabled for this project\r\n        const i18nConfig = vscode.workspace.getConfiguration('i18nAI', repo.rootUri);\r\n        const promptsDisabled = i18nConfig.get<boolean>('disablePrompts') || false;\r\n        \r\n        if (promptsDisabled) {\r\n            return; // Prompts are disabled for this project\r\n        }\r\n\r\n        // Find workspace folder for this repo\r\n        const folders = vscode.workspace.workspaceFolders || [];\r\n        const folder = folders.find(f => f.uri.fsPath === repo.rootUri.fsPath);\r\n        \r\n        if (!folder) {\r\n            return;\r\n        }\r\n\r\n        // Check if working tree is clean (no staged or unstaged changes)\r\n        const state = repo.state;\r\n        const isClean = \r\n            (state.workingTreeChanges?.length || 0) === 0 &&\r\n            (state.indexChanges?.length || 0) === 0;\r\n\r\n        if (isClean) {\r\n            // Working tree is clean, check if we should run extraction/rewrite\r\n            await this.processCleanState(folder);\r\n        }\r\n    }\r\n\r\n    private async hasTranslatableContent(document: vscode.TextDocument): Promise<boolean> {\r\n        const text = document.getText();\r\n        \r\n        // Check for string literals that might be translatable\r\n        // Look for JSX text, template literals with text, or string literals\r\n        const patterns = [\r\n            />([^<>{}]+)</g,                    // JSX text content\r\n            /['\"`]([^'\"`]{3,})['\"`]/g,          // String literals (3+ chars)\r\n            /\\{\\s*['\"`]([^'\"`]{3,})['\"`]\\s*\\}/g, // Template expressions\r\n        ];\r\n\r\n        for (const pattern of patterns) {\r\n            const matches = text.match(pattern);\r\n            if (matches && matches.length > 0) {\r\n                // Filter out likely non-translatable strings (URLs, code, etc.)\r\n                const translatable = matches.some(match => {\r\n                    const cleaned = match.replace(/[<>{}'\"` ]/g, '');\r\n                    return (\r\n                        cleaned.length >= 3 &&\r\n                        !/^(https?|ftp|file):\\/\\//i.test(cleaned) &&\r\n                        !/^[a-z_][a-z0-9_]*$/i.test(cleaned) && // Not a variable name\r\n                        /[a-z]/i.test(cleaned) // Contains at least one letter\r\n                    );\r\n                });\r\n                \r\n                if (translatable) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private scheduleProcessing(folder: vscode.WorkspaceFolder): void {\r\n        const folderKey = folder.uri.fsPath;\r\n        \r\n        // Clear existing timer\r\n        const existingTimer = this.debounceTimers.get(folderKey);\r\n        if (existingTimer) {\r\n            clearTimeout(existingTimer);\r\n        }\r\n\r\n        // Schedule new processing\r\n        const timer = setTimeout(() => {\r\n            this.processPendingFiles(folder);\r\n        }, DEBOUNCE_DELAY);\r\n\r\n        this.debounceTimers.set(folderKey, timer);\r\n    }\r\n\r\n    private async processPendingFiles(folder: vscode.WorkspaceFolder): Promise<void> {\r\n        const folderKey = folder.uri.fsPath;\r\n        const state = this.getOrCreateState(folderKey);\r\n\r\n        if (state.isProcessing || state.pendingFiles.size === 0) {\r\n            return;\r\n        }\r\n\r\n        // Check if user has disabled auto-monitoring for this workspace\r\n        const config = vscode.workspace.getConfiguration('ai-localizer');\r\n        const autoExtract = config.get<boolean>('i18n.autoExtract', true);\r\n        const autoRewrite = config.get<boolean>('i18n.autoRewrite', true);\r\n        \r\n        // Check if prompts are disabled for this project\r\n        const i18nConfig = vscode.workspace.getConfiguration('i18nAI', folder.uri);\r\n        const promptsDisabled = i18nConfig.get<boolean>('disablePrompts') || false;\r\n        \r\n        if (promptsDisabled || (!autoExtract && !autoRewrite)) {\r\n            // User has disabled prompts or both auto features, don't show any prompts\r\n            state.pendingFiles.clear();\r\n            return;\r\n        }\r\n\r\n        // Check if enough time has passed since last prompt\r\n        const now = Date.now();\r\n        const timeSinceLastPrompt = now - state.lastPromptTime;\r\n        \r\n        // If user dismissed prompt this session, don't show again until next session\r\n        if (state.promptDismissedThisSession) {\r\n            state.pendingFiles.clear();\r\n            return;\r\n        }\r\n        \r\n        // Don't show prompts too frequently\r\n        if (timeSinceLastPrompt < MIN_INTERVAL_BETWEEN_PROMPTS) {\r\n            // Too soon, reschedule for later\r\n            setTimeout(() => this.processPendingFiles(folder), MIN_INTERVAL_BETWEEN_PROMPTS - timeSinceLastPrompt);\r\n            return;\r\n        }\r\n\r\n        state.isProcessing = true;\r\n\r\n        try {\r\n            // Check if all pending files are clean in git\r\n            const cleanFiles: string[] = [];\r\n            for (const filePath of state.pendingFiles) {\r\n                const fileUri = vscode.Uri.file(filePath);\r\n                const isClean = await isFileClean(folder, fileUri);\r\n                if (isClean) {\r\n                    cleanFiles.push(filePath);\r\n                }\r\n            }\r\n\r\n            if (cleanFiles.length === 0) {\r\n                // No clean files yet, wait for git state change\r\n                state.pendingFiles.clear();\r\n                return;\r\n            }\r\n\r\n            // Check if extraction/rewrite has been run before\r\n            const hasRunBefore = await this.hasRunBefore(folder);\r\n            \r\n            if (!hasRunBefore) {\r\n                // First time setup - don't auto-run, just notify\r\n                // But only if user hasn't explicitly disabled auto-extract/rewrite\r\n                vscode.window.showInformationMessage(\r\n                    `AI Localizer: Detected ${cleanFiles.length} file(s) with translatable content. Run \"AI Localizer: Configure Project i18n\" to set up auto-extraction.`,\r\n                    'Configure Now'\r\n                ).then(choice => {\r\n                    if (choice === 'Configure Now') {\r\n                        vscode.commands.executeCommand('ai-localizer.i18n.configureProject');\r\n                    }\r\n                });\r\n                state.pendingFiles.clear();\r\n                return;\r\n            }\r\n\r\n            // Auto-run extraction and rewrite\r\n            // Re-check config here in case it was updated during initial setup\r\n            const autoExtractCurrent = config.get<boolean>('i18n.autoExtract', true);\r\n            const autoRewriteCurrent = config.get<boolean>('i18n.autoRewrite', true);\r\n\r\n            if (autoExtractCurrent || autoRewriteCurrent) {\r\n                const scriptsLabel = autoExtractCurrent && autoRewriteCurrent\r\n                    ? 'i18n:extract and i18n:rewrite'\r\n                    : autoExtractCurrent\r\n                        ? 'i18n:extract'\r\n                        : 'i18n:rewrite';\r\n\r\n                const relativeFiles = cleanFiles.map((p) => vscode.workspace.asRelativePath(p));\r\n                let filesPreview = relativeFiles[0];\r\n                if (relativeFiles.length === 2) {\r\n                    filesPreview = `${relativeFiles[0]}, ${relativeFiles[1]}`;\r\n                } else if (relativeFiles.length > 2) {\r\n                    filesPreview = `${relativeFiles[0]}, ${relativeFiles[1]}, ... (+${relativeFiles.length - 2} more)`;\r\n                }\r\n\r\n                const scriptsToRun: string[] = [];\r\n                if (autoExtractCurrent) scriptsToRun.push('i18n:extract');\r\n                if (autoRewriteCurrent) scriptsToRun.push('i18n:rewrite');\r\n                const scriptsDetail =\r\n                    scriptsToRun.length > 1\r\n                        ? `\"${scriptsToRun[0]}\" and \"${scriptsToRun[1]}\"`\r\n                        : `\"${scriptsToRun[0]}\"`;\r\n\r\n                const choice = await vscode.window.showQuickPick(\r\n                    [\r\n                        {\r\n                            label: `Run ${scriptsLabel} now`,\r\n                            description:\r\n                                cleanFiles.length === 1\r\n                                    ? `Run for 1 clean file: ${relativeFiles[0]}`\r\n                                    : `Run for ${cleanFiles.length} clean files (e.g. ${filesPreview})`,\r\n                            detail: `Will run package.json script(s) ${scriptsDetail} for the changed files only and update locale JSON files.`,\r\n                        },\r\n                        {\r\n                            label: 'Skip this time',\r\n                            description: 'Do not run i18n scripts automatically right now',\r\n                        },\r\n                        {\r\n                            label: 'Skip for this session',\r\n                            description: 'Do not show this prompt again until next VS Code restart',\r\n                        },\r\n                        {\r\n                            label: 'Disable auto extract/rewrite',\r\n                            description:\r\n                                'Stop running i18n:extract/i18n:rewrite automatically for this workspace (you can still run them manually).',\r\n                        },\r\n                    ],\r\n                    {\r\n                        placeHolder: `AI Localizer: Run ${scriptsLabel} for ${cleanFiles.length} clean file(s)?`,\r\n                    },\r\n                );\r\n\r\n                // Update last prompt time\r\n                state.lastPromptTime = Date.now();\r\n\r\n                if (!choice || choice.label === 'Skip this time') {\r\n                    state.pendingFiles.clear();\r\n                    return;\r\n                }\r\n\r\n                if (choice.label === 'Skip for this session') {\r\n                    state.promptDismissedThisSession = true;\r\n                    state.pendingFiles.clear();\r\n                    return;\r\n                }\r\n\r\n                if (choice.label === 'Disable auto extract/rewrite') {\r\n                    await config.update(\r\n                        'i18n.autoExtract',\r\n                        false,\r\n                        vscode.ConfigurationTarget.Workspace,\r\n                    );\r\n                    await config.update(\r\n                        'i18n.autoRewrite',\r\n                        false,\r\n                        vscode.ConfigurationTarget.Workspace,\r\n                    );\r\n                    vscode.window.showInformationMessage(\r\n                        'AI Localizer: Disabled automatic extract/rewrite for this workspace.',\r\n                    );\r\n                    state.pendingFiles.clear();\r\n                    return;\r\n                }\r\n            }\r\n\r\n            // Convert file paths to relative paths for passing to scripts\r\n            const relativeFilePaths = cleanFiles.map(f => path.relative(folder.uri.fsPath, f));\r\n\r\n            if (autoExtractCurrent) {\r\n                await runI18nScript('i18n:extract', { \r\n                    folder,\r\n                    extraArgs: relativeFilePaths \r\n                });\r\n                state.lastExtractTime = Date.now();\r\n            }\r\n\r\n            if (autoRewriteCurrent) {\r\n                await runI18nScript('i18n:rewrite', { \r\n                    folder,\r\n                    extraArgs: relativeFilePaths \r\n                });\r\n                state.lastRewriteTime = Date.now();\r\n            }\r\n\r\n            // Use granular sync for specific files to preserve existing translations\r\n            // This syncs only the keys from the processed files without deleting other translations\r\n            try {\r\n                const syncService = getGranularSyncService();\r\n                const config = vscode.workspace.getConfiguration('ai-localizer');\r\n                const baseLocale = config.get<string>('i18n.defaultLocale') ?? 'en';\r\n                \r\n                for (const filePath of cleanFiles) {\r\n                    const fileUri = vscode.Uri.file(filePath);\r\n                    await syncService.syncFile(folder, fileUri, { baseLocale });\r\n                }\r\n            } catch (syncErr) {\r\n                console.error('Failed to sync translations for processed files:', syncErr);\r\n                // Don't fail the whole operation if sync fails\r\n            }\r\n\r\n            // Clear processed files\r\n            for (const filePath of cleanFiles) {\r\n                state.pendingFiles.delete(filePath);\r\n            }\r\n\r\n            vscode.window.showInformationMessage(\r\n                `AI Localizer: Auto-processed ${cleanFiles.length} clean file(s).`\r\n            );\r\n\r\n        } catch (err) {\r\n            console.error('Failed to process pending files:', err);\r\n            vscode.window.showErrorMessage(`AI Localizer: Auto-processing failed. ${err}`);\r\n        } finally {\r\n            state.isProcessing = false;\r\n        }\r\n    }\r\n\r\n    private async processCleanState(folder: vscode.WorkspaceFolder): Promise<void> {\r\n        const folderKey = folder.uri.fsPath;\r\n        const state = this.getOrCreateState(folderKey);\r\n\r\n        if (state.pendingFiles.size > 0) {\r\n            // We have pending files and git is clean, process them\r\n            await this.processPendingFiles(folder);\r\n        }\r\n    }\r\n\r\n    private async hasRunBefore(folder: vscode.WorkspaceFolder): Promise<boolean> {\r\n        // Check if i18n scripts exist in package.json\r\n        const pkgUri = vscode.Uri.joinPath(folder.uri, 'package.json');\r\n        try {\r\n            const data = await vscode.workspace.fs.readFile(pkgUri);\r\n            const text = new TextDecoder('utf-8').decode(data);\r\n            const pkg = JSON.parse(text);\r\n            \r\n            if (!pkg.scripts) {\r\n                return false;\r\n            }\r\n\r\n            // Check if i18n scripts are configured\r\n            return !!(\r\n                pkg.scripts['i18n:extract'] ||\r\n                pkg.scripts['i18n:rewrite']\r\n            );\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private getOrCreateState(folderKey: string): MonitorState {\r\n        let state = this.states.get(folderKey);\r\n        if (!state) {\r\n            state = {\r\n                lastExtractTime: 0,\r\n                lastRewriteTime: 0,\r\n                lastPromptTime: 0,\r\n                pendingFiles: new Set(),\r\n                isProcessing: false,\r\n                promptDismissedThisSession: false,\r\n                outdatedScriptsChecked: false,\r\n            };\r\n            this.states.set(folderKey, state);\r\n        }\r\n        return state;\r\n    }\r\n\r\n    dispose(): void {\r\n        for (const timer of this.debounceTimers.values()) {\r\n            clearTimeout(timer);\r\n        }\r\n        this.debounceTimers.clear();\r\n\r\n        for (const disposable of this.disposables) {\r\n            disposable.dispose();\r\n        }\r\n        this.disposables = [];\r\n    }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\core\\commitTracker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\core\\gitHistory.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'execAsync' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":6,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":16},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":17,"column":26,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":17,"endColumn":27,"suggestions":[{"messageId":"removeEscape","fix":{"range":[698,699],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[698,698],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\nimport * as path from 'path';\nimport { exec, execFile } from 'child_process';\nimport { promisify } from 'util';\n\nconst execAsync = promisify(exec);\nconst execFileAsync = promisify(execFile);\n\n/**\n * Validate that a string is a safe git ref (commit hash, branch name, or tag).\n * Only allows alphanumeric characters, hyphens, underscores, slashes, dots, and ^~:\n */\nfunction isValidGitRef(ref: string): boolean {\n    if (!ref || typeof ref !== 'string') return false;\n    // Git refs: alphanumeric, hyphen, underscore, slash, dot, ^, ~, @, numbers after ^ or ~\n    // Reject anything with shell metacharacters: $, `, \", ', \\, |, ;, &, etc.\n    return /^[A-Za-z0-9_.\\/\\-^~@]+$/.test(ref) && ref.length < 256;\n}\n\n// Timeout for git operations (30 seconds for larger repos)\nconst GIT_TIMEOUT_MS = 30000;\n// Max buffer size for git output (10MB for larger files)\nconst GIT_MAX_BUFFER = 10 * 1024 * 1024;\n// Max commits to check in history search (increased for better recovery)\nconst MAX_HISTORY_COMMITS = 100;\n\nexport interface GitCommitInfo {\n    hash: string;\n    date: Date;\n    message: string;\n    author: string;\n}\n\nexport interface GitFileHistory {\n    commits: GitCommitInfo[];\n    filePath: string;\n}\n\n/**\n * Get git commit hash for current HEAD\n */\nexport async function getCurrentCommitHash(\n    folder: vscode.WorkspaceFolder,\n): Promise<string | null> {\n    try {\n        // Use execFile for safer argument handling\n        const { stdout } = await execFileAsync('git', ['rev-parse', 'HEAD'], {\n            cwd: folder.uri.fsPath,\n            timeout: GIT_TIMEOUT_MS,\n            maxBuffer: GIT_MAX_BUFFER,\n        });\n        return stdout.trim() || null;\n    } catch {\n        return null;\n    }\n}\n\n/**\n * Get file history from git log (up to specified days back)\n */\nexport async function getFileHistory(\n    folder: vscode.WorkspaceFolder,\n    filePath: string,\n    daysBack: number = 30,\n    maxCommits: number = MAX_HISTORY_COMMITS,\n): Promise<GitFileHistory> {\n    const relativePath = path.relative(folder.uri.fsPath, filePath).replace(/\\\\/g, '/');\n    const sinceDate = new Date();\n    sinceDate.setDate(sinceDate.getDate() - daysBack);\n    const since = sinceDate.toISOString().split('T')[0];\n\n    try {\n        const commits = await readHistory(relativePath, folder.uri.fsPath, `--since=${since}`, maxCommits);\n\n        // Fallback: if no commits in the window, get the latest commits without date filter\n        if (commits.length === 0) {\n            const fallback = await readHistory(relativePath, folder.uri.fsPath, null, maxCommits);\n            return {\n                commits: fallback,\n                filePath: relativePath,\n            };\n        }\n\n        return {\n            commits,\n            filePath: relativePath,\n        };\n    } catch {\n        return {\n            commits: [],\n            filePath: relativePath,\n        };\n    }\n}\n\nasync function readHistory(\n    relativePath: string,\n    cwd: string,\n    sinceFlag: string | null,\n    maxCommits: number,\n): Promise<GitCommitInfo[]> {\n    const args = [\n        'log',\n        ...(sinceFlag ? [sinceFlag] : []),\n        '-n',\n        String(maxCommits),\n        '--format=%H|%ai|%an|%s',\n        '--',\n        relativePath,\n    ];\n\n    const { stdout } = await execFileAsync(\n        'git',\n        args,\n        {\n            cwd,\n            timeout: GIT_TIMEOUT_MS,\n            maxBuffer: GIT_MAX_BUFFER,\n        },\n    );\n\n    const commits: GitCommitInfo[] = [];\n    const lines = stdout.trim().split('\\n').filter(Boolean);\n\n    for (const line of lines) {\n        const [hash, dateStr, author, ...messageParts] = line.split('|');\n        if (hash && dateStr) {\n            commits.push({\n                hash: hash.trim(),\n                date: new Date(dateStr.trim()),\n                message: messageParts.join('|').trim(),\n                author: author.trim(),\n            });\n        }\n    }\n    return commits;\n}\n\n/**\n * Get file content at a specific commit\n */\nexport async function getFileContentAtCommit(\n    folder: vscode.WorkspaceFolder,\n    filePath: string,\n    commitHash: string,\n): Promise<string | null> {\n    // Validate commit hash to prevent shell injection\n    if (!isValidGitRef(commitHash)) {\n        console.warn(`AI Localizer: Invalid git ref format: ${commitHash}`);\n        return null;\n    }\n\n    const relativePath = path.relative(folder.uri.fsPath, filePath).replace(/\\\\/g, '/');\n\n    try {\n        // Use execFile for safer argument handling (no shell interpolation)\n        const { stdout } = await execFileAsync('git', ['show', `${commitHash}:${relativePath}`], {\n            cwd: folder.uri.fsPath,\n            timeout: GIT_TIMEOUT_MS,\n            maxBuffer: GIT_MAX_BUFFER,\n        });\n        return stdout || null;\n    } catch {\n        return null;\n    }\n}\n\n/**\n * Get diff for a file between two commits\n */\nexport async function getFileDiff(\n    folder: vscode.WorkspaceFolder,\n    filePath: string,\n    fromCommit: string,\n    toCommit: string = 'HEAD',\n): Promise<string | null> {\n    // Validate commit refs to prevent shell injection\n    if (!isValidGitRef(fromCommit) || !isValidGitRef(toCommit)) {\n        console.warn(`AI Localizer: Invalid git ref format: ${fromCommit} or ${toCommit}`);\n        return null;\n    }\n\n    const relativePath = path.relative(folder.uri.fsPath, filePath).replace(/\\\\/g, '/');\n\n    try {\n        // Use execFile for safer argument handling (no shell interpolation)\n        const { stdout } = await execFileAsync('git', ['diff', fromCommit, toCommit, '--', relativePath], {\n            cwd: folder.uri.fsPath,\n            timeout: GIT_TIMEOUT_MS,\n            maxBuffer: GIT_MAX_BUFFER,\n        });\n        return stdout || null;\n    } catch {\n        return null;\n    }\n}\n\n/**\n * Generate key path variations to try when searching.\n * Handles cases where key structure doesn't match file structure.\n */\nfunction getKeyPathVariations(keyPath: string): string[] {\n    const variations: string[] = [keyPath];\n    const parts = keyPath.split('.').filter(Boolean);\n    \n    if (parts.length > 1) {\n        variations.push(parts.slice(1).join('.'));\n        if (parts.length > 2) {\n            variations.push(parts.slice(2).join('.'));\n        }\n        variations.push(parts[parts.length - 1]);\n        if (parts.length > 2) {\n            variations.push(parts.slice(-2).join('.'));\n        }\n    }\n    \n    return variations;\n}\n\n/**\n * Find the most recent commit where a key existed in a locale file.\n * Tries multiple key path variations for better recovery rate.\n */\nexport async function findKeyInHistory(\n    folder: vscode.WorkspaceFolder,\n    localeFilePath: string,\n    keyPath: string,\n    daysBack: number = 90,\n): Promise<{ commit: GitCommitInfo; value: string; keyVariant: string } | null> {\n    const history = await getFileHistory(folder, localeFilePath, daysBack);\n    const keyVariations = getKeyPathVariations(keyPath);\n    const seenCommits = new Set<string>();\n\n    // Priority 1: commits mentioning i18n/translate (and their immediate predecessors)\n    const keywordIndices = history.commits\n        .map((c, idx) => ({ c, idx }))\n        .filter(({ c }) => /i18n|translat/i.test(c.message));\n\n    const tryCommitContent = async (commit: GitCommitInfo): Promise<{ commit: GitCommitInfo; value: string; keyVariant: string } | null> => {\n        if (seenCommits.has(commit.hash)) return null;\n        seenCommits.add(commit.hash);\n\n        const content = await getFileContentAtCommit(folder, localeFilePath, commit.hash);\n        if (!content) return null;\n        try {\n            const json = JSON.parse(content);\n            for (const keyVariant of keyVariations) {\n                const value = getNestedValue(json, keyVariant);\n                if (value && typeof value === 'string') {\n                    return { commit, value, keyVariant };\n                }\n            }\n        } catch {\n            // ignore invalid JSON\n        }\n        return null;\n    };\n\n    for (const { c, idx } of keywordIndices) {\n        const hit = await tryCommitContent(c);\n        if (hit) return hit;\n        const prev = history.commits[idx + 1];\n        if (prev) {\n            const prevHit = await tryCommitContent(prev);\n            if (prevHit) return prevHit;\n        }\n    }\n\n    for (const commit of history.commits) {\n        const hit = await tryCommitContent(commit);\n        if (hit) return hit;\n    }\n\n    return null;\n}\n\n/**\n * Get nested value from object using dot notation path\n */\nfunction getNestedValue(obj: any, path: string): any {\n    const segments = path.split('.').filter(Boolean);\n    let current = obj;\n    for (const segment of segments) {\n        if (!current || typeof current !== 'object' || Array.isArray(current)) {\n            return undefined;\n        }\n        if (!Object.prototype.hasOwnProperty.call(current, segment)) {\n            return undefined;\n        }\n        current = current[segment];\n    }\n    return current;\n}\n\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\core\\gitMonitor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\core\\i18nFs.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\core\\i18nIndex.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\core\\i18nPath.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\core\\projectEnv.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\core\\reactRuntime.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\core\\statusBar.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\core\\textValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\core\\vueRuntime.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\core\\workspace.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":249,"column":18,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":249,"endColumn":25,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[8162,8163],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\r\nimport * as path from 'path';\r\nimport { spawn } from 'child_process';\r\nimport { CommitTracker } from './commitTracker';\r\n\r\nexport async function pickWorkspaceFolder(): Promise<vscode.WorkspaceFolder | undefined> {\r\n    const folders = vscode.workspace.workspaceFolders;\r\n    if (!folders || folders.length === 0) {\r\n        return undefined;\r\n    }\r\n    if (folders.length === 1) {\r\n        return folders[0];\r\n    }\r\n    const items = folders.map((folder) => ({\r\n        label: folder.name,\r\n        description: folder.uri.fsPath,\r\n        folder,\r\n    }));\r\n    const selection = await vscode.window.showQuickPick(items, {\r\n        placeHolder: 'Select workspace folder for AI i18n configuration',\r\n    });\r\n    return selection?.folder;\r\n}\r\n\r\nexport async function findPackageJson(folder: vscode.WorkspaceFolder): Promise<vscode.Uri | undefined> {\r\n    const pattern = new vscode.RelativePattern(folder, 'package.json');\r\n    const matches = await vscode.workspace.findFiles(pattern, '**/node_modules/**', 20);\r\n    if (matches.length === 0) {\r\n        return undefined;\r\n    }\r\n    if (matches.length === 1) {\r\n        return matches[0];\r\n    }\r\n    const items = matches\r\n        .sort((a, b) => a.fsPath.length - b.fsPath.length)\r\n        .map((uri) => ({\r\n            label: path.relative(folder.uri.fsPath, uri.fsPath) || 'package.json',\r\n            description: uri.fsPath,\r\n            uri,\r\n        }));\r\n    const selection = await vscode.window.showQuickPick(items, {\r\n        placeHolder: 'Select package.json to configure for AI i18n',\r\n    });\r\n    return selection?.uri;\r\n}\r\n\r\nasync function hasWorkspaceFile(folder: vscode.WorkspaceFolder, relativePath: string): Promise<boolean> {\r\n    const uri = vscode.Uri.joinPath(folder.uri, relativePath);\r\n    try {\r\n        await vscode.workspace.fs.stat(uri);\r\n        return true;\r\n    } catch {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport async function workspaceLooksTypeScript(folder: vscode.WorkspaceFolder): Promise<boolean> {\r\n    if (await hasWorkspaceFile(folder, 'tsconfig.json')) {\r\n        return true;\r\n    }\r\n    try {\r\n        const tsPattern = new vscode.RelativePattern(folder, '**/*.ts');\r\n        const tsMatches = await vscode.workspace.findFiles(tsPattern, '**/node_modules/**', 1);\r\n        if (tsMatches.length > 0) {\r\n            return true;\r\n        }\r\n        const tsxPattern = new vscode.RelativePattern(folder, '**/*.tsx');\r\n        const tsxMatches = await vscode.workspace.findFiles(tsxPattern, '**/node_modules/**', 1);\r\n        return tsxMatches.length > 0;\r\n    } catch {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport type PackageManager = 'npm' | 'yarn' | 'pnpm' | 'bun';\r\n\r\nexport async function detectPackageManager(folder: vscode.WorkspaceFolder): Promise<PackageManager> {\r\n    if (await hasWorkspaceFile(folder, 'yarn.lock')) {\r\n        return 'yarn';\r\n    }\r\n    if (await hasWorkspaceFile(folder, 'pnpm-lock.yaml')) {\r\n        return 'pnpm';\r\n    }\r\n    if (await hasWorkspaceFile(folder, 'bun.lockb')) {\r\n        return 'bun';\r\n    }\r\n    if (await hasWorkspaceFile(folder, 'package-lock.json')) {\r\n        return 'npm';\r\n    }\r\n    return 'npm';\r\n}\r\n\r\n/**\r\n * Get the install command for a package manager\r\n */\r\nexport function getInstallCommand(pm: PackageManager, packages: string[], dev = true): string {\r\n    const devFlag = dev ? '-D' : '';\r\n    const pkgList = packages.join(' ');\r\n    switch (pm) {\r\n        case 'yarn':\r\n            return `yarn add ${devFlag} ${pkgList}`.trim();\r\n        case 'pnpm':\r\n            return `pnpm add ${devFlag} ${pkgList}`.trim();\r\n        case 'bun':\r\n            return `bun add ${devFlag} ${pkgList}`.trim();\r\n        case 'npm':\r\n        default:\r\n            return `npm install ${dev ? '--save-dev' : ''} ${pkgList}`.trim();\r\n    }\r\n}\r\n\r\n/**\r\n * Check if a package is installed in the project\r\n */\r\nexport async function isPackageInstalled(\r\n    folder: vscode.WorkspaceFolder,\r\n    packageName: string,\r\n): Promise<boolean> {\r\n    const pkgJsonUri = await findPackageJson(folder);\r\n    if (!pkgJsonUri) {\r\n        return false;\r\n    }\r\n    try {\r\n        const data = await vscode.workspace.fs.readFile(pkgJsonUri);\r\n        const pkg = JSON.parse(new TextDecoder().decode(data));\r\n        const deps = pkg.dependencies || {};\r\n        const devDeps = pkg.devDependencies || {};\r\n        return packageName in deps || packageName in devDeps;\r\n    } catch {\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Detect if project uses ESM (has \"type\": \"module\" in package.json)\r\n */\r\nexport async function isProjectESM(folder: vscode.WorkspaceFolder): Promise<boolean> {\r\n    const pkgJsonUri = await findPackageJson(folder);\r\n    if (!pkgJsonUri) {\r\n        return false;\r\n    }\r\n    try {\r\n        const data = await vscode.workspace.fs.readFile(pkgJsonUri);\r\n        const pkg = JSON.parse(new TextDecoder().decode(data));\r\n        return pkg.type === 'module';\r\n    } catch {\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Install packages using the detected package manager\r\n * Returns true if installation was initiated successfully\r\n */\r\nexport async function installPackages(\r\n    folder: vscode.WorkspaceFolder,\r\n    packages: string[],\r\n    dev = true,\r\n): Promise<boolean> {\r\n    const pm = await detectPackageManager(folder);\r\n    const command = getInstallCommand(pm, packages, dev);\r\n\r\n    const terminalName = `AI i18n Setup (${folder.name})`;\r\n    let terminal = vscode.window.terminals.find((t) => t.name === terminalName);\r\n    if (!terminal) {\r\n        terminal = vscode.window.createTerminal({ name: terminalName, cwd: folder.uri.fsPath });\r\n    }\r\n    terminal.show(true);\r\n    terminal.sendText(command);\r\n    return true;\r\n}\r\n\r\nexport interface RunI18nScriptOptions {\r\n    folder?: vscode.WorkspaceFolder;\r\n    extraArgs?: string[];\r\n    context?: vscode.ExtensionContext;\r\n}\r\n\r\nlet scriptsOutputChannel: vscode.OutputChannel | undefined;\r\n\r\nfunction getScriptsOutputChannel(): vscode.OutputChannel {\r\n    if (!scriptsOutputChannel) {\r\n        scriptsOutputChannel = vscode.window.createOutputChannel('AI i18n Scripts');\r\n    }\r\n    return scriptsOutputChannel;\r\n}\r\n\r\nexport async function runI18nScript(\r\n    scriptName: string,\r\n    options?: RunI18nScriptOptions,\r\n): Promise<void> {\r\n    let folder = options?.folder;\r\n\r\n    if (!folder) {\r\n        const active = vscode.window.activeTextEditor;\r\n        folder = active\r\n            ? vscode.workspace.getWorkspaceFolder(active.document.uri) ?? undefined\r\n            : undefined;\r\n        if (!folder) {\r\n            folder = await pickWorkspaceFolder();\r\n        }\r\n    }\r\n\r\n    if (!folder) {\r\n        vscode.window.showInformationMessage('AI Localizer: No workspace folder available.');\r\n        return;\r\n    }\r\n\r\n    // Track commit ref before running extract/replace scripts\r\n    const context = options?.context;\r\n    if (context && (scriptName === 'i18n:extract' || scriptName === 'i18n:rewrite' || scriptName === 'i18n:replace')) {\r\n        await CommitTracker.saveCommitRef(context, folder, scriptName);\r\n    }\r\n\r\n    const pm = await detectPackageManager(folder);\r\n    const args = options?.extraArgs && options.extraArgs.length\r\n        ? ` -- ${options.extraArgs.join(' ')}`\r\n        : '';\r\n\r\n    let command: string;\r\n    switch (pm) {\r\n        case 'yarn':\r\n            command = `yarn ${scriptName}${args}`;\r\n            break;\r\n        case 'pnpm':\r\n            command = `pnpm run ${scriptName}${args}`;\r\n            break;\r\n        case 'bun':\r\n            command = `bun run ${scriptName}${args}`;\r\n            break;\r\n        case 'npm':\r\n        default:\r\n            command = `npm run ${scriptName}${args}`;\r\n            break;\r\n    }\r\n\r\n    const output = getScriptsOutputChannel();\r\n    output.show(true);\r\n    output.appendLine(`> (${folder.name}) ${command}`);\r\n\r\n    // Timeout for scripts (5 minutes default, can be long for large projects)\r\n    const timeoutMs = 5 * 60 * 1000;\r\n\r\n    await new Promise<void>((resolve, reject) => {\r\n        let settled = false;\r\n        let timeoutId: NodeJS.Timeout | undefined;\r\n\r\n        const child = spawn(command, {\r\n            cwd: folder!.uri.fsPath,\r\n            shell: true,\r\n            stdio: ['pipe', 'pipe', 'pipe'], // Explicit stdio configuration\r\n        });\r\n\r\n        // Close stdin immediately to signal we won't provide input\r\n        // This prevents scripts from hanging waiting for input\r\n        if (child.stdin) {\r\n            child.stdin.end();\r\n        }\r\n\r\n        const settle = (error?: Error) => {\r\n            if (settled) return;\r\n            settled = true;\r\n            if (timeoutId) {\r\n                clearTimeout(timeoutId);\r\n            }\r\n            if (error) {\r\n                reject(error);\r\n            } else {\r\n                resolve();\r\n            }\r\n        };\r\n\r\n        // Set timeout to prevent infinite hanging\r\n        timeoutId = setTimeout(() => {\r\n            if (!settled) {\r\n                output.appendLine(`\\n[ai-i18n] Script ${scriptName} timed out after ${timeoutMs / 1000}s.`);\r\n                try {\r\n                    child.kill('SIGTERM');\r\n                    // Force kill after grace period\r\n                    setTimeout(() => {\r\n                        try { child.kill('SIGKILL'); } catch { /* ignore */ }\r\n                    }, 5000);\r\n                } catch { /* ignore */ }\r\n                settle(new Error(`Script ${scriptName} timed out`));\r\n            }\r\n        }, timeoutMs);\r\n\r\n        if (child.stdout) {\r\n            child.stdout.on('data', (data: Buffer) => {\r\n                output.append(data.toString());\r\n            });\r\n        }\r\n\r\n        if (child.stderr) {\r\n            child.stderr.on('data', (data: Buffer) => {\r\n                output.append(data.toString());\r\n            });\r\n        }\r\n\r\n        child.on('error', (err) => {\r\n            const msg = err instanceof Error ? err.message : String(err);\r\n            output.appendLine(`\\n[ai-i18n] Failed to start script ${scriptName}: ${msg}`);\r\n            settle(err instanceof Error ? err : new Error(msg));\r\n        });\r\n\r\n        // Handle both 'exit' and 'close' events\r\n        // 'exit' fires when process ends, 'close' fires when stdio streams close\r\n        // We use 'close' as primary since it ensures all output has been captured\r\n        child.on('close', (code) => {\r\n            if (settled) return;\r\n            if (code === 0 || code === null) {\r\n                output.appendLine(`[ai-i18n] Script ${scriptName} completed successfully.`);\r\n                settle();\r\n            } else {\r\n                const message = `[ai-i18n] Script ${scriptName} exited with code ${code}.`;\r\n                output.appendLine(message);\r\n                vscode.window.showErrorMessage(`AI Localizer: ${message}`);\r\n                settle(new Error(message));\r\n            }\r\n        });\r\n\r\n        // Fallback: handle 'exit' in case 'close' doesn't fire\r\n        child.on('exit', (code) => {\r\n            // Give 'close' event a chance to fire first with all output\r\n            setTimeout(() => {\r\n                if (!settled) {\r\n                    if (code === 0 || code === null) {\r\n                        output.appendLine(`[ai-i18n] Script ${scriptName} completed (via exit).`);\r\n                        settle();\r\n                    } else {\r\n                        const message = `[ai-i18n] Script ${scriptName} exited with code ${code}.`;\r\n                        output.appendLine(message);\r\n                        settle(new Error(message));\r\n                    }\r\n                }\r\n            }, 100);\r\n        });\r\n    });\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\extension.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\frameworks\\detection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\i18n\\lib\\parsers\\index.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\i18n\\runtime\\vue\\i18n.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\i18n\\runtime\\vue\\useTranslation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\providers\\i18nProviders.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":406,"column":36,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":406,"endColumn":48}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\nimport * as path from 'path';\nimport { I18nIndex, extractKeyAtPosition, escapeMarkdown } from '../core/i18nIndex';\nimport { readLaravelKeyValueFromFile, sharedDecoder } from '../core/i18nFs';\nimport { inferJsonLocaleFromUri } from '../core/i18nPath';\nimport { detectFrameworkProfile } from '../frameworks/detection';\nimport { ProjectConfigService } from '../services/projectConfigService';\nimport {\n    parseInvalidDiagnostic,\n    parseMissingReferenceDiagnostic,\n    parsePlaceholderDiagnostic,\n    parseStyleDiagnostic,\n    parseUntranslatedDiagnostic,\n} from '../commands/untranslated/utils/diagnosticParser';\n\n/**\n * Language selector for source files using i18n keys\n */\nexport const I18N_CODE_SELECTOR: vscode.DocumentSelector = [\n    { language: 'javascript', scheme: 'file' },\n    { language: 'typescript', scheme: 'file' },\n    { language: 'javascriptreact', scheme: 'file' },\n    { language: 'typescriptreact', scheme: 'file' },\n    { language: 'vue', scheme: 'file' },\n    { language: 'blade', scheme: 'file' },\n    { language: 'php', scheme: 'file' },\n];\n\n/**\n * Language selector for locale JSON files\n */\nexport const I18N_JSON_SELECTOR: vscode.DocumentSelector = [\n    { language: 'json', scheme: 'file' },\n    { language: 'jsonc', scheme: 'file' },\n];\n\n/**\n * Hover provider for i18n translation keys\n * Shows all translations for a key across all locales\n */\nexport class I18nHoverProvider implements vscode.HoverProvider {\n    constructor(private i18nIndex: I18nIndex) {}\n\n    async provideHover(\n        document: vscode.TextDocument,\n        position: vscode.Position,\n        token: vscode.CancellationToken,\n    ): Promise<vscode.Hover | undefined> {\n        try {\n            const config = vscode.workspace.getConfiguration('ai-localizer');\n            const delayMs = config.get<number>('i18n.hoverDelayMs') ?? 1900;\n\n            if (delayMs > 0) {\n                // Use a cancellation-aware delay to avoid keeping promises pending\n                const cancelled = await new Promise<boolean>((resolve) => {\n                    const handle = setTimeout(() => resolve(false), delayMs);\n                    // Listen for cancellation to resolve early and clear timer\n                    const disposable = token.onCancellationRequested(() => {\n                        clearTimeout(handle);\n                        disposable.dispose();\n                        resolve(true);\n                    });\n                });\n\n                if (cancelled || token.isCancellationRequested) {\n                    return undefined;\n                }\n            }\n\n            await this.i18nIndex.ensureInitialized();\n            \n            const keyInfo = extractKeyAtPosition(document, position);\n            if (!keyInfo) {\n                return undefined;\n            }\n\n            const range = keyInfo.range;\n\n            const record = this.i18nIndex.getRecord(keyInfo.key);\n            if (!record) {\n                return undefined;\n            }\n\n            const languageId = document.languageId;\n            const isLaravelSource = languageId === 'php' || languageId === 'blade';\n\n            const valueMap = new Map<string, string>();\n            let locales: string[] = [];\n\n            if (isLaravelSource) {\n                const laravelByLocale = new Map<string, vscode.Uri>();\n                for (const loc of record.locations) {\n                    const fsPath = loc.uri.fsPath.replace(/\\\\/g, '/').toLowerCase();\n                    if (fsPath.includes('/lang/') || fsPath.includes('/resources/lang/')) {\n                        const existing = laravelByLocale.get(loc.locale);\n                        if (!existing || loc.uri.fsPath.length < existing.fsPath.length) {\n                            laravelByLocale.set(loc.locale, loc.uri);\n                        }\n                    }\n                }\n\n                if (laravelByLocale.size === 0) {\n                    return undefined;\n                }\n\n                const entries = Array.from(laravelByLocale.entries());\n                const results = await Promise.all(\n                    entries.map(async ([locale, uri]) => {\n                        const v = await readLaravelKeyValueFromFile(uri, record.key);\n                        return { locale, value: v };\n                    }),\n                );\n\n                for (const { locale, value } of results) {\n                    if (typeof value === 'string' && value !== '') {\n                        valueMap.set(locale, value);\n                    }\n                }\n\n                if (valueMap.size === 0) {\n                    return undefined;\n                }\n\n                locales = Array.from(valueMap.keys());\n            } else {\n                for (const [locale, value] of record.locales.entries()) {\n                    if (typeof value === 'string') {\n                        valueMap.set(locale, value);\n                    }\n                }\n                locales = Array.from(valueMap.keys());\n            }\n\n            locales.sort((a, b) => {\n                if (a === record.defaultLocale) return -1;\n                if (b === record.defaultLocale) return 1;\n                return a.localeCompare(b);\n            });\n\n            const md = new vscode.MarkdownString();\n            md.appendMarkdown(`**i18n key** \\`${record.key}\\`\\n\\n`);\n            \n            const missingLocales = locales.filter((l) => {\n                const v = valueMap.get(l);\n                return v === undefined || v === '';\n            });\n            if (missingLocales.length > 0) {\n                md.appendMarkdown(`⚠️ Missing in: ${missingLocales.join(', ')}\\n\\n`);\n            }\n            \n            for (const locale of locales) {\n                const value = valueMap.get(locale);\n                if (value === undefined || value === '') {\n                    const isDefault = locale === record.defaultLocale;\n                    const localeLabel = isDefault ? `${locale} (default)` : locale;\n                    md.appendMarkdown(`- **${localeLabel}**: *(missing)*\\n`);\n                    continue;\n                }\n                \n                const isDefault = locale === record.defaultLocale;\n                const localeLabel = isDefault ? `${locale} (default)` : locale;\n                const displayValue = value.length > 80 ? value.substring(0, 77) + '...' : value;\n                md.appendMarkdown(`- **${localeLabel}**: ${escapeMarkdown(displayValue)}\\n`);\n            }\n\n            const args = {\n                uri: document.uri.toString(),\n                position: { line: range.start.line, character: range.start.character },\n            };\n            const encoded = encodeURIComponent(JSON.stringify(args));\n            md.appendMarkdown(\n                `\\n[Go to translation file](command:ai-localizer.i18n.gotoTranslationFromHover?${encoded})\\n`,\n            );\n\n            md.isTrusted = true;\n            return new vscode.Hover(md, keyInfo.range);\n        } catch (err) {\n            console.error('Hover provider error:', err);\n            return undefined;\n        }\n    }\n}\n\n/**\n * Definition provider for i18n translation keys\n * Allows jumping to translation files with locale selection\n */\nexport class I18nDefinitionProvider implements vscode.DefinitionProvider {\n    private projectConfigService = new ProjectConfigService();\n\n    constructor(private i18nIndex: I18nIndex) {}\n\n    private skipJsonWhitespaceAndComments(text: string, index: number): number {\n        let i = index;\n        while (i < text.length) {\n            const ch = text[i];\n            if (ch === ' ' || ch === '\\t' || ch === '\\r' || ch === '\\n') {\n                i += 1;\n                continue;\n            }\n\n            // JSONC: line comment\n            if (ch === '/' && text[i + 1] === '/') {\n                i += 2;\n                while (i < text.length && text[i] !== '\\n') i += 1;\n                continue;\n            }\n\n            // JSONC: block comment\n            if (ch === '/' && text[i + 1] === '*') {\n                i += 2;\n                while (i + 1 < text.length && !(text[i] === '*' && text[i + 1] === '/')) i += 1;\n                i = i + 2;\n                continue;\n            }\n\n            return i;\n        }\n        return i;\n    }\n\n    private parseJsonString(\n        text: string,\n        index: number,\n    ): { value: string; start: number; end: number } | null {\n        const quote = text[index];\n        if (quote !== '\"') return null;\n\n        const start = index;\n        let i = index + 1;\n        let value = '';\n        while (i < text.length) {\n            const ch = text[i];\n            if (ch === '\\\\') {\n                const next = text[i + 1];\n                if (next === undefined) return null;\n                // We don't need perfect unescaping for key comparisons; preserve common escapes.\n                value += next;\n                i += 2;\n                continue;\n            }\n            if (ch === quote) {\n                return { value, start, end: i + 1 };\n            }\n            value += ch;\n            i += 1;\n        }\n        return null;\n    }\n\n    private skipJsonValue(text: string, index: number): number {\n        let i = this.skipJsonWhitespaceAndComments(text, index);\n        if (i >= text.length) return i;\n\n        const ch = text[i];\n        if (ch === '\"') {\n            const str = this.parseJsonString(text, i);\n            return str ? str.end : i + 1;\n        }\n\n        if (ch === '{' || ch === '[') {\n            const open = ch;\n            const close = ch === '{' ? '}' : ']';\n            let depth = 0;\n            while (i < text.length) {\n                i = this.skipJsonWhitespaceAndComments(text, i);\n                if (i >= text.length) return i;\n\n                const c = text[i];\n                if (c === '\"') {\n                    const s = this.parseJsonString(text, i);\n                    i = s ? s.end : i + 1;\n                    continue;\n                }\n                if (c === open) {\n                    depth += 1;\n                    i += 1;\n                    continue;\n                }\n                if (c === close) {\n                    depth -= 1;\n                    i += 1;\n                    if (depth <= 0) return i;\n                    continue;\n                }\n                i += 1;\n            }\n            return i;\n        }\n\n        // Primitive value: read until delimiter\n        while (i < text.length) {\n            const c = text[i];\n            if (c === ',' || c === '}' || c === ']') {\n                return i;\n            }\n            i += 1;\n        }\n        return i;\n    }\n\n    private findJsonKeyRangeInObject(\n        text: string,\n        startIndex: number,\n        targetParts: string[],\n        partIndex: number,\n    ): { start: number; end: number } | null {\n        let i = this.skipJsonWhitespaceAndComments(text, startIndex);\n        if (text[i] !== '{') return null;\n        i += 1;\n\n        while (i < text.length) {\n            i = this.skipJsonWhitespaceAndComments(text, i);\n            if (i >= text.length) return null;\n            if (text[i] === '}') return null;\n\n            const keyNode = this.parseJsonString(text, i);\n            if (!keyNode) return null;\n            i = this.skipJsonWhitespaceAndComments(text, keyNode.end);\n            if (text[i] !== ':') return null;\n            i = this.skipJsonWhitespaceAndComments(text, i + 1);\n\n            const currentPart = targetParts[partIndex];\n            const isMatch = keyNode.value === currentPart;\n            if (isMatch) {\n                if (partIndex === targetParts.length - 1) {\n                    return { start: keyNode.start, end: keyNode.end };\n                }\n                const next = this.skipJsonWhitespaceAndComments(text, i);\n                if (text[next] === '{') {\n                    const nested = this.findJsonKeyRangeInObject(\n                        text,\n                        next,\n                        targetParts,\n                        partIndex + 1,\n                    );\n                    if (nested) return nested;\n                }\n            }\n\n            i = this.skipJsonValue(text, i);\n            i = this.skipJsonWhitespaceAndComments(text, i);\n            if (text[i] === ',') {\n                i += 1;\n                continue;\n            }\n            if (text[i] === '}') {\n                return null;\n            }\n        }\n\n        return null;\n    }\n\n    private findJsonKeyRange(text: string, key: string): { start: number; end: number } | null {\n        const rootIndex = this.skipJsonWhitespaceAndComments(text, 0);\n        if (rootIndex >= text.length || text[rootIndex] !== '{') return null;\n\n        // Prefer nested key paths (Auth.Authorize.heading.key)\n        const dottedParts = key.split('.').filter(Boolean);\n        if (dottedParts.length > 1) {\n            const nested = this.findJsonKeyRangeInObject(text, rootIndex, dottedParts, 0);\n            if (nested) return nested;\n        }\n\n        // Fallback: flat JSON where the entire dotted key is a single property\n        return this.findJsonKeyRangeInObject(text, rootIndex, [key], 0);\n    }\n\n    /**\n     * Find the exact position of a key in a JSON file\n     * Returns a range that can be used to navigate to the key\n     */\n    private async findKeyPositionInFile(\n        uri: vscode.Uri,\n        key: string,\n    ): Promise<vscode.Range> {\n        try {\n            // Open the document (loads into memory, doesn't show in editor yet)\n            const document = await vscode.workspace.openTextDocument(uri);\n            const text = document.getText();\n\n            const ext = uri.fsPath.split('.').pop()?.toLowerCase() || '';\n            if (ext === 'json' || ext === 'jsonc') {\n                const rangeOffsets = this.findJsonKeyRange(text, key);\n                if (rangeOffsets) {\n                    const startPos = document.positionAt(rangeOffsets.start);\n                    const endPos = document.positionAt(rangeOffsets.end);\n                    return new vscode.Range(startPos, endPos);\n                }\n            }\n            \n            // Split key into parts (e.g., \"Namespace.button.save\" -> [\"Namespace\", \"button\", \"save\"])\n            const keyParts = key.split('.');\n            const lastPart = keyParts[keyParts.length - 1];\n            \n            // Search for the key in the JSON structure\n            // Look for patterns like: \"lastPart\": \"value\" or \"lastPart\":\"value\"\n            const escapedKey = lastPart.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n            const searchPattern = new RegExp(`\"${escapedKey}\"\\\\s*:\\\\s*`, 'g');\n            const matches = [...text.matchAll(searchPattern)];\n            \n            if (matches.length > 0) {\n                // Use the first match\n                const match = matches[0];\n                const matchIndex = match.index!;\n                const startPos = document.positionAt(matchIndex);\n                // Create a range that highlights the key name\n                const endPos = document.positionAt(matchIndex + lastPart.length + 2); // +2 for quotes\n                return new vscode.Range(startPos, endPos);\n            }\n        } catch (err) {\n            console.error('Failed to find key position in file:', err);\n            console.error('URI:', uri.toString());\n            console.error('Key:', key);\n        }\n        \n        // Fallback to top of file\n        return new vscode.Range(new vscode.Position(0, 0), new vscode.Position(0, 0));\n    }\n\n    async provideDefinition(\n        document: vscode.TextDocument,\n        position: vscode.Position,\n    ): Promise<vscode.Definition | undefined> {\n        try {\n            await this.i18nIndex.ensureInitialized();\n            \n            // If nothing is indexed yet, offer to initialize i18n for the project\n            const allKeys = this.i18nIndex.getAllKeys();\n            if (!allKeys.length) {\n                const folder = vscode.workspace.getWorkspaceFolder(document.uri);\n                const isConfigured = folder\n                    ? await this.projectConfigService.hasI18nScripts(folder)\n                    : false;\n\n                const buttons = isConfigured\n                    ? ['Rescan Translations']\n                    : ['Disable for this Project', 'Configure i18n'];\n\n                const choice = await vscode.window.showInformationMessage(\n                    'AI Localizer: No translations indexed for this workspace yet.',\n                    ...buttons,\n                );\n\n                if (choice === 'Rescan Translations') {\n                    await vscode.commands.executeCommand('ai-localizer.i18n.rescan');\n                } else if (choice === 'Configure i18n') {\n                    await vscode.commands.executeCommand('ai-localizer.i18n.configureProject');\n                } else if (choice === 'Disable for this Project') {\n                    const configTarget = vscode.workspace.getConfiguration(\n                        'ai-localizer',\n                        folder?.uri,\n                    );\n                    await configTarget.update(\n                        'i18n.enabled',\n                        false,\n                        folder\n                            ? vscode.ConfigurationTarget.WorkspaceFolder\n                            : vscode.ConfigurationTarget.Workspace,\n                    );\n                    vscode.window.showInformationMessage(\n                        'AI Localizer: i18n has been disabled for this project.',\n                    );\n                }\n                return undefined;\n            }\n\n            const keyInfo = extractKeyAtPosition(document, position);\n            if (!keyInfo) {\n                return undefined;\n            }\n\n            const record = this.i18nIndex.getRecord(keyInfo.key);\n            if (!record || record.locations.length === 0) {\n                return undefined;\n            }\n\n            const isLaravelSource = document.languageId === 'php' || document.languageId === 'blade';\n\n            // Collapse to a single primary location per locale using the indexed information\n            const primaryByLocale = new Map<string, { locale: string; uri: vscode.Uri }>();\n            for (const loc of record.locations) {\n                const existing = primaryByLocale.get(loc.locale);\n                if (!existing) {\n                    primaryByLocale.set(loc.locale, loc);\n                    continue;\n                }\n                // Prefer the shorter (shallower) path as the primary location for that locale\n                const existingLen = existing.uri.fsPath.length;\n                const newLen = loc.uri.fsPath.length;\n                if (newLen < existingLen) {\n                    primaryByLocale.set(loc.locale, loc);\n                }\n            }\n\n            // Start from one canonical location per locale\n            const currentFolder = vscode.workspace.getWorkspaceFolder(document.uri) || undefined;\n            let locations = Array.from(primaryByLocale.values());\n\n            if (isLaravelSource) {\n                const laravelLocations = locations.filter((loc) => {\n                    const fsPath = loc.uri.fsPath.replace(/\\\\/g, '/').toLowerCase();\n                    return fsPath.includes('/lang/') || fsPath.includes('/resources/lang/');\n                });\n                if (laravelLocations.length > 0) {\n                    locations = laravelLocations;\n                }\n            }\n\n            if (currentFolder) {\n                try {\n                    const profile = await detectFrameworkProfile(currentFolder);\n                    if (profile) {\n                        const preferredByRoot = locations.filter((loc) => {\n                            const rel = path\n                                .relative(currentFolder.uri.fsPath, loc.uri.fsPath)\n                                .replace(/\\\\/g, '/');\n                            return rel.startsWith(profile.rootDir + '/');\n                        });\n                        if (preferredByRoot.length > 0) {\n                            locations = preferredByRoot;\n                        }\n                    }\n                } catch (err) {\n                    console.error('Failed to detect framework profile for definition provider:', err);\n                }\n\n                // Fallback: prefer locations in the same workspace folder\n                if (locations.length > 1) {\n                    const sameWorkspace = locations.filter((loc) => {\n                        const locFolder = vscode.workspace.getWorkspaceFolder(loc.uri);\n                        return locFolder && locFolder.uri.fsPath === currentFolder.uri.fsPath;\n                    });\n                    if (sameWorkspace.length > 0) {\n                        locations = sameWorkspace;\n                    }\n                }\n            }\n\n            // If only one location, jump directly with precise position\n            if (locations.length === 1) {\n                const targetUri = locations[0].uri;\n                console.log('[i18n] Jumping to single location:', targetUri.toString());\n                const range = await this.findKeyPositionInFile(targetUri, keyInfo.key);\n                console.log('[i18n] Found range:', range.start.line, range.start.character);\n                return new vscode.Location(targetUri, range);\n            }\n\n            // Multiple locales available - let user choose\n            const localeChoices = locations.map((loc) => {\n                const translation = record.locales.get(loc.locale) || '';\n                const isDefault = loc.locale === record.defaultLocale;\n                \n                return {\n                    label: isDefault ? `$(star-full) ${loc.locale}` : `$(globe) ${loc.locale}`,\n                    description: translation.length > 50 \n                        ? translation.substring(0, 50) + '...' \n                        : translation,\n                    detail: isDefault ? 'Default locale' : undefined,\n                    location: loc,\n                };\n            });\n\n            // Sort with default locale first\n            localeChoices.sort((a, b) => {\n                if (a.location.locale === record.defaultLocale) return -1;\n                if (b.location.locale === record.defaultLocale) return 1;\n                return a.location.locale.localeCompare(b.location.locale);\n            });\n\n            const choice = await vscode.window.showQuickPick(localeChoices, {\n                placeHolder: `Select locale for translation key: ${record.key}`,\n                title: 'Go to Translation File',\n                matchOnDescription: true,\n            });\n\n            if (!choice) {\n                // User cancelled - jump to default locale as fallback\n                const primary =\n                    record.locations.find((l) => l.locale === record.defaultLocale) ||\n                    record.locations[0];\n                console.log('[i18n] User cancelled, jumping to default:', primary.uri.toString());\n                const range = await this.findKeyPositionInFile(primary.uri, keyInfo.key);\n                return new vscode.Location(primary.uri, range);\n            }\n\n            // Jump to the selected locale file with precise position\n            const targetUri = choice.location.uri;\n            console.log('[i18n] User selected locale:', choice.location.locale, targetUri.toString());\n            const range = await this.findKeyPositionInFile(targetUri, keyInfo.key);\n            console.log('[i18n] Found range:', range.start.line, range.start.character);\n            return new vscode.Location(targetUri, range);\n        } catch (err) {\n            console.error('Definition provider error:', err);\n            return undefined;\n        }\n    }\n}\n\n/**\n * Completion provider for i18n translation keys\n * Provides autocomplete suggestions for translation keys\n */\nexport class I18nCompletionProvider implements vscode.CompletionItemProvider {\n    constructor(private i18nIndex: I18nIndex) {}\n\n    async provideCompletionItems(\n        document: vscode.TextDocument,\n        position: vscode.Position,\n    ): Promise<vscode.CompletionItem[]> {\n        try {\n            await this.i18nIndex.ensureInitialized();\n            const langId = document.languageId;\n            const isLaravelSource = langId === 'php' || langId === 'blade';\n\n            if (langId === 'json' || langId === 'jsonc') {\n                // Provide IntelliSense for known translations inside locale JSON files\n                return this.provideJsonTranslationCompletions(document, position);\n            }\n\n            const keyInfo = extractKeyAtPosition(document, position);\n            if (!keyInfo) {\n                // Only offer completions when cursor is inside a translation key string\n                return [];\n            }\n            const existingPrefix = keyInfo.key;\n\n            const items: vscode.CompletionItem[] = [];\n            const allKeys = this.i18nIndex.getAllKeys();\n\n            for (const key of allKeys) {\n                // Filter by prefix if one exists\n                if (existingPrefix && !key.startsWith(existingPrefix)) {\n                    continue;\n                }\n\n                const record = this.i18nIndex.getRecord(key);\n                if (!record) continue;\n\n                if (isLaravelSource) {\n                    const hasLaravel = record.locations.some((loc) => {\n                        const fsPath = loc.uri.fsPath.replace(/\\\\/g, '/').toLowerCase();\n                        return fsPath.includes('/lang/') || fsPath.includes('/resources/lang/');\n                    });\n                    if (!hasLaravel) {\n                        continue;\n                    }\n                }\n\n                // Calculate the suffix to insert (avoid duplicating the prefix)\n                const insertText = existingPrefix ? key.substring(existingPrefix.length) : key;\n                const item = new vscode.CompletionItem(key, vscode.CompletionItemKind.Value);\n                item.insertText = insertText;\n                item.command = {\n                    title: 'Go to Translation File',\n                    command: 'ai-localizer.i18n.gotoTranslationFromHover',\n                    arguments: [\n                        {\n                            uri: document.uri.toString(),\n                            position: {\n                                line: keyInfo.range.start.line,\n                                character: keyInfo.range.start.character,\n                            },\n                        },\n                    ],\n                };\n                \n                // Set detail to default locale translation\n                const defaultTranslation = record.locales.get(record.defaultLocale) ?? '';\n                item.detail = defaultTranslation;\n\n                // Build documentation with all translations\n                const md = new vscode.MarkdownString();\n                md.appendMarkdown(`**i18n key** \\`${record.key}\\`\\n\\n`);\n                \n                // Sort locales with default first\n                const sortedLocales = Array.from(record.locales.entries()).sort(([a], [b]) => {\n                    if (a === record.defaultLocale) return -1;\n                    if (b === record.defaultLocale) return 1;\n                    return a.localeCompare(b);\n                });\n\n                for (const [locale, value] of sortedLocales) {\n                    const isDefault = locale === record.defaultLocale;\n                    const localeLabel = isDefault ? `${locale} (default)` : locale;\n                    md.appendMarkdown(`- **${localeLabel}**: ${escapeMarkdown(value)}\\n`);\n                }\n                \n                md.isTrusted = false;\n                item.documentation = md;\n\n                // Add sort text to prioritize matches\n                if (key.startsWith(existingPrefix)) {\n                    item.sortText = `0_${key}`;\n                } else {\n                    item.sortText = `1_${key}`;\n                }\n\n                items.push(item);\n\n                // Limit results to prevent performance issues\n                if (items.length >= 200) {\n                    break;\n                }\n            }\n\n            return items;\n        } catch (err) {\n            console.error('Completion provider error:', err);\n            return [];\n        }\n    }\n\n    /**\n     * Provide completion items for locale JSON files based on known\n     * translations for the current locale.\n     */\n    private async provideJsonTranslationCompletions(\n        document: vscode.TextDocument,\n        position: vscode.Position,\n    ): Promise<vscode.CompletionItem[]> {\n        const fsPath = document.uri.fsPath;\n        const normalized = fsPath.replace(/\\\\/g, '/');\n\n        // Heuristic: only run on likely locale JSON paths\n        if (\n            !normalized.includes('/i18n/') &&\n            !normalized.includes('/locales/') &&\n            !normalized.includes('/resources/js/i18n/')\n        ) {\n            return [];\n        }\n\n        const locale = inferJsonLocaleFromUri(document.uri);\n\n        if (!locale) {\n            return [];\n        }\n\n        const line = document.lineAt(position.line).text;\n        if (!line) {\n            return [];\n        }\n\n        const before = line.slice(0, position.character);\n        const lastQuote = before.lastIndexOf('\"');\n        const lastColon = before.lastIndexOf(':');\n\n        // Only provide value completions when cursor is inside a JSON string\n        // after the colon (i.e. the value side of a key/value pair).\n        if (lastQuote === -1 || lastColon === -1 || lastQuote < lastColon) {\n            return [];\n        }\n\n        const existingPrefix = before.slice(lastQuote + 1);\n        const prefixLower = existingPrefix.toLowerCase();\n\n        const items: vscode.CompletionItem[] = [];\n        const seen = new Set<string>();\n        const allKeys = this.i18nIndex.getAllKeys();\n\n        for (const key of allKeys) {\n            const record = this.i18nIndex.getRecord(key);\n            if (!record) continue;\n\n            const rawValue = record.locales.get(locale);\n            if (typeof rawValue !== 'string') continue;\n            const value = rawValue.trim();\n            if (!value) continue;\n\n            if (existingPrefix) {\n                const valueLower = value.toLowerCase();\n                if (!valueLower.startsWith(prefixLower)) {\n                    continue;\n                }\n            }\n\n            if (seen.has(value)) {\n                continue;\n            }\n            seen.add(value);\n\n            const item = new vscode.CompletionItem(value, vscode.CompletionItemKind.Text);\n            const insertText = existingPrefix ? value.slice(existingPrefix.length) : value;\n            item.insertText = insertText;\n            item.detail = `Known ${locale} translation from key ${key}`;\n\n            items.push(item);\n\n            if (items.length >= 100) {\n                break;\n            }\n        }\n\n        return items;\n    }\n}\n\nclass I18nUntranslatedCodeActionProvider implements vscode.CodeActionProvider {\n    public static readonly providedCodeActionKinds = [vscode.CodeActionKind.QuickFix];\n\n    private isLaravelLocaleFile(document: vscode.TextDocument): boolean {\n        const fsPath = document.uri.fsPath.replace(/\\\\/g, '/').toLowerCase();\n        if (!fsPath.endsWith('.php')) {\n            return false;\n        }\n        return fsPath.includes('/lang/') || fsPath.includes('/resources/lang/');\n    }\n\n    constructor(private i18nIndex: I18nIndex) {}\n\n    async provideCodeActions(\n        document: vscode.TextDocument,\n        range: vscode.Range,\n        context: vscode.CodeActionContext,\n    ): Promise<(vscode.CodeAction | vscode.Command)[]> {\n        const actions: vscode.CodeAction[] = [];\n\n        const relevant = context.diagnostics.filter(\n            (d) =>\n                d.code === 'ai-i18n.untranslated' ||\n                d.code === 'ai-i18n.style' ||\n                d.code === 'ai-i18n.invalid' ||\n                d.code === 'ai-i18n.placeholders' ||\n                d.code === 'ai-i18n.missing-reference',\n        );\n\n        let addedBulkActions = false;\n        const workspaceFolder = vscode.workspace.getWorkspaceFolder(document.uri);\n        const isJsonLocale = document.languageId === 'json' || document.languageId === 'jsonc';\n        const isLaravelLocale = this.isLaravelLocaleFile(document);\n\n        for (const diagnostic of relevant) {\n            if (!diagnostic.range.intersection(range)) {\n                continue;\n            }\n\n            if (diagnostic.code === 'ai-i18n.untranslated') {\n                const parsed = parseUntranslatedDiagnostic(String(diagnostic.message || ''));\n                if (!parsed) continue;\n                const { key, locales } = parsed;\n                if (!key || !locales || !locales.length) {\n                    continue;\n                }\n                const uniqueLocales = Array.from(new Set(locales));\n                const localeLabel = uniqueLocales.join(', ');\n                const title = `AI Localizer: AI-translate ${localeLabel} for ${key}`;\n                const action = new vscode.CodeAction(title, vscode.CodeActionKind.QuickFix);\n                action.diagnostics = [diagnostic];\n                action.isPreferred = true;\n                action.command = {\n                    title,\n                    command: 'ai-localizer.i18n.applyUntranslatedQuickFix',\n                    arguments: [document.uri, key, uniqueLocales],\n                };\n                actions.push(action);\n\n                // Add \"ignore this key\" option for keys that shouldn't be translated\n                if (workspaceFolder) {\n                    const ignoreTitle = `AI Localizer: Add \"${key}\" to ignore list`;\n                    const ignoreAction = new vscode.CodeAction(ignoreTitle, vscode.CodeActionKind.QuickFix);\n                    ignoreAction.diagnostics = [diagnostic];\n                    ignoreAction.command = {\n                        title: ignoreTitle,\n                        command: 'ai-localizer.i18n.addKeyToIgnoreList',\n                        arguments: [workspaceFolder.uri, key],\n                    };\n                    actions.push(ignoreAction);\n                }\n            } else if (diagnostic.code === 'ai-i18n.placeholders') {\n                // Placeholder mismatch - offer to copy placeholders from default\n                const placeholderParsed = parsePlaceholderDiagnostic(String(diagnostic.message || ''));\n                if (placeholderParsed) {\n                    const { key, locale } = placeholderParsed;\n                    const title = `AI Localizer: Fix placeholder mismatch for ${key} in ${locale}`;\n                    const action = new vscode.CodeAction(title, vscode.CodeActionKind.QuickFix);\n                    action.diagnostics = [diagnostic];\n                    action.isPreferred = true;\n                    action.command = {\n                        title,\n                        command: 'ai-localizer.i18n.fixPlaceholderMismatch',\n                        arguments: [document.uri, key, locale],\n                    };\n                    actions.push(action);\n                }\n            } else if (diagnostic.code === 'ai-i18n.style') {\n                const styleParsed = parseStyleDiagnostic(String(diagnostic.message || ''));\n                if (!styleParsed) continue;\n                const { key, locale, suggested } = styleParsed;\n                if (!key || !locale || !suggested) continue;\n                const title = `AI Localizer: Apply suggested style (${locale}) for ${key}`;\n                const action = new vscode.CodeAction(title, vscode.CodeActionKind.QuickFix);\n                action.diagnostics = [diagnostic];\n                action.command = {\n                    title,\n                    command: 'ai-localizer.i18n.applyStyleSuggestionQuickFix',\n                    arguments: [document.uri, key, locale, suggested],\n                };\n                actions.push(action);\n            } else if (diagnostic.code === 'ai-i18n.invalid') {\n                // Parse the invalid diagnostic to extract the key\n                const invalidParsed = parseInvalidDiagnostic(String(diagnostic.message || ''));\n                if (!invalidParsed) continue;\n                const { key } = invalidParsed;\n\n                // Offer per-key removal from this file\n                const title = `AI Localizer: Remove invalid key \"${key}\" from this file`;\n                const action = new vscode.CodeAction(title, vscode.CodeActionKind.QuickFix);\n                action.diagnostics = [diagnostic];\n                action.isPreferred = true;\n                action.command = {\n                    title,\n                    command: 'ai-localizer.i18n.removeInvalidKeyInFile',\n                    arguments: [document.uri, key],\n                };\n                actions.push(action);\n\n                // Also offer bulk restore if we have a folder\n                if (workspaceFolder) {\n                    const bulkTitle = `AI Localizer: Restore all invalid keys in code and remove from locales`;\n                    const bulkAction = new vscode.CodeAction(bulkTitle, vscode.CodeActionKind.QuickFix);\n                    bulkAction.diagnostics = [diagnostic];\n                    bulkAction.command = {\n                        title: bulkTitle,\n                        command: 'ai-localizer.i18n.restoreInvalidKeysInFile',\n                        arguments: [document.uri],\n                    };\n                    actions.push(bulkAction);\n                }\n            } else if (diagnostic.code === 'ai-i18n.missing-reference') {\n                // Parse the missing reference diagnostic to extract the key\n                const missingRefParsed = parseMissingReferenceDiagnostic(String(diagnostic.message || ''));\n                if (!missingRefParsed) continue;\n                const { key } = missingRefParsed;\n\n                // Single fix action\n                const title = `AI Localizer: Fix missing reference \"${key}\"`;\n                const action = new vscode.CodeAction(title, vscode.CodeActionKind.QuickFix);\n                action.diagnostics = [diagnostic];\n                action.isPreferred = true;\n                action.command = {\n                    title,\n                    command: 'ai-localizer.i18n.fixMissingKeyReference',\n                    arguments: [\n                        document.uri,\n                        { line: diagnostic.range.start.line, character: diagnostic.range.start.character },\n                        key,\n                    ],\n                };\n                actions.push(action);\n\n                // Bulk fix action for all missing references in this file\n                if (\n                    !addedBulkActions &&\n                    (document.languageId === 'typescript' ||\n                        document.languageId === 'typescriptreact' ||\n                        document.languageId === 'javascript' ||\n                        document.languageId === 'javascriptreact' ||\n                        document.languageId === 'vue' ||\n                        document.languageId === 'php' ||\n                        document.languageId === 'blade')\n                ) {\n                    addedBulkActions = true;\n                    const bulkTitle = 'AI Localizer: Bulk fix all missing key references in this file';\n                    const bulkAction = new vscode.CodeAction(bulkTitle, vscode.CodeActionKind.QuickFix);\n                    bulkAction.diagnostics = [diagnostic];\n                    bulkAction.command = {\n                        title: bulkTitle,\n                        command: 'ai-localizer.i18n.bulkFixMissingKeyReferences',\n                        arguments: [document.uri],\n                    };\n                    actions.push(bulkAction);\n                }\n            }\n\n            if (!addedBulkActions && (isJsonLocale || isLaravelLocale)) {\n                addedBulkActions = true;\n\n                // Add bulk translate action for all untranslated keys in this file\n                const bulkTranslateTitle = 'AI Localizer: AI-translate all untranslated keys in this file';\n                const bulkTranslateAction = new vscode.CodeAction(\n                    bulkTranslateTitle,\n                    vscode.CodeActionKind.QuickFix,\n                );\n                bulkTranslateAction.command = {\n                    title: bulkTranslateTitle,\n                    command: 'ai-localizer.i18n.translateAllUntranslatedInFile',\n                    arguments: [document.uri],\n                };\n                actions.push(bulkTranslateAction);\n\n                if (isJsonLocale) {\n                    const cleanupTitle = 'AI Localizer: Cleanup unused keys in this file (from report)';\n                    const cleanupAction = new vscode.CodeAction(\n                        cleanupTitle,\n                        vscode.CodeActionKind.QuickFix,\n                    );\n                    cleanupAction.command = {\n                        title: cleanupTitle,\n                        command: 'ai-localizer.i18n.cleanupUnusedKeysInFile',\n                        arguments: [document.uri],\n                    };\n                    actions.push(cleanupAction);\n\n                    const invalidTitle =\n                        'AI Localizer: Remove invalid/non-translatable keys in this file (from report)';\n                    const invalidAction = new vscode.CodeAction(\n                        invalidTitle,\n                        vscode.CodeActionKind.QuickFix,\n                    );\n                    invalidAction.command = {\n                        title: invalidTitle,\n                        command: 'ai-localizer.i18n.restoreInvalidKeysInFile',\n                        arguments: [document.uri],\n                    };\n                    actions.push(invalidAction);\n                }\n            }\n        }\n\n        const folder = vscode.workspace.getWorkspaceFolder(document.uri) || undefined;\n\n        if (folder && (document.languageId === 'json' || document.languageId === 'jsonc')) {\n            const keyPath = await this.getKeyPathForJsonRange(document, range);\n            if (keyPath) {\n                const scriptsDir = vscode.Uri.joinPath(folder.uri, 'scripts');\n                const unusedReport = await this.loadReport(scriptsDir, '.i18n-unused-report.json');\n                const invalidReport = await this.loadReport(scriptsDir, '.i18n-invalid-report.json');\n\n                const unused = Array.isArray(unusedReport?.unused) ? unusedReport.unused : [];\n                const invalid = Array.isArray(invalidReport?.invalid) ? invalidReport.invalid : [];\n\n                const isUnused = unused.some(\n                    (item: any) => item && typeof item.keyPath === 'string' && item.keyPath === keyPath,\n                );\n                const isInvalid = invalid.some(\n                    (item: any) => item && typeof item.keyPath === 'string' && item.keyPath === keyPath,\n                );\n\n                if (isUnused) {\n                    const title = `AI Localizer: Remove this unused key (${keyPath}) from this file (from report)`;\n                    const action = new vscode.CodeAction(title, vscode.CodeActionKind.QuickFix);\n                    action.command = {\n                        title,\n                        command: 'ai-localizer.i18n.removeUnusedKeyInFile',\n                        arguments: [document.uri, keyPath],\n                    };\n                    actions.push(action);\n                }\n\n                if (isInvalid) {\n                    const title = `AI Localizer: Remove this invalid/non-translatable key (${keyPath}) from this file (from report)`;\n                    const action = new vscode.CodeAction(title, vscode.CodeActionKind.QuickFix);\n                    action.isPreferred = true;\n                    action.command = {\n                        title,\n                        command: 'ai-localizer.i18n.removeInvalidKeyInFile',\n                        arguments: [document.uri, keyPath],\n                    };\n                    actions.push(action);\n                }\n            }\n        }\n\n        if (folder && document.languageId !== 'json' && document.languageId !== 'jsonc' && !isLaravelLocale) {\n            const keyInfo = extractKeyAtPosition(document, range.start) || extractKeyAtPosition(document, range.end);\n            if (keyInfo) {\n                const scriptsDir = vscode.Uri.joinPath(folder.uri, 'scripts');\n                const invalidReport = await this.loadReport(scriptsDir, '.i18n-invalid-report.json');\n                const invalid = Array.isArray(invalidReport?.invalid) ? invalidReport.invalid : [];\n                const hasInvalid = invalid.some(\n                    (item: any) => item && typeof item.keyPath === 'string' && item.keyPath === keyInfo.key,\n                );\n\n                if (hasInvalid) {\n                    const title = `AI Localizer: Restore inline string and remove invalid key (${keyInfo.key}) (from report)`;\n                    const action = new vscode.CodeAction(title, vscode.CodeActionKind.QuickFix);\n                    action.isPreferred = true;\n                    action.command = {\n                        title,\n                        command: 'ai-localizer.i18n.restoreInvalidKeyInCode',\n                        arguments: [\n                            document.uri,\n                            { line: keyInfo.range.start.line, character: keyInfo.range.start.character },\n                            keyInfo.key,\n                        ],\n                    };\n                    actions.push(action);\n                }\n\n                await this.i18nIndex.ensureInitialized();\n                const record = this.i18nIndex.getRecord(keyInfo.key);\n                if (!record) {\n                    const title = 'AI Localizer: Fix reference';\n                    const action = new vscode.CodeAction(title, vscode.CodeActionKind.QuickFix);\n                    if (!hasInvalid) {\n                        action.isPreferred = true;\n                    }\n                    action.command = {\n                        title,\n                        command: 'ai-localizer.i18n.fixMissingKeyReference',\n                        arguments: [\n                            document.uri,\n                            { line: keyInfo.range.start.line, character: keyInfo.range.start.character },\n                            keyInfo.key,\n                        ],\n                    };\n                    actions.push(action);\n\n                    // Add bulk fix action for ts/tsx files\n                    if (document.languageId === 'typescript' || document.languageId === 'typescriptreact') {\n                        const bulkTitle = 'AI Localizer: Bulk fix all missing key references in this file';\n                        const bulkAction = new vscode.CodeAction(bulkTitle, vscode.CodeActionKind.QuickFix);\n                        bulkAction.command = {\n                            title: bulkTitle,\n                            command: 'ai-localizer.i18n.bulkFixMissingKeyReferences',\n                            arguments: [document.uri],\n                        };\n                        actions.push(bulkAction);\n                    }\n                }\n            }\n        }\n\n        const unique: vscode.CodeAction[] = [];\n        const seen = new Set<string>();\n\n        for (const action of actions) {\n            const commandId = action.command?.command || '';\n            const argsSig = action.command?.arguments ? JSON.stringify(action.command.arguments) : '';\n            const key = `${commandId}:${action.title}:${argsSig}`;\n            if (seen.has(key)) {\n                continue;\n            }\n            seen.add(key);\n            unique.push(action);\n        }\n\n        return unique;\n    }\n\n    private async loadReport(scriptsDir: vscode.Uri, fileName: string): Promise<any | null> {\n        const reportUri = vscode.Uri.joinPath(scriptsDir, fileName);\n        try {\n            const data = await vscode.workspace.fs.readFile(reportUri);\n            const raw = sharedDecoder.decode(data);\n            return JSON.parse(raw);\n        } catch {\n            return null;\n        }\n    }\n\n    private async getKeyPathForJsonRange(\n        document: vscode.TextDocument,\n        range: vscode.Range,\n    ): Promise<string | null> {\n        await this.i18nIndex.ensureInitialized();\n        const info = this.i18nIndex.getKeysForFile(document.uri);\n        const keys = info?.keys || [];\n        if (!keys.length) {\n            return null;\n        }\n        const text = document.getText();\n        for (const fullKey of keys) {\n            const keyRange = this.findKeyRangeInJsonText(document, text, fullKey);\n            if (keyRange && keyRange.intersection(range)) {\n                return fullKey;\n            }\n        }\n        return null;\n    }\n\n    private findKeyRangeInJsonText(\n        document: vscode.TextDocument,\n        text: string,\n        fullKey: string,\n    ): vscode.Range | null {\n        const parts = fullKey.split('.');\n        const lastSegment = parts[parts.length - 1];\n        if (!lastSegment) {\n            return null;\n        }\n        const needle = `\"${lastSegment}\"`;\n        let index = text.indexOf(needle);\n        while (index !== -1) {\n            let i = index + needle.length;\n            while (\n                i < text.length &&\n                (text[i] === ' ' || text[i] === '\\t' || text[i] === '\\r' || text[i] === '\\n')\n            ) {\n                i += 1;\n            }\n            if (i < text.length && text[i] === ':') {\n                const startOffset = index + 1;\n                const start = document.positionAt(startOffset);\n                const end = new vscode.Position(start.line, start.character + lastSegment.length);\n                return new vscode.Range(start, end);\n            }\n            index = text.indexOf(needle, index + needle.length);\n        }\n        return null;\n    }\n}\n\n/**\n * Register all i18n IntelliSense providers\n */\nexport function registerI18nProviders(\n    context: vscode.ExtensionContext,\n    i18nIndex: I18nIndex,\n): void {\n    const hoverProvider = new I18nHoverProvider(i18nIndex);\n    const definitionProvider = new I18nDefinitionProvider(i18nIndex);\n    const completionProvider = new I18nCompletionProvider(i18nIndex);\n    const codeActionProvider = new I18nUntranslatedCodeActionProvider(i18nIndex);\n\n    context.subscriptions.push(\n        vscode.languages.registerHoverProvider(I18N_CODE_SELECTOR, hoverProvider),\n        vscode.languages.registerDefinitionProvider(I18N_CODE_SELECTOR, definitionProvider),\n        // Completions for code files (keys)\n        vscode.languages.registerCompletionItemProvider(\n            I18N_CODE_SELECTOR,\n            completionProvider,\n            '.', // Trigger on dot\n            '\"', // Trigger on quote\n            \"'\", // Trigger on single quote\n        ),\n        // Completions for locale JSON files (known translations)\n        vscode.languages.registerCompletionItemProvider(\n            I18N_JSON_SELECTOR,\n            completionProvider,\n            '\"',\n        ),\n        vscode.languages.registerCodeActionsProvider(\n            I18N_CODE_SELECTOR,\n            codeActionProvider,\n            {\n                providedCodeActionKinds: I18nUntranslatedCodeActionProvider.providedCodeActionKinds,\n            },\n        ),\n        vscode.languages.registerCodeActionsProvider(\n            I18N_JSON_SELECTOR,\n            codeActionProvider,\n            {\n                providedCodeActionKinds: I18nUntranslatedCodeActionProvider.providedCodeActionKinds,\n            },\n        ),\n    );\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\services\\diagnosticAnalyzer.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":579,"column":49,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":579,"endColumn":62,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[23227,23228],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":580,"column":60,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":580,"endColumn":84,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[23333,23334],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":581,"column":52,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":581,"endColumn":68,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[23434,23435],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":594,"column":49,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":594,"endColumn":62,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[23992,23993],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":595,"column":60,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":595,"endColumn":84,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[24098,24099],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":596,"column":52,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":596,"endColumn":68,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[24199,24200],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\[.","line":710,"column":42,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":710,"endColumn":43,"suggestions":[{"messageId":"removeEscape","fix":{"range":[28257,28258],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[28257,28257],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\[.","line":710,"column":86,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":710,"endColumn":87,"suggestions":[{"messageId":"removeEscape","fix":{"range":[28301,28302],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[28301,28301],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\r\nimport { TextDecoder } from 'util';\r\nimport { I18nIndex, TranslationRecord } from '../core/i18nIndex';\r\nimport { ProjectConfigService } from './projectConfigService';\r\nimport { operationLock } from '../commands/untranslated/utils/operationLock';\r\n\r\n// Shared decoder instance to avoid repeated allocations\r\nconst sharedDecoder = new TextDecoder('utf-8');\r\n\r\n// Maximum number of files to keep in text cache (prevents unbounded memory growth)\r\nconst MAX_FILE_TEXT_CACHE_SIZE = 50;\r\n\r\n/**\r\n * Incremental diagnostic analyzer for i18n translation issues.\r\n * \r\n * Architecture:\r\n * - Maintains per-file diagnostic cache\r\n * - Tracks which keys are affected by each file\r\n * - Only recomputes diagnostics for keys in changed files\r\n * - Supports single-file and multi-file analysis\r\n */\r\nexport class DiagnosticAnalyzer {\r\n    private diagnosticsByFile = new Map<string, vscode.Diagnostic[]>();\r\n    private fileTextCache = new Map<\r\n        string,\r\n        { text: string; lineStarts: number[]; keyRanges: Map<string, vscode.Range> }\r\n    >();\r\n    private fileTextCacheOrder: string[] = []; // Track insertion order for LRU eviction\r\n    private styleIssuesByLocaleKey = new Map<\r\n        string,\r\n        { english?: string; current?: string; suggested?: string }\r\n    >();\r\n    private styleReportLoaded = false;\r\n    private ignorePatterns: { exact?: string[]; exactInsensitive?: string[]; contains?: string[] } | null = null;\r\n    private ignorePatternsLoaded = false;\r\n    private untranslatedIssuesByLocaleKey = new Map<string, boolean>();\r\n    private untranslatedReportActive = false;\r\n    private sourceKeySetsCache:\r\n        | {\r\n              laravelKeys: Set<string>;\r\n              jsonBackedKeys: Set<string>;\r\n              resxBackedKeys: Set<string>;\r\n              poBackedKeys: Set<string>;\r\n              keyCount: number;\r\n          }\r\n        | null = null;\r\n\r\n    constructor(\r\n        private i18nIndex: I18nIndex,\r\n        private projectConfigService: ProjectConfigService,\r\n        private log: vscode.OutputChannel,\r\n    ) {}\r\n\r\n    // Per-run logging flag (set from config)\r\n    private logVerboseEnabled = false;\r\n\r\n    private static readonly SOURCE_SUPPORTED_LANGUAGES = new Set<string>([\r\n        'typescript',\r\n        'typescriptreact',\r\n        'javascript',\r\n        'javascriptreact',\r\n        'vue',\r\n        'php',\r\n        'blade',\r\n        'csharp',\r\n        'razor',\r\n        'python',\r\n    ]);\r\n\r\n    private static readonly I18N_KEY_PATTERN = '[A-Za-z0-9_\\\\.\\\\-]+';\r\n\r\n    private buildTranslationCallPatterns(options: {\r\n        isLaravelSource: boolean;\r\n        isPythonSource: boolean;\r\n    }): Array<{ regex: RegExp; keyGroupIndex: number }> {\r\n        const { isLaravelSource, isPythonSource } = options;\r\n        const key = DiagnosticAnalyzer.I18N_KEY_PATTERN;\r\n        const patterns: Array<{ regex: RegExp; keyGroupIndex: number }> = [];\r\n\r\n        // JS/TS/Vue: t('key'), t(\"key\"), $t('key'), $t(\"key\")\r\n        patterns.push({\r\n            regex: new RegExp(`\\\\b\\\\$?t\\\\s*\\\\(\\\\s*(['\"\\`])(${key})\\\\1\\\\s*(?:,|\\\\))`, 'g'),\r\n            keyGroupIndex: 2,\r\n        });\r\n\r\n        if (isLaravelSource) {\r\n            patterns.push(\r\n                {\r\n                    regex: new RegExp(`\\\\b__\\\\s*\\\\(\\\\s*(['\"])(${key})\\\\1\\\\s*(?:,|\\\\))`, 'g'),\r\n                    keyGroupIndex: 2,\r\n                },\r\n                {\r\n                    regex: new RegExp(`\\\\btrans\\\\s*\\\\(\\\\s*(['\"])(${key})\\\\1\\\\s*(?:,|\\\\))`, 'g'),\r\n                    keyGroupIndex: 2,\r\n                },\r\n                {\r\n                    regex: new RegExp(`@lang\\\\s*\\\\(\\\\s*(['\"])(${key})\\\\1\\\\s*(?:,|\\\\))`, 'g'),\r\n                    keyGroupIndex: 2,\r\n                },\r\n            );\r\n        } else if (isPythonSource) {\r\n            // _(\"key\"), gettext('key')\r\n            patterns.push({\r\n                regex: new RegExp(`\\\\b(_|gettext)\\\\s*\\\\(\\\\s*(['\"])(${key})\\\\2\\\\s*(?:,|\\\\))`, 'g'),\r\n                keyGroupIndex: 3,\r\n            });\r\n        }\r\n\r\n        return patterns;\r\n    }\r\n\r\n    /**\r\n     * Suppress verbose logging while bulk operations (key management, translations, cleanup) are running.\r\n     */\r\n    private isQuietMode(): boolean {\r\n        const current = operationLock.getCurrentOperation();\r\n        if (!current) return false;\r\n        return [\r\n            'key-management',\r\n            'translation-project',\r\n            'translation-file',\r\n            'cleanup-unused',\r\n            'cleanup-invalid',\r\n            'style-fix',\r\n        ].includes(current.type);\r\n    }\r\n\r\n    private safeLog(message: string): void {\r\n        if (!this.logVerboseEnabled) return;\r\n        if (this.isQuietMode()) return;\r\n        this.log.appendLine(message);\r\n    }\r\n\r\n    private verboseLog(message: string, enabled: boolean): void {\r\n        if (!enabled) return;\r\n        this.safeLog(message);\r\n    }\r\n\r\n    /**\r\n     * Analyze a single locale file and return diagnostics for it.\r\n     * This is the core incremental analysis method.\r\n     */\r\n    async analyzeFile(\r\n        uri: vscode.Uri,\r\n        config: DiagnosticConfig,\r\n        extraKeys?: string[],\r\n        forcedLocales?: string[],\r\n    ): Promise<vscode.Diagnostic[]> {\r\n        this.logVerboseEnabled = config.verboseLogging === true;\r\n        const fileKey = uri.toString();\r\n        // Invalidate cached text/range data so we always analyze the latest version\r\n        this.fileTextCache.delete(fileKey);\r\n        this.safeLog(`[DiagnosticAnalyzer] Analyzing file: ${uri.fsPath}`);\r\n        const verbose = config.verboseLogging === true;\r\n\r\n        // Get keys contributed by this file\r\n        const fileInfo = this.i18nIndex.getKeysForFile(uri);\r\n        \r\n        // If no keys in this file, we still need to check if this is a locale file\r\n        // that should have keys from the default locale\r\n        const fileLocale = fileInfo?.locale;\r\n        const fileKeys = fileInfo?.keys || [];\r\n        const keysToAnalyze = extraKeys && extraKeys.length\r\n            ? Array.from(new Set<string>([...fileKeys, ...extraKeys]))\r\n            : fileKeys;\r\n        \r\n        if (!fileLocale) {\r\n            this.safeLog(`[DiagnosticAnalyzer] Cannot determine locale for file: ${uri.fsPath}`);\r\n            return [];\r\n        }\r\n        \r\n        this.verboseLog(\r\n            `[DiagnosticAnalyzer] File has ${fileKeys.length} key(s) for locale '${fileLocale}' (analyzing ${keysToAnalyze.length})`,\r\n            verbose,\r\n        );\r\n        const diagnostics: vscode.Diagnostic[] = [];\r\n\r\n        // Get workspace folder config\r\n        const folder = vscode.workspace.getWorkspaceFolder(uri);\r\n        if (!folder) {\r\n            return [];\r\n        }\r\n\r\n        const projectConfig = await this.projectConfigService.readConfig(folder);\r\n        const defaultLocaleGlobal = config.defaultLocale || 'en';\r\n        const discoveredLocales = this.i18nIndex.getAllLocales();\r\n        const configuredLocales = projectConfig?.locales || [];\r\n\r\n        // If the project has an explicit locale list (aiI18n.locales in package.json),\r\n        // treat that as the source of truth and only analyze those locales (plus default).\r\n        // Otherwise, fall back to all discovered locales in the workspace.\r\n        let localesBase: string[];\r\n        if (projectConfig && configuredLocales.length > 0) {\r\n            const set = new Set<string>([defaultLocaleGlobal, ...configuredLocales]);\r\n            localesBase = Array.from(set);\r\n        } else {\r\n            const union = new Set<string>([...discoveredLocales, defaultLocaleGlobal]);\r\n            localesBase = [\r\n                defaultLocaleGlobal,\r\n                ...Array.from(union).filter((l) => l !== defaultLocaleGlobal),\r\n            ];\r\n        }\r\n\r\n        const localesSet = new Set<string>(localesBase);\r\n        for (const fl of forcedLocales || []) {\r\n            if (fl) localesSet.add(fl);\r\n        }\r\n        const locales = Array.from(localesSet);\r\n\r\n        // For each key in this file (plus any extra changed keys), check all locales\r\n        for (const key of keysToAnalyze) {\r\n            const record = this.i18nIndex.getRecord(key);\r\n            if (!record) {\r\n                continue;\r\n            }\r\n\r\n            const defaultLocaleForKey = record.defaultLocale || defaultLocaleGlobal;\r\n            const defaultValueRaw =\r\n                record.locales.get(defaultLocaleForKey) ??\r\n                record.locales.get(defaultLocaleGlobal);\r\n            const hasDefaultValue = typeof defaultValueRaw === 'string' && !!defaultValueRaw.trim();\r\n            const defaultValue = hasDefaultValue ? (defaultValueRaw as string) : '';\r\n            const defaultPlaceholders = hasDefaultValue\r\n                ? this.extractPlaceholders(defaultValue)\r\n                : new Set<string>();\r\n\r\n            const isConstantLikeAcrossLocales = this.isProbablyConstantAcrossLocales(\r\n                record,\r\n                defaultLocaleForKey,\r\n                defaultValue,\r\n            );\r\n\r\n            // Base value flags:\r\n            // - baseLooksNonTranslatable: clearly technical / CSS / code, should not be translated\r\n            // - baseIsIgnored: user-configured ignore pattern (suppress untranslated/missing diagnostics)\r\n            const baseLooksNonTranslatable =\r\n                hasDefaultValue && this.isProbablyNonTranslatable(defaultValue);\r\n            const baseIsIgnored = hasDefaultValue && this.isIgnoredText(defaultValue);\r\n\r\n            this.verboseLog(\r\n                `[DiagnosticAnalyzer] Checking key '${key}' (default='${defaultLocaleForKey}') in file '${uri.fsPath}' (fileLocale='${fileLocale}')`,\r\n                verbose,\r\n            );\r\n\r\n            // Emit a dedicated diagnostic when the default-locale value itself looks invalid/non-translatable.\r\n            // This runs only when analyzing the default-locale file for this key so Problems entries are stable.\r\n            // NOTE: we only use heuristic detection here; user ignore patterns (baseIsIgnored) do NOT trigger\r\n            // an invalid diagnostic, they simply suppress untranslated/missing diagnostics.\r\n            if (fileLocale === defaultLocaleForKey && baseLooksNonTranslatable) {\r\n                const range = await this.getKeyRangeInFile(uri, key);\r\n                const invalidDiag = new vscode.Diagnostic(\r\n                    range,\r\n                    `Invalid/non-translatable value \"${key}\" [${defaultLocaleForKey}]`,\r\n                    config.invalidSeverity,\r\n                );\r\n                invalidDiag.code = 'ai-i18n.invalid';\r\n                diagnostics.push(invalidDiag);\r\n            }\r\n\r\n            // Check all locales for this key\r\n            for (const locale of locales) {\r\n                if (locale === defaultLocaleForKey) {\r\n                    continue;\r\n                }\r\n\r\n                const val = record.locales.get(locale);\r\n                const locEntry = record.locations.find((l) => l.locale === locale);\r\n\r\n                // Determine if we should report diagnostics for this locale in this file:\r\n                // 1. If this file IS the locale file (fileLocale === locale), always report\r\n                // 2. If this file is the DEFAULT locale and the key is missing in target locale, report\r\n                // 3. If locEntry exists but points to a different file, skip (that file will handle it)\r\n                \r\n                const shouldReport = \r\n                    fileLocale === locale || // This file owns this locale\r\n                    (fileLocale === defaultLocaleForKey && !locEntry); // Default-locale file reporting missing translations\r\n                \r\n                if (!shouldReport) {\r\n                    // Skip if another file owns this locale\r\n                    if (locEntry && locEntry.uri.toString() !== fileKey) {\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                // Avoid duplicate missing diagnostics: only the default-locale file should emit\r\n                if ((!val || !val.trim()) && fileLocale !== defaultLocaleForKey) {\r\n                    continue;\r\n                }\r\n\r\n                this.verboseLog(\r\n                    `[DiagnosticAnalyzer] Considering locale '${locale}' for key '${key}': ` +\r\n                    `val=${val ? 'present' : 'missing'}, locEntry=${!!locEntry}, shouldReport=${shouldReport}`,\r\n                    verbose,\r\n                );\r\n\r\n                if (!val || !val.trim()) {\r\n                    this.verboseLog(\r\n                        `[DiagnosticAnalyzer] Missing translation detected for key '${key}' in locale '${locale}' while analyzing file '${uri.fsPath}' (fileLocale='${fileLocale}', defaultLocale='${defaultLocaleForKey}')`,\r\n                        verbose,\r\n                    );\r\n                }\r\n\r\n                const issues = this.analyzeKeyForLocale(\r\n                    key,\r\n                    locale,\r\n                    val,\r\n                    defaultValue,\r\n                    defaultPlaceholders,\r\n                    config,\r\n                    isConstantLikeAcrossLocales,\r\n                    baseIsIgnored || baseLooksNonTranslatable,\r\n                );\r\n\r\n                for (const issue of issues) {\r\n                    const range = await this.getKeyRangeInFile(uri, key);\r\n                    const diagnostic = new vscode.Diagnostic(\r\n                        range,\r\n                        issue.message,\r\n                        issue.severity,\r\n                    );\r\n                    diagnostic.code = issue.code;\r\n                    diagnostics.push(diagnostic);\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        this.diagnosticsByFile.set(fileKey, diagnostics);\r\n        this.safeLog(\r\n            `[DiagnosticAnalyzer] Found ${diagnostics.length} diagnostic(s) for file: ${uri.fsPath}`,\r\n        );\r\n        return diagnostics;\r\n    }\r\n\r\n    /**\r\n     * Analyze multiple files in parallel.\r\n     */\r\n    async analyzeFiles(\r\n        uris: vscode.Uri[],\r\n        config: DiagnosticConfig,\r\n    ): Promise<Map<string, vscode.Diagnostic[]>> {\r\n        this.logVerboseEnabled = config.verboseLogging === true;\r\n        this.safeLog(`[DiagnosticAnalyzer] Analyzing ${uris.length} file(s)...`);\r\n        const results: { uri: string; diagnostics: vscode.Diagnostic[] }[] = new Array(uris.length);\r\n\r\n        const concurrency = Math.max(\r\n            1,\r\n            Number(process.env.AI_I18N_DIAG_CONCURRENCY || 8),\r\n        );\r\n        let index = 0;\r\n\r\n        const worker = async () => {\r\n            while (true) {\r\n                const current = index;\r\n                index += 1;\r\n                if (current >= uris.length) {\r\n                    break;\r\n                }\r\n                const uri = uris[current];\r\n                const diagnostics = await this.analyzeFile(uri, config);\r\n                results[current] = { uri: uri.toString(), diagnostics };\r\n            }\r\n        };\r\n\r\n        const workerCount = Math.min(concurrency, uris.length);\r\n        const workers: Promise<void>[] = [];\r\n        for (let i = 0; i < workerCount; i += 1) {\r\n            workers.push(worker());\r\n        }\r\n        await Promise.all(workers);\r\n\r\n        const map = new Map<string, vscode.Diagnostic[]>();\r\n        for (const result of results) {\r\n            if (!result) continue;\r\n            map.set(result.uri, result.diagnostics);\r\n        }\r\n\r\n        return map;\r\n    }\r\n\r\n    /**\r\n     * Analyze all locale files in the index.\r\n     */\r\n    async analyzeAll(config: DiagnosticConfig): Promise<Map<string, vscode.Diagnostic[]>> {\r\n        this.logVerboseEnabled = config.verboseLogging === true;\r\n        this.safeLog('[DiagnosticAnalyzer] Performing full analysis...');\r\n\r\n        // Collect all unique locale file URIs from the index\r\n        const allKeys = this.i18nIndex.getAllKeys();\r\n        const fileUris = new Set<string>();\r\n\r\n        for (const key of allKeys) {\r\n            const record = this.i18nIndex.getRecord(key);\r\n            if (!record) {\r\n                continue;\r\n            }\r\n            for (const loc of record.locations) {\r\n                fileUris.add(loc.uri.toString());\r\n            }\r\n        }\r\n\r\n        const uris = Array.from(fileUris).map((uriStr) => vscode.Uri.parse(uriStr));\r\n        return this.analyzeFiles(uris, config);\r\n    }\r\n\r\n    /**\r\n     * Reset all caches. Call before a full re-analysis.\r\n     */\r\n    resetCaches(): void {\r\n        this.diagnosticsByFile.clear();\r\n        this.fileTextCache.clear();\r\n        this.fileTextCacheOrder = [];\r\n        this.styleIssuesByLocaleKey.clear();\r\n        this.styleReportLoaded = false;\r\n        this.untranslatedIssuesByLocaleKey.clear();\r\n        this.untranslatedReportActive = false;\r\n        this.ignorePatterns = null;\r\n        this.ignorePatternsLoaded = false;\r\n        this.sourceKeySetsCache = null;\r\n    }\r\n\r\n    /**\r\n     * Invalidate untranslated report entries for specific keys.\r\n     * This should be called when translation files are edited to ensure\r\n     * stale report data doesn't cause incorrect diagnostics.\r\n     */\r\n    invalidateUntranslatedReportKeys(keys: string[]): void {\r\n        if (!this.untranslatedReportActive || !keys.length) {\r\n            return;\r\n        }\r\n\r\n        // Get all locales from the index to invalidate all locale variants of each key\r\n        const allLocales = this.i18nIndex.getAllLocales();\r\n        \r\n        for (const key of keys) {\r\n            for (const locale of allLocales) {\r\n                const reportKey = `${key}::${locale}`;\r\n                this.untranslatedIssuesByLocaleKey.delete(reportKey);\r\n            }\r\n        }\r\n\r\n        // If all entries are cleared, deactivate the report\r\n        if (this.untranslatedIssuesByLocaleKey.size === 0) {\r\n            this.untranslatedReportActive = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load style issues from .i18n-untranslated-style.json report.\r\n     */\r\n    async loadStyleReport(\r\n        workspaceFolders: readonly vscode.WorkspaceFolder[],\r\n        force = false,\r\n    ): Promise<void> {\r\n        if (this.styleReportLoaded && !force) {\r\n            return;\r\n        }\r\n\r\n        this.styleIssuesByLocaleKey.clear();\r\n\r\n        for (const folder of workspaceFolders) {\r\n            try {\r\n                const styleUri = vscode.Uri.joinPath(\r\n                    folder.uri,\r\n                    'scripts',\r\n                    '.i18n-untranslated-style.json',\r\n                );\r\n                const data = await vscode.workspace.fs.readFile(styleUri);\r\n                const raw = sharedDecoder.decode(data);\r\n                const report: any = JSON.parse(raw);\r\n                const files = Array.isArray(report?.files) ? report.files : [];\r\n\r\n                for (const file of files) {\r\n                    const locale = typeof file?.locale === 'string' ? file.locale : null;\r\n                    const issues = Array.isArray(file?.issues) ? file.issues : [];\r\n                    if (!locale || !issues.length) {\r\n                        continue;\r\n                    }\r\n\r\n                    for (const issue of issues) {\r\n                        const keyPath = typeof issue?.keyPath === 'string' ? issue.keyPath : null;\r\n                        if (!keyPath) {\r\n                            continue;\r\n                        }\r\n                        const mapKey = `${keyPath}::${locale}`;\r\n                        if (!this.styleIssuesByLocaleKey.has(mapKey)) {\r\n                            this.styleIssuesByLocaleKey.set(mapKey, {\r\n                                english: typeof issue.english === 'string' ? issue.english : undefined,\r\n                                current: typeof issue.current === 'string' ? issue.current : undefined,\r\n                                suggested: typeof issue.suggested === 'string' ? issue.suggested : undefined,\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            } catch {\r\n                // Style report is optional\r\n            }\r\n        }\r\n        this.styleReportLoaded = true;\r\n    }\r\n\r\n    async loadUntranslatedReport(\r\n        workspaceFolders: readonly vscode.WorkspaceFolder[],\r\n        force = false,\r\n    ): Promise<void> {\r\n        if (this.untranslatedReportActive && !force) {\r\n            return;\r\n        }\r\n\r\n        this.untranslatedIssuesByLocaleKey.clear();\r\n        this.untranslatedReportActive = false;\r\n\r\n        for (const folder of workspaceFolders) {\r\n            try {\r\n                const reportUri = vscode.Uri.joinPath(\r\n                    folder.uri,\r\n                    'scripts',\r\n                    '.i18n-untranslated-untranslated.json',\r\n                );\r\n                const data = await vscode.workspace.fs.readFile(reportUri);\r\n                const raw = sharedDecoder.decode(data);\r\n                const report: any = JSON.parse(raw);\r\n                const files = Array.isArray(report?.files) ? report.files : [];\r\n\r\n                for (const file of files) {\r\n                    const locale = typeof file?.locale === 'string' ? file.locale : null;\r\n                    const issues = Array.isArray(file?.issues) ? file.issues : [];\r\n                    if (!locale || !issues.length) {\r\n                        continue;\r\n                    }\r\n\r\n                    for (const issue of issues) {\r\n                        const keyPath = typeof issue?.keyPath === 'string' ? issue.keyPath : null;\r\n                        if (!keyPath) {\r\n                            continue;\r\n                        }\r\n                        const mapKey = `${keyPath}::${locale}`;\r\n                        if (!this.untranslatedIssuesByLocaleKey.has(mapKey)) {\r\n                            this.untranslatedIssuesByLocaleKey.set(mapKey, true);\r\n                        }\r\n                    }\r\n                }\r\n            } catch {\r\n                // Optional report; ignore missing/invalid files and move on to the next folder\r\n            }\r\n        }\r\n\r\n        if (this.untranslatedIssuesByLocaleKey.size > 0) {\r\n            this.untranslatedReportActive = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load ignore patterns from scripts/i18n-ignore-patterns.json if present.\r\n     */\r\n    async loadIgnorePatterns(\r\n        workspaceFolders: readonly vscode.WorkspaceFolder[],\r\n        force = false,\r\n    ): Promise<void> {\r\n        if (this.ignorePatternsLoaded && !force) {\r\n            return;\r\n        }\r\n\r\n        const merged: { exact?: string[]; exactInsensitive?: string[]; contains?: string[] } = {\r\n            exact: [],\r\n            exactInsensitive: [],\r\n            contains: [],\r\n        };\r\n        for (const folder of workspaceFolders) {\r\n            try {\r\n                const ignoreUri = vscode.Uri.joinPath(\r\n                    folder.uri,\r\n                    'scripts',\r\n                    'i18n-ignore-patterns.json',\r\n                );\r\n                const data = await vscode.workspace.fs.readFile(ignoreUri);\r\n                const raw = sharedDecoder.decode(data);\r\n                const json = JSON.parse(raw);\r\n                if (Array.isArray(json?.exact)) merged.exact!.push(...json.exact);\r\n                if (Array.isArray(json?.exactInsensitive)) merged.exactInsensitive!.push(...json.exactInsensitive);\r\n                if (Array.isArray(json?.contains)) merged.contains!.push(...json.contains);\r\n            } catch {\r\n                // ignore missing/invalid files\r\n            }\r\n            try {\r\n                const autoUri = vscode.Uri.joinPath(\r\n                    folder.uri,\r\n                    'scripts',\r\n                    '.i18n-auto-ignore.json',\r\n                );\r\n                const data = await vscode.workspace.fs.readFile(autoUri);\r\n                const raw = sharedDecoder.decode(data);\r\n                const json = JSON.parse(raw);\r\n                if (Array.isArray(json?.exact)) merged.exact!.push(...json.exact);\r\n                if (Array.isArray(json?.exactInsensitive)) merged.exactInsensitive!.push(...json.exactInsensitive);\r\n                if (Array.isArray(json?.contains)) merged.contains!.push(...json.contains);\r\n            } catch {\r\n                // ignore missing/invalid auto-ignore files\r\n            }\r\n        }\r\n        this.ignorePatterns = merged;\r\n        this.ignorePatternsLoaded = true;\r\n    }\r\n\r\n    private isIgnoredText(text: string): boolean {\r\n        const pat = this.ignorePatterns;\r\n        if (!pat) return false;\r\n        const normalized = String(text || '').replace(/\\s+/g, ' ').trim();\r\n        if (!normalized) return false;\r\n        if (Array.isArray(pat.exact) && pat.exact.includes(normalized)) return true;\r\n        if (Array.isArray(pat.exactInsensitive)) {\r\n            const lower = normalized.toLowerCase();\r\n            for (const v of pat.exactInsensitive) {\r\n                if (String(v || '').toLowerCase() === lower) return true;\r\n            }\r\n        }\r\n        if (Array.isArray(pat.contains)) {\r\n            for (const sub of pat.contains) {\r\n                if (sub && normalized.includes(String(sub))) return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private isPlaceholderOnlyText(text: string): boolean {\r\n        const trimmed = String(text || '').trim();\r\n        if (!trimmed) {\r\n            return false;\r\n        }\r\n        let stripped = trimmed\r\n            .replace(/\\{\\{\\s*[^}]+\\s*\\}\\}/g, ' ')\r\n            .replace(/\\{[A-Za-z0-9_]+(?:\\.[A-Za-z0-9_]+)*\\}/g, ' ');\r\n        stripped = stripped.replace(/[()[\\]{}.,:;'\"!?\\\\-_]/g, ' ');\r\n        stripped = stripped.replace(/\\s+/g, ' ').trim();\r\n        if (!stripped) {\r\n            return true;\r\n        }\r\n        if (!/[A-Za-z]/.test(stripped)) {\r\n            return true;\r\n        }\r\n        const letters = stripped.replace(/[^A-Za-z]/g, '');\r\n        if (letters.length <= 1 && stripped.length <= 3) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Detect values that are clearly extraction errors and should be removed/restored.\r\n     * These are technical fragments that should never have been translation keys.\r\n     * Examples:\r\n     *   - \"?duration=\" (query fragment)\r\n     *   - \"/schedule/\" (path fragment)\r\n     *   - \"{value1} {value2} {value3} {value4}\" (placeholder-only)\r\n     *   - \"font-medium {color}\" (CSS + placeholder)\r\n     */\r\n    private isProbablyNonTranslatable(text: string): boolean {\r\n        const normalized = String(text || '').trim();\r\n        if (!normalized) return false;\r\n\r\n        // Placeholder-only text (no real words, just placeholders and punctuation)\r\n        if (this.isPlaceholderOnlyText(normalized)) {\r\n            return true;\r\n        }\r\n\r\n        // CSS/utility class patterns with placeholders like \"font-medium {color}\"\r\n        if (this.isCssWithPlaceholders(normalized)) {\r\n            return true;\r\n        }\r\n\r\n        if (this.isCssUtilityString(normalized)) {\r\n            return true;\r\n        }\r\n\r\n        if (/\\{[^}]*:[^;]+;[^}]*\\}/.test(normalized)) {\r\n            return true;\r\n        }\r\n\r\n        if (\r\n            normalized.includes('class=\"') ||\r\n            normalized.includes(\"class='\") ||\r\n            normalized.includes('style=\"') ||\r\n            normalized.includes(\"style='\") ||\r\n            /@\\w+\\s*=/.test(normalized)\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        if (/^\\s*(height|width|margin|padding|font(?:-family)?|color|background|border)[^;{]*;?\\s*$/.test(normalized)) {\r\n            return true;\r\n        }\r\n\r\n        if (/^\\s*(sans|serif|mono|monospace|system)\\s*\\([^)]+\\)\\s*$/i.test(normalized)) {\r\n            return true;\r\n        }\r\n\r\n        if (\r\n            /\\{\\{\\s*[^}]+\\s*\\}\\}/.test(normalized) &&\r\n            (/[?:]/.test(normalized) || /\\|\\|/.test(normalized) || /&&/.test(normalized) || /\\.length\\b/.test(normalized))\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        // UUID-like strings\r\n        if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(normalized)) {\r\n            return true;\r\n        }\r\n\r\n        // Complex CSS/utility token (single token with :, [], etc.)\r\n        if (!/\\s/.test(normalized) && /[:\\[\\]]/.test(normalized) && /^[A-Za-z0-9:._\\-\\[\\]]+$/.test(normalized)) {\r\n            return true;\r\n        }\r\n\r\n        // Obvious JS-ish code with common keywords\r\n        if (/[{};]/.test(normalized) && /\\b(const|let|var|function|return|if|else|for|while|class|async|await)\\b/.test(normalized)) {\r\n            return true;\r\n        }\r\n\r\n        // Analytics / object-literal style code snippets (e.g. gtag(... { 'send_to': ... }); )\r\n        if (\r\n            normalized.includes('gtag(') ||\r\n            (/[{}]/.test(normalized) && /['\"][^'\"]+['\"]\\s*:/.test(normalized))\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        // Obvious URLs\r\n        if (/^https?:\\/\\//i.test(normalized) || /^www\\./i.test(normalized)) return true;\r\n\r\n        // Filesystem-like paths (e.g. \"/schedule/\", \"/api/v1\", \"C:\\\\path\")\r\n        if (/^\\/[A-Za-z0-9_/-]+\\/?$/.test(normalized)) return true;\r\n        if (/^\\\\\\\\[^\\s]+/.test(normalized) || /^[A-Za-z]:[\\\\/][^\\s]*$/.test(normalized)) return true;\r\n\r\n        // Query-string fragments (e.g. \"?duration=\", \"?lang=en\", \"foo=bar&baz=qux\")\r\n        if (!/\\s/.test(normalized)) {\r\n            // Starts with ? or # and has key=value pattern\r\n            if (/^[?#][A-Za-z0-9_.-]+=/.test(normalized)) return true;\r\n            // Pure query string without leading ?\r\n            if (/^[A-Za-z0-9_.-]+=[^&\\s]*(&[A-Za-z0-9_.-]+=[^&\\s]*)+$/.test(normalized)) return true;\r\n        }\r\n\r\n        // Single character\r\n        if (normalized.length === 1) return true;\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Detect CSS/utility class patterns mixed with placeholders.\r\n     * Examples: \"font-medium {color}\", \"w-full {value1}\", \"text-{size} font-bold\"\r\n     */\r\n    private isCssWithPlaceholders(text: string): boolean {\r\n        const hasPlaceholder = /\\{[A-Za-z0-9_]+\\}/.test(text);\r\n        if (!hasPlaceholder) return false;\r\n\r\n        // Remove placeholders and check if remaining looks like CSS classes\r\n        const withoutPlaceholders = text.replace(/\\{[A-Za-z0-9_]+\\}/g, '').trim();\r\n        if (!withoutPlaceholders) return true; // Only placeholders\r\n\r\n        // Check if remaining parts look like CSS utility classes (kebab-case tokens)\r\n        const tokens = withoutPlaceholders.split(/\\s+/).filter(Boolean);\r\n        if (tokens.length === 0) return true;\r\n\r\n        // If all remaining tokens are kebab-case or utility-like, it's CSS\r\n        const cssLikeTokens = tokens.filter(t => /^[a-z][a-z0-9]*(-[a-z0-9]+)+$/i.test(t));\r\n        return cssLikeTokens.length === tokens.length;\r\n    }\r\n\r\n    private isCssUtilityString(text: string): boolean {\r\n        const withoutPlaceholders = text\r\n            .replace(/\\{\\{\\s*[^}]+\\s*\\}\\}/g, ' ')\r\n            .replace(/\\{[A-Za-z0-9_]+(?:\\.[A-Za-z0-9_]+)*\\}/g, ' ');\r\n        const tokens = withoutPlaceholders.split(/\\s+/).filter(Boolean);\r\n        if (tokens.length < 3) {\r\n            return false;\r\n        }\r\n\r\n        const cssKeywords = new Set([\r\n            'absolute',\r\n            'relative',\r\n            'fixed',\r\n            'sticky',\r\n            'static',\r\n            'transform',\r\n            'inline',\r\n            'block',\r\n            'flex',\r\n            'grid',\r\n        ]);\r\n\r\n        let cssLikeCount = 0;\r\n        for (const token of tokens) {\r\n            const lower = token.toLowerCase();\r\n            if (cssKeywords.has(lower)) {\r\n                cssLikeCount += 1;\r\n                continue;\r\n            }\r\n            if (/^-?[a-z][a-z0-9]*(?:-[a-z0-9/:%]+)+$/.test(lower)) {\r\n                cssLikeCount += 1;\r\n                continue;\r\n            }\r\n            if (/^[a-z]+[0-9]+$/.test(lower)) {\r\n                cssLikeCount += 1;\r\n            }\r\n        }\r\n\r\n        return cssLikeCount >= 3 && cssLikeCount / tokens.length >= 0.6;\r\n    }\r\n\r\n    private isProbablyConstantAcrossLocales(\r\n        record: TranslationRecord,\r\n        defaultLocale: string,\r\n        defaultValue: string,\r\n    ): boolean {\r\n        const base = String(defaultValue || '').trim();\r\n        if (!base) {\r\n            return false;\r\n        }\r\n\r\n        const normalized = base.replace(/\\s+/g, ' ');\r\n        const words = normalized.split(/\\s+/).filter(Boolean);\r\n        const wordCount = words.length;\r\n\r\n        // Expanded heuristics for constants:\r\n        // 1. Short token-like strings (brand names, technical terms)\r\n        // 2. Strings with numbers or special chars (version numbers, codes)\r\n        // 3. Single capitalized words (proper nouns)\r\n        // 4. Strings that are intentionally the same (OK, Cancel, etc.)\r\n        const isTokenLike =\r\n            (wordCount <= 3 && normalized.length <= 32) ||\r\n            /[0-9]/.test(normalized) ||\r\n            /^[A-Z][a-z]+$/.test(normalized) ||\r\n            /^[A-Z]+$/.test(normalized);\r\n\r\n        if (!isTokenLike) {\r\n            return false;\r\n        }\r\n\r\n        // Check if value is the same across multiple locales\r\n        let sameCount = 0;\r\n        const nonDefaultLocales = Array.from(record.locales.keys()).filter(\r\n            (l) => l !== defaultLocale,\r\n        );\r\n        for (const locale of nonDefaultLocales) {\r\n            const value = record.locales.get(locale);\r\n            if (typeof value !== 'string') {\r\n                continue;\r\n            }\r\n            if (value.trim() === base) {\r\n                sameCount += 1;\r\n            }\r\n        }\r\n\r\n        // If at least one other locale has the same value, it's likely intentional\r\n        const requiredSame = 1;\r\n        return sameCount >= requiredSame;\r\n    }\r\n\r\n    private analyzeKeyForLocale(\r\n        key: string,\r\n        locale: string,\r\n        value: string | undefined,\r\n        defaultValue: string,\r\n        defaultPlaceholders: Set<string>,\r\n        config: DiagnosticConfig,\r\n        isConstantLikeAcrossLocales: boolean,\r\n        isBaseNonTranslatable: boolean,\r\n    ): Array<{ message: string; severity: vscode.DiagnosticSeverity; code: string }> {\r\n        const issues: Array<{ message: string; severity: vscode.DiagnosticSeverity; code: string }> = [];\r\n\r\n        // Check for missing translation\r\n        if (!value || !value.trim()) {\r\n            if (!isBaseNonTranslatable) {\r\n                issues.push({\r\n                    message: `Missing translation for \"${key}\" [${locale}]`,\r\n                    severity: config.missingSeverity,\r\n                    code: 'ai-i18n.untranslated',\r\n                });\r\n            }\r\n            return issues; // No point checking placeholders if value is missing\r\n        }\r\n\r\n        // Check for untranslated (same as default) and apply ignore patterns/heuristics\r\n        if (config.untranslatedEnabled && value === defaultValue) {\r\n            const ignore =\r\n                isConstantLikeAcrossLocales ||\r\n                isBaseNonTranslatable;\r\n\r\n            let allowedByReport = true;\r\n            if (this.untranslatedReportActive) {\r\n                const reportKey = `${key}::${locale}`;\r\n                allowedByReport = this.untranslatedIssuesByLocaleKey.has(reportKey);\r\n            }\r\n\r\n            if (!ignore && allowedByReport) {\r\n                issues.push({\r\n                    message: `Untranslated (same as default) \"${key}\" [${locale}]`,\r\n                    severity: config.untranslatedSeverity,\r\n                    code: 'ai-i18n.untranslated',\r\n                });\r\n            }\r\n        }\r\n\r\n        // Check for placeholder mismatch\r\n        if (defaultPlaceholders.size > 0) {\r\n            const localePlaceholders = this.extractPlaceholders(value);\r\n            let mismatch = false;\r\n\r\n            if (localePlaceholders.size !== defaultPlaceholders.size) {\r\n                mismatch = true;\r\n            } else {\r\n                for (const token of defaultPlaceholders) {\r\n                    if (!localePlaceholders.has(token)) {\r\n                        mismatch = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (mismatch) {\r\n                const expected = Array.from(defaultPlaceholders).join(', ');\r\n                const message =\r\n                    expected.length > 0\r\n                        ? `Placeholder mismatch \"${key}\" [${locale}] (expected: ${expected})`\r\n                        : `Placeholder mismatch \"${key}\" [${locale}]`;\r\n                issues.push({\r\n                    message,\r\n                    severity: vscode.DiagnosticSeverity.Warning,\r\n                    code: 'ai-i18n.placeholders',\r\n                });\r\n            }\r\n        }\r\n\r\n        // Check for style issues\r\n        const styleKey = `${key}::${locale}`;\r\n        const styleInfo = this.styleIssuesByLocaleKey.get(styleKey);\r\n        if (styleInfo) {\r\n            const normalizedValue = String(value || '').replace(/\\s+/g, ' ').trim();\r\n            const normalizedCurrent =\r\n                typeof styleInfo.current === 'string'\r\n                    ? styleInfo.current.replace(/\\s+/g, ' ').trim()\r\n                    : '';\r\n            const normalizedSuggested =\r\n                typeof styleInfo.suggested === 'string'\r\n                    ? styleInfo.suggested.replace(/\\s+/g, ' ').trim()\r\n                    : '';\r\n\r\n            if (\r\n                (normalizedCurrent && normalizedValue !== normalizedCurrent) ||\r\n                (!normalizedCurrent && normalizedSuggested && normalizedValue === normalizedSuggested)\r\n            ) {\r\n                return issues;\r\n            }\r\n\r\n            const parts: string[] = [];\r\n            if (typeof styleInfo.current === 'string') {\r\n                parts.push(`current: ${styleInfo.current}`);\r\n            }\r\n            if (typeof styleInfo.suggested === 'string') {\r\n                parts.push(`suggested: ${styleInfo.suggested}`);\r\n            }\r\n            const details = parts.length ? ` (${parts.join(' | ')})` : '';\r\n            issues.push({\r\n                message: `Style suggestion \"${key}\" [${locale}]${details}`,\r\n                severity: vscode.DiagnosticSeverity.Information,\r\n                code: 'ai-i18n.style',\r\n            });\r\n        }\r\n\r\n        return issues;\r\n    }\r\n\r\n    /**\r\n     * Extract placeholders from a translation string.\r\n     */\r\n    private extractPlaceholders(text: string): Set<string> {\r\n        const result = new Set<string>();\r\n        if (!text) {\r\n            return result;\r\n        }\r\n        const single = /\\{[A-Za-z0-9_]+(?:\\.[A-Za-z0-9_]+)*\\}/g;\r\n        const double = /\\{\\{\\s*[^}]+\\s*\\}\\}/g;\r\n        let match: RegExpExecArray | null;\r\n        // eslint-disable-next-line no-cond-assign\r\n        while ((match = single.exec(text)) !== null) {\r\n            result.add(match[0]);\r\n        }\r\n        // eslint-disable-next-line no-cond-assign\r\n        while ((match = double.exec(text)) !== null) {\r\n            result.add(match[0]);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get the range of a key in a locale file, with caching.\r\n     */\r\n    private async getKeyRangeInFile(uri: vscode.Uri, fullKey: string): Promise<vscode.Range> {\r\n        const cacheKey = uri.toString();\r\n        let cached = this.fileTextCache.get(cacheKey);\r\n\r\n        if (!cached) {\r\n            try {\r\n                const data = await vscode.workspace.fs.readFile(uri);\r\n                const text = sharedDecoder.decode(data);\r\n                const lineStarts: number[] = [0];\r\n                for (let i = 0; i < text.length; i += 1) {\r\n                    if (text.charCodeAt(i) === 10) {\r\n                        lineStarts.push(i + 1);\r\n                    }\r\n                }\r\n                cached = { text, lineStarts, keyRanges: new Map<string, vscode.Range>() };\r\n                \r\n                // LRU eviction: remove oldest entries if at capacity\r\n                while (this.fileTextCacheOrder.length >= MAX_FILE_TEXT_CACHE_SIZE) {\r\n                    const oldest = this.fileTextCacheOrder.shift();\r\n                    if (oldest) {\r\n                        this.fileTextCache.delete(oldest);\r\n                    }\r\n                }\r\n                \r\n                this.fileTextCache.set(cacheKey, cached);\r\n                this.fileTextCacheOrder.push(cacheKey);\r\n            } catch {\r\n                return new vscode.Range(new vscode.Position(0, 0), new vscode.Position(0, 0));\r\n            }\r\n        }\r\n\r\n        const { text, lineStarts, keyRanges } = cached;\r\n\r\n        const existingRange = keyRanges.get(fullKey);\r\n        if (existingRange) {\r\n            return existingRange;\r\n        }\r\n\r\n        const parts = fullKey.split('.');\r\n        const lastSegment = parts[parts.length - 1];\r\n        if (!lastSegment) {\r\n            return new vscode.Range(new vscode.Position(0, 0), new vscode.Position(0, 0));\r\n        }\r\n\r\n        const lowerFsPath = uri.fsPath.replace(/\\\\/g, '/').toLowerCase();\r\n        const isPhpLocaleFile =\r\n            lowerFsPath.endsWith('.php') &&\r\n            (lowerFsPath.includes('/lang/') || lowerFsPath.includes('/resources/lang/'));\r\n\r\n        if (isPhpLocaleFile) {\r\n            const escapeRegex = (input: string): string =>\r\n                input.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n\r\n            const findKey = (segment: string, startAt: number): { start: number } | null => {\r\n                const escaped = escapeRegex(segment);\r\n                const re = new RegExp(`(['\"])${escaped}\\\\1\\\\s*=>`, 'g');\r\n                re.lastIndex = Math.max(0, startAt);\r\n                const match = re.exec(text);\r\n                if (!match || typeof match.index !== 'number') {\r\n                    return null;\r\n                }\r\n                return { start: match.index + 1 };\r\n            };\r\n\r\n            let searchStart = 0;\r\n            if (parts.length > 1) {\r\n                for (let i = 0; i < parts.length - 1; i += 1) {\r\n                    const seg = parts[i];\r\n                    if (!seg) continue;\r\n                    const hit = findKey(seg, searchStart);\r\n                    if (!hit) {\r\n                        searchStart = 0;\r\n                        break;\r\n                    }\r\n                    searchStart = hit.start + seg.length;\r\n                }\r\n            }\r\n\r\n            const found = findKey(lastSegment, searchStart) || findKey(lastSegment, 0);\r\n            if (!found) {\r\n                return new vscode.Range(new vscode.Position(0, 0), new vscode.Position(0, 0));\r\n            }\r\n\r\n            const foundIndex = found.start;\r\n            let line = 0;\r\n            while (line + 1 < lineStarts.length && lineStarts[line + 1] <= foundIndex) {\r\n                line += 1;\r\n            }\r\n            const character = foundIndex - lineStarts[line];\r\n            const start = new vscode.Position(line, character);\r\n            const end = new vscode.Position(line, character + lastSegment.length);\r\n            const range = new vscode.Range(start, end);\r\n            keyRanges.set(fullKey, range);\r\n            return range;\r\n        }\r\n\r\n        // Try to narrow the search using the full dotted key path so we place\r\n        // diagnostics on the correct occurrence when the same slug appears\r\n        // under multiple groups in a large locale file.\r\n        let searchStart = 0;\r\n        if (parts.length > 1) {\r\n            for (let i = 0; i < parts.length - 1; i += 1) {\r\n                const seg = parts[i];\r\n                if (!seg) {\r\n                    continue;\r\n                }\r\n                const segNeedle = `\"${seg}\"`;\r\n                const idx = text.indexOf(segNeedle, searchStart);\r\n                if (idx === -1) {\r\n                    searchStart = 0;\r\n                    break;\r\n                }\r\n                searchStart = idx + segNeedle.length;\r\n            }\r\n        }\r\n\r\n        const needle = `\"${lastSegment}\"`;\r\n        let index = text.indexOf(needle, searchStart);\r\n        let foundIndex = -1;\r\n\r\n        while (index !== -1) {\r\n            let i = index + needle.length;\r\n            while (\r\n                i < text.length &&\r\n                (text[i] === ' ' || text[i] === '\\t' || text[i] === '\\r' || text[i] === '\\n')\r\n            ) {\r\n                i += 1;\r\n            }\r\n            if (i < text.length && text[i] === ':') {\r\n                foundIndex = index + 1;\r\n                break;\r\n            }\r\n            index = text.indexOf(needle, index + needle.length);\r\n        }\r\n\r\n        if (foundIndex === -1) {\r\n            return new vscode.Range(new vscode.Position(0, 0), new vscode.Position(0, 0));\r\n        }\r\n\r\n        let line = 0;\r\n        while (line + 1 < lineStarts.length && lineStarts[line + 1] <= foundIndex) {\r\n            line += 1;\r\n        }\r\n        const character = foundIndex - lineStarts[line];\r\n        const start = new vscode.Position(line, character);\r\n        const end = new vscode.Position(line, character + lastSegment.length);\r\n        const range = new vscode.Range(start, end);\r\n        keyRanges.set(fullKey, range);\r\n        return range;\r\n    }\r\n\r\n    private getSourceKeySets(\r\n        allKeys: string[],\r\n    ): {\r\n        laravelKeys: Set<string>;\r\n        jsonBackedKeys: Set<string>;\r\n        resxBackedKeys: Set<string>;\r\n        poBackedKeys: Set<string>;\r\n    } {\r\n        if (\r\n            this.sourceKeySetsCache &&\r\n            this.sourceKeySetsCache.keyCount === allKeys.length\r\n        ) {\r\n            return {\r\n                laravelKeys: this.sourceKeySetsCache.laravelKeys,\r\n                jsonBackedKeys: this.sourceKeySetsCache.jsonBackedKeys,\r\n                resxBackedKeys: this.sourceKeySetsCache.resxBackedKeys,\r\n                poBackedKeys: this.sourceKeySetsCache.poBackedKeys,\r\n            };\r\n        }\r\n\r\n        const laravelKeys = new Set<string>();\r\n        const jsonBackedKeys = new Set<string>();\r\n        const resxBackedKeys = new Set<string>();\r\n        const poBackedKeys = new Set<string>();\r\n\r\n        for (const key of allKeys) {\r\n            const record = this.i18nIndex.getRecord(key);\r\n            if (!record) {\r\n                continue;\r\n            }\r\n            let hasLaravel = false;\r\n            let hasJson = false;\r\n            let hasResx = false;\r\n            let hasPo = false;\r\n            for (const loc of record.locations) {\r\n                const fsPath = loc.uri.fsPath.replace(/\\\\/g, '/').toLowerCase();\r\n                if (fsPath.endsWith('.json')) {\r\n                    hasJson = true;\r\n                }\r\n                if (fsPath.includes('/lang/') || fsPath.includes('/resources/lang/')) {\r\n                    hasLaravel = true;\r\n                }\r\n                if (fsPath.endsWith('.resx')) {\r\n                    hasResx = true;\r\n                }\r\n                if (fsPath.endsWith('.po')) {\r\n                    hasPo = true;\r\n                }\r\n                if (hasLaravel && hasJson && hasResx && hasPo) {\r\n                    break;\r\n                }\r\n            }\r\n            if (hasLaravel) {\r\n                laravelKeys.add(key);\r\n            }\r\n            if (hasJson) {\r\n                jsonBackedKeys.add(key);\r\n            }\r\n            if (hasResx) {\r\n                resxBackedKeys.add(key);\r\n            }\r\n            if (hasPo) {\r\n                poBackedKeys.add(key);\r\n            }\r\n        }\r\n\r\n        this.sourceKeySetsCache = {\r\n            laravelKeys,\r\n            jsonBackedKeys,\r\n            resxBackedKeys,\r\n            poBackedKeys,\r\n            keyCount: allKeys.length,\r\n        };\r\n\r\n        return { laravelKeys, jsonBackedKeys, resxBackedKeys, poBackedKeys };\r\n    }\r\n\r\n    /**\r\n     * Analyze a source file (ts/tsx/js/jsx/vue) for missing translation key references.\r\n     * Returns diagnostics for any t('key') calls where the key doesn't exist.\r\n     */\r\n    async analyzeSourceFile(\r\n        uri: vscode.Uri,\r\n        config: DiagnosticConfig,\r\n    ): Promise<vscode.Diagnostic[]> {\r\n        this.logVerboseEnabled = config.verboseLogging === true;\r\n        const fileKey = uri.toString();\r\n        const languageId = this.getLanguageIdForUri(uri);\r\n        const isLaravelSource = languageId === 'php' || languageId === 'blade';\r\n        const isDotNetSource = languageId === 'csharp' || languageId === 'razor';\r\n        const isPythonSource = languageId === 'python';\r\n        \r\n        // Only analyze supported source file types\r\n        if (!DiagnosticAnalyzer.SOURCE_SUPPORTED_LANGUAGES.has(languageId)) {\r\n            return [];\r\n        }\r\n\r\n        // Never analyze files inside vendor/ directories for missing reference diagnostics.\r\n        const normalizedPath = uri.fsPath.replace(/\\\\/g, '/');\r\n        if (normalizedPath.includes('/vendor/')) {\r\n            return [];\r\n        }\r\n\r\n        const lowerPath = normalizedPath.toLowerCase();\r\n        if (\r\n            lowerPath.endsWith('.php') &&\r\n            (lowerPath.includes('/lang/') || lowerPath.includes('/resources/lang/'))\r\n        ) {\r\n            return [];\r\n        }\r\n\r\n        this.safeLog(`[DiagnosticAnalyzer] Analyzing source file for missing refs: ${uri.fsPath}`);\r\n\r\n        let text: string;\r\n        try {\r\n            const data = await vscode.workspace.fs.readFile(uri);\r\n            text = sharedDecoder.decode(data);\r\n        } catch {\r\n            return [];\r\n        }\r\n\r\n        await this.i18nIndex.ensureInitialized();\r\n        const allKeys = this.i18nIndex.getAllKeys();\r\n\r\n        // Use cached key sets to avoid recomputing classifications on every file\r\n        const { laravelKeys, jsonBackedKeys, resxBackedKeys, poBackedKeys } =\r\n            this.getSourceKeySets(allKeys);\r\n        const validKeysSet = isLaravelSource\r\n            ? laravelKeys\r\n            : isDotNetSource\r\n            ? resxBackedKeys\r\n            : isPythonSource\r\n            ? poBackedKeys\r\n            : jsonBackedKeys;\r\n        \r\n        const diagnostics: vscode.Diagnostic[] = [];\r\n        \r\n        // Build comment ranges to skip false positives in comments\r\n        const commentRanges = this.findCommentRanges(text);\r\n        // Build string literal ranges to avoid flagging t('key') patterns that only\r\n        // appear inside plain strings (e.g. documentation prompts, AI instructions).\r\n        const stringRanges = this.findStringLiteralRanges(text);\r\n\r\n        // Match translation calls that reference i18n keys.\r\n        // JS/TS/Vue: t('key'), t(\"key\"), $t('key'), $t(\"key\")\r\n        // Laravel PHP/Blade: __('key'), trans('key'), @lang('key')\r\n        // ASP.NET C#/Razor: Localizer[\"Key\"], HtmlLocalizer[\"Key\"], etc.\r\n        // Python (Django/Flask): _('key'), gettext('key')\r\n        const tCallPatterns = this.buildTranslationCallPatterns({ isLaravelSource, isPythonSource });\r\n\r\n        for (const { regex, keyGroupIndex } of tCallPatterns) {\r\n            regex.lastIndex = 0;\r\n            let match;\r\n\r\n            while ((match = regex.exec(text)) !== null) {\r\n                const key = match[keyGroupIndex];\r\n                const matchIndex = match.index;\r\n                \r\n                // Skip if match is inside a comment or string literal\r\n                if (\r\n                    this.isIndexInRanges(matchIndex, commentRanges) ||\r\n                    this.isIndexInRanges(matchIndex, stringRanges)\r\n                ) {\r\n                    continue;\r\n                }\r\n                \r\n                if (!validKeysSet.has(key)) {\r\n                    // Fallback: if the key exists anywhere in the index, treat it as\r\n                    // valid when it has a backing file appropriate for the source\r\n                    // language (JSON for JS/TS, PHP for Laravel, RESX for .NET,\r\n                    // PO for Python/Django/Flask).\r\n                    const record = this.i18nIndex.getRecord(key);\r\n                    if (record && Array.isArray(record.locations) && record.locations.length > 0) {\r\n                        const hasJsonLocation = record.locations.some((loc) =>\r\n                            loc.uri.fsPath.toLowerCase().endsWith('.json'),\r\n                        );\r\n                        const hasResxLocation = record.locations.some((loc) =>\r\n                            loc.uri.fsPath.toLowerCase().endsWith('.resx'),\r\n                        );\r\n                        const hasPoLocation = record.locations.some((loc) =>\r\n                            loc.uri.fsPath.toLowerCase().endsWith('.po'),\r\n                        );\r\n\r\n                        if (isLaravelSource) {\r\n                            // Any backing location is acceptable for Laravel usages.\r\n                            continue;\r\n                        }\r\n                        if (isDotNetSource && hasResxLocation) {\r\n                            continue;\r\n                        }\r\n                        if (isPythonSource && hasPoLocation) {\r\n                            continue;\r\n                        }\r\n                        if (!isDotNetSource && !isPythonSource && hasJsonLocation) {\r\n                            continue;\r\n                        }\r\n                    }\r\n\r\n                    // Calculate position\r\n                    const startIndex = match.index + match[0].indexOf(key);\r\n                    const endIndex = startIndex + key.length;\r\n                    \r\n                    const startPos = this.indexToPosition(text, startIndex);\r\n                    const endPos = this.indexToPosition(text, endIndex);\r\n                    const range = new vscode.Range(startPos, endPos);\r\n\r\n                    const diagnostic = new vscode.Diagnostic(\r\n                        range,\r\n                        `Missing translation key \"${key}\" - key not found in locale files`,\r\n                        config.missingReferenceSeverity ?? config.missingSeverity,\r\n                    );\r\n                    diagnostic.code = 'ai-i18n.missing-reference';\r\n                    diagnostic.source = 'AI Localizer';\r\n                    diagnostics.push(diagnostic);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.diagnosticsByFile.set(fileKey, diagnostics);\r\n        // Avoid spamming the output channel for every scanned file.\r\n        // Only log per-file results when there are actual missing refs, or when verbose logging is enabled.\r\n        if (diagnostics.length > 0) {\r\n            this.log.appendLine(\r\n                `[DiagnosticAnalyzer] Found ${diagnostics.length} missing reference(s) in source file: ${uri.fsPath}`,\r\n            );\r\n        } else {\r\n            this.safeLog(\r\n                `[DiagnosticAnalyzer] Found ${diagnostics.length} missing reference(s) in source file: ${uri.fsPath}`,\r\n            );\r\n        }\r\n        return diagnostics;\r\n    }\r\n    \r\n    /**\r\n     * Find all comment ranges in source text (single-line // and multi-line /* *\\/)\r\n     * Also handles HTML comments <!-- --> for Vue templates\r\n     */\r\n    private findCommentRanges(text: string): Array<{ start: number; end: number }> {\r\n        const ranges: Array<{ start: number; end: number }> = [];\r\n        \r\n        // Match single-line comments: // ... until end of line\r\n        const singleLineRegex = /\\/\\/[^\\n]*/g;\r\n        let match;\r\n        while ((match = singleLineRegex.exec(text)) !== null) {\r\n            ranges.push({ start: match.index, end: match.index + match[0].length });\r\n        }\r\n        \r\n        // Match multi-line comments: /* ... */\r\n        const multiLineRegex = /\\/\\*[\\s\\S]*?\\*\\//g;\r\n        while ((match = multiLineRegex.exec(text)) !== null) {\r\n            ranges.push({ start: match.index, end: match.index + match[0].length });\r\n        }\r\n\r\n        // Match hash-style comments: # ... until end of line (Python, shell, etc.)\r\n        const hashLineRegex = /^[ \\t]*#[^\\n]*/gm;\r\n        while ((match = hashLineRegex.exec(text)) !== null) {\r\n            ranges.push({ start: match.index, end: match.index + match[0].length });\r\n        }\r\n        \r\n        // Match HTML comments: <!-- ... --> (for Vue templates)\r\n        const htmlCommentRegex = /<!--[\\s\\S]*?-->/g;\r\n        while ((match = htmlCommentRegex.exec(text)) !== null) {\r\n            ranges.push({ start: match.index, end: match.index + match[0].length });\r\n        }\r\n        \r\n        return ranges;\r\n    }\r\n\r\n    /**\r\n     * Find ranges of JavaScript/TypeScript string literals (\", ' and `) in raw text.\r\n     * This is a lightweight heuristic used only to suppress false positives where\r\n     * t('key') appears inside documentation strings or prompt text.\r\n     */\r\n    private findStringLiteralRanges(text: string): Array<{ start: number; end: number }> {\r\n        const ranges: Array<{ start: number; end: number }> = [];\r\n        const len = text.length;\r\n        let i = 0;\r\n\r\n        while (i < len) {\r\n            const ch = text[i];\r\n            if (ch === '\"' || ch === '\\'' || ch === '`') {\r\n                const quote = ch;\r\n                const start = i;\r\n                i += 1;\r\n                let escaped = false;\r\n                while (i < len) {\r\n                    const c = text[i];\r\n                    if (escaped) {\r\n                        escaped = false;\r\n                    } else if (c === '\\\\') {\r\n                        escaped = true;\r\n                    } else if (c === quote) {\r\n                        i += 1;\r\n                        ranges.push({ start, end: i });\r\n                        break;\r\n                    }\r\n                    i += 1;\r\n                }\r\n                continue;\r\n            }\r\n            i += 1;\r\n        }\r\n\r\n        return ranges;\r\n    }\r\n    \r\n    /**\r\n     * Check if an index falls within any of the given ranges\r\n     */\r\n    private isIndexInRanges(index: number, ranges: Array<{ start: number; end: number }>): boolean {\r\n        for (const range of ranges) {\r\n            if (index >= range.start && index < range.end) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Convert a character index to a Position in the document.\r\n     */\r\n    private indexToPosition(text: string, index: number): vscode.Position {\r\n        let line = 0;\r\n        let character = 0;\r\n        \r\n        for (let i = 0; i < index && i < text.length; i++) {\r\n            if (text[i] === '\\n') {\r\n                line++;\r\n                character = 0;\r\n            } else {\r\n                character++;\r\n            }\r\n        }\r\n        \r\n        return new vscode.Position(line, character);\r\n    }\r\n\r\n    /**\r\n     * Get language ID for a URI based on file extension.\r\n     */\r\n    private getLanguageIdForUri(uri: vscode.Uri): string {\r\n        const ext = uri.fsPath.split('.').pop()?.toLowerCase() || '';\r\n        switch (ext) {\r\n            case 'ts':\r\n                return 'typescript';\r\n            case 'tsx':\r\n                return 'typescriptreact';\r\n            case 'js':\r\n            case 'mjs':\r\n                return 'javascript';\r\n            case 'jsx':\r\n                return 'javascriptreact';\r\n            case 'vue':\r\n                return 'vue';\r\n            case 'cs':\r\n                return 'csharp';\r\n            case 'cshtml':\r\n            case 'razor':\r\n                return 'razor';\r\n            case 'py':\r\n                return 'python';\r\n            case 'go':\r\n                return 'go';\r\n            default:\r\n                return ext;\r\n        }\r\n    }\r\n}\r\n\r\nexport interface DiagnosticConfig {\r\n    enabled: boolean;\r\n    defaultLocale: string;\r\n    missingSeverity: vscode.DiagnosticSeverity;\r\n    untranslatedEnabled: boolean;\r\n    untranslatedSeverity: vscode.DiagnosticSeverity;\r\n    invalidSeverity: vscode.DiagnosticSeverity;\r\n    missingReferenceEnabled: boolean;\r\n    missingReferenceSeverity: vscode.DiagnosticSeverity;\r\n    verboseLogging?: boolean;\r\n}\r\n\r\nexport function getDiagnosticConfig(): DiagnosticConfig {\r\n    const cfg = vscode.workspace.getConfiguration('ai-localizer');\r\n    const enabled = cfg.get<boolean>('i18n.diagnostics.enabled') ?? true;\r\n    const defaultLocale = cfg.get<string>('i18n.defaultLocale') || 'en';\r\n\r\n    const mapSeverity = (value: string | undefined): vscode.DiagnosticSeverity => {\r\n        switch ((value || '').toLowerCase()) {\r\n            case 'error':\r\n                return vscode.DiagnosticSeverity.Error;\r\n            case 'info':\r\n                return vscode.DiagnosticSeverity.Information;\r\n            case 'hint':\r\n                return vscode.DiagnosticSeverity.Hint;\r\n            case 'warning':\r\n            default:\r\n                return vscode.DiagnosticSeverity.Warning;\r\n        }\r\n    };\r\n\r\n    const missingSeveritySetting = cfg.get<string>('i18n.diagnostics.missingLocaleSeverity') || 'warning';\r\n    const untranslatedEnabled = cfg.get<boolean>('i18n.diagnostics.untranslatedSameAsDefaultEnabled') ?? true;\r\n    const untranslatedSeveritySetting =\r\n        cfg.get<string>('i18n.diagnostics.untranslatedSameAsDefaultSeverity') || 'warning';\r\n    const invalidSeveritySetting =\r\n        cfg.get<string>('i18n.diagnostics.invalidBaseValueSeverity') || 'warning';\r\n    const missingReferenceEnabled = cfg.get<boolean>('i18n.diagnostics.missingReferenceEnabled') ?? true;\r\n    const missingReferenceSeveritySetting =\r\n        cfg.get<string>('i18n.diagnostics.missingReferenceSeverity') || 'error';\r\n    const verboseLogging = cfg.get<boolean>('i18n.diagnostics.verboseLogging') ?? false;\r\n\r\n    return {\r\n        enabled,\r\n        defaultLocale,\r\n        missingSeverity: mapSeverity(missingSeveritySetting),\r\n        untranslatedEnabled,\r\n        untranslatedSeverity: mapSeverity(untranslatedSeveritySetting),\r\n        invalidSeverity: mapSeverity(invalidSeveritySetting),\r\n        missingReferenceEnabled,\r\n        missingReferenceSeverity: mapSeverity(missingReferenceSeveritySetting),\r\n        verboseLogging,\r\n    };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\services\\fileSystemService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\services\\granularSyncService.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":227,"column":17,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":227,"endColumn":42,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[7653,7654],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":471,"column":17,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":471,"endColumn":42,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[17337,17338],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\r\nimport * as path from 'path';\r\nimport { TextDecoder, TextEncoder } from 'util';\r\nimport { getProjectEnv } from '../core/projectEnv';\r\n\r\nconst sharedDecoder = new TextDecoder('utf-8');\r\nconst sharedEncoder = new TextEncoder();\r\n\r\nexport type SyncMode = 'keys' | 'file' | 'full';\r\n\r\nexport interface SyncResult {\r\n    updated: number;\r\n    files: string[];\r\n    mode: SyncMode;\r\n}\r\n\r\nexport interface GranularSyncOptions {\r\n    baseLocale?: string;\r\n    verbose?: boolean;\r\n    forceUpdate?: boolean;\r\n}\r\n\r\nfunction sortObjectDeep(input: unknown): unknown {\r\n    if (!input || typeof input !== 'object' || Array.isArray(input)) {\r\n        return input;\r\n    }\r\n    const obj = input as Record<string, unknown>;\r\n    const sortedKeys = Object.keys(obj).sort();\r\n    const result: Record<string, unknown> = {};\r\n    for (const key of sortedKeys) {\r\n        result[key] = sortObjectDeep(obj[key]);\r\n    }\r\n    return result;\r\n}\r\n\r\nfunction getKeyValue(obj: unknown, keyPath: string): unknown {\r\n    if (!obj || typeof obj !== 'object') return undefined;\r\n    const segments = String(keyPath).split('.').filter(Boolean);\r\n    let node: any = obj;\r\n    for (const segment of segments) {\r\n        if (!node || typeof node !== 'object') return undefined;\r\n        node = node[segment];\r\n    }\r\n    return node;\r\n}\r\n\r\nfunction setKeyValue(obj: Record<string, unknown>, keyPath: string, value: unknown): void {\r\n    const segments = String(keyPath).split('.').filter(Boolean);\r\n    if (!segments.length) return;\r\n\r\n    let node: any = obj;\r\n    for (let i = 0; i < segments.length - 1; i++) {\r\n        const segment = segments[i];\r\n        if (!node[segment] || typeof node[segment] !== 'object') {\r\n            node[segment] = {};\r\n        }\r\n        node = node[segment];\r\n    }\r\n    node[segments[segments.length - 1]] = value;\r\n}\r\n\r\nfunction hasKeyPath(obj: unknown, keyPath: string): boolean {\r\n    return getKeyValue(obj, keyPath) !== undefined;\r\n}\r\n\r\nasync function readJsonFile(uri: vscode.Uri): Promise<Record<string, unknown> | null> {\r\n    try {\r\n        const data = await vscode.workspace.fs.readFile(uri);\r\n        const text = sharedDecoder.decode(data);\r\n        const parsed = JSON.parse(text);\r\n        if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\r\n            return parsed as Record<string, unknown>;\r\n        }\r\n        return null;\r\n    } catch {\r\n        return null;\r\n    }\r\n}\r\n\r\nasync function writeJsonFile(uri: vscode.Uri, data: Record<string, unknown>): Promise<void> {\r\n    const sorted = sortObjectDeep(data) as Record<string, unknown>;\r\n    const payload = `${JSON.stringify(sorted, null, 2)}\\n`;\r\n    await vscode.workspace.fs.writeFile(uri, sharedEncoder.encode(payload));\r\n}\r\n\r\nasync function fileExists(uri: vscode.Uri): Promise<boolean> {\r\n    try {\r\n        await vscode.workspace.fs.stat(uri);\r\n        return true;\r\n    } catch {\r\n        return false;\r\n    }\r\n}\r\n\r\nasync function ensureDir(uri: vscode.Uri): Promise<void> {\r\n    try {\r\n        await vscode.workspace.fs.createDirectory(uri);\r\n    } catch {\r\n        // Directory may already exist\r\n    }\r\n}\r\n\r\nfunction getFileNameForKey(keyPath: string): string {\r\n    const segments = String(keyPath).split('.').filter(Boolean);\r\n    if (segments.length < 1) {\r\n        return 'common.json';\r\n    }\r\n    return `${segments[0].toLowerCase()}.json`;\r\n}\r\n\r\nexport class GranularSyncService {\r\n    private outputChannel: vscode.OutputChannel | undefined;\r\n\r\n    constructor(private context?: vscode.ExtensionContext) {}\r\n\r\n    private log(message: string): void {\r\n        if (!this.outputChannel) {\r\n            this.outputChannel = vscode.window.createOutputChannel('AI Localizer Sync');\r\n        }\r\n        this.outputChannel.appendLine(message);\r\n    }\r\n\r\n    private async getAutoDir(folder: vscode.WorkspaceFolder): Promise<vscode.Uri> {\r\n        try {\r\n            const env = await getProjectEnv(folder);\r\n            return vscode.Uri.file(path.join(env.runtimeRoot, 'auto'));\r\n        } catch {\r\n            // Fallback paths\r\n            const candidates = [\r\n                'resources/js/i18n/auto',\r\n                'src/i18n/auto',\r\n                'src/locales',\r\n                'locales',\r\n            ];\r\n            for (const candidate of candidates) {\r\n                const uri = vscode.Uri.joinPath(folder.uri, candidate);\r\n                if (await fileExists(uri)) {\r\n                    return uri;\r\n                }\r\n            }\r\n            return vscode.Uri.joinPath(folder.uri, 'resources/js/i18n/auto');\r\n        }\r\n    }\r\n\r\n    private async getConfiguredLocales(folder: vscode.WorkspaceFolder): Promise<string[]> {\r\n        try {\r\n            const pkgUri = vscode.Uri.joinPath(folder.uri, 'package.json');\r\n            const data = await vscode.workspace.fs.readFile(pkgUri);\r\n            const pkg = JSON.parse(sharedDecoder.decode(data));\r\n            if (pkg?.aiI18n?.locales && Array.isArray(pkg.aiI18n.locales)) {\r\n                return pkg.aiI18n.locales.filter((l: unknown) => typeof l === 'string' && l);\r\n            }\r\n        } catch {\r\n            // Ignore\r\n        }\r\n        return [];\r\n    }\r\n\r\n    private async discoverLocales(\r\n        autoDir: vscode.Uri,\r\n        baseLocale: string\r\n    ): Promise<Set<string>> {\r\n        const locales = new Set<string>();\r\n\r\n        try {\r\n            const entries = await vscode.workspace.fs.readDirectory(autoDir);\r\n            for (const [name, type] of entries) {\r\n                if (type === vscode.FileType.Directory && name !== baseLocale) {\r\n                    locales.add(name);\r\n                } else if (type === vscode.FileType.File && name.endsWith('.json')) {\r\n                    const localeName = name.replace(/\\.json$/i, '');\r\n                    if (localeName !== baseLocale) {\r\n                        locales.add(localeName);\r\n                    }\r\n                }\r\n            }\r\n        } catch {\r\n            // Directory may not exist\r\n        }\r\n\r\n        return locales;\r\n    }\r\n\r\n    /**\r\n     * Sync specific keys only across all locales.\r\n     * Use this for quick fixes where only a few keys need syncing.\r\n     */\r\n    async syncKeys(\r\n        folder: vscode.WorkspaceFolder,\r\n        keys: string[],\r\n        options: GranularSyncOptions = {}\r\n    ): Promise<SyncResult> {\r\n        const { baseLocale = 'en', verbose = false } = options;\r\n        const result: SyncResult = { updated: 0, files: [], mode: 'keys' };\r\n\r\n        if (!keys.length) {\r\n            return result;\r\n        }\r\n\r\n        const autoDir = await this.getAutoDir(folder);\r\n        const baseGroupedDir = vscode.Uri.joinPath(autoDir, baseLocale);\r\n        const useGrouped = await fileExists(baseGroupedDir);\r\n\r\n        // Determine target locales\r\n        const configuredLocales = await this.getConfiguredLocales(folder);\r\n        let locales = new Set(configuredLocales.filter(l => l !== baseLocale));\r\n\r\n        if (locales.size === 0) {\r\n            locales = await this.discoverLocales(autoDir, baseLocale);\r\n        }\r\n\r\n        if (locales.size === 0) {\r\n            if (verbose) {\r\n                this.log('[granular-sync] No target locales found');\r\n            }\r\n            return result;\r\n        }\r\n\r\n        if (useGrouped) {\r\n            // Group keys by their target file\r\n            const keysByFile = new Map<string, string[]>();\r\n            for (const key of keys) {\r\n                const fileName = getFileNameForKey(key);\r\n                if (!keysByFile.has(fileName)) {\r\n                    keysByFile.set(fileName, []);\r\n                }\r\n                keysByFile.get(fileName)!.push(key);\r\n            }\r\n\r\n            for (const locale of locales) {\r\n                const localeDir = vscode.Uri.joinPath(autoDir, locale);\r\n\r\n                for (const [fileName, fileKeys] of keysByFile.entries()) {\r\n                    const baseFileUri = vscode.Uri.joinPath(baseGroupedDir, fileName);\r\n                    const targetFileUri = vscode.Uri.joinPath(localeDir, fileName);\r\n\r\n                    const baseData = await readJsonFile(baseFileUri);\r\n                    if (!baseData) continue;\r\n\r\n                    const targetData = (await readJsonFile(targetFileUri)) || {};\r\n                    let modified = false;\r\n\r\n                    for (const key of fileKeys) {\r\n                        const baseValue = getKeyValue(baseData, key);\r\n                        if (baseValue === undefined) continue;\r\n\r\n                        if (!hasKeyPath(targetData, key)) {\r\n                            setKeyValue(targetData, key, baseValue);\r\n                            modified = true;\r\n                            if (verbose) {\r\n                                this.log(`[granular-sync] Added key \"${key}\" to ${locale}/${fileName}`);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (modified) {\r\n                        await ensureDir(localeDir);\r\n                        await writeJsonFile(targetFileUri, targetData);\r\n                        result.updated++;\r\n                        result.files.push(targetFileUri.fsPath);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            // Single-file structure\r\n            const baseFileUri = vscode.Uri.joinPath(autoDir, `${baseLocale}.json`);\r\n            const baseData = await readJsonFile(baseFileUri);\r\n            if (!baseData) return result;\r\n\r\n            for (const locale of locales) {\r\n                const targetFileUri = vscode.Uri.joinPath(autoDir, `${locale}.json`);\r\n                const targetData = (await readJsonFile(targetFileUri)) || {};\r\n                let modified = false;\r\n\r\n                for (const key of keys) {\r\n                    const baseValue = getKeyValue(baseData, key);\r\n                    if (baseValue === undefined) continue;\r\n\r\n                    if (!hasKeyPath(targetData, key)) {\r\n                        setKeyValue(targetData, key, baseValue);\r\n                        modified = true;\r\n                        if (verbose) {\r\n                            this.log(`[granular-sync] Added key \"${key}\" to ${locale}.json`);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (modified) {\r\n                    await writeJsonFile(targetFileUri, targetData);\r\n                    result.updated++;\r\n                    result.files.push(targetFileUri.fsPath);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (verbose) {\r\n            this.log(`[granular-sync] Synced ${keys.length} key(s), updated ${result.updated} file(s)`);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sync all keys from a specific locale JSON file to other locales.\r\n     * Use this when operating on a single file.\r\n     */\r\n    async syncFile(\r\n        folder: vscode.WorkspaceFolder,\r\n        fileUri: vscode.Uri,\r\n        options: GranularSyncOptions = {}\r\n    ): Promise<SyncResult> {\r\n        const { baseLocale = 'en', verbose = false } = options;\r\n        const result: SyncResult = { updated: 0, files: [], mode: 'file' };\r\n\r\n        if (!(await fileExists(fileUri))) {\r\n            return result;\r\n        }\r\n\r\n        const autoDir = await this.getAutoDir(folder);\r\n        const normalizedPath = fileUri.fsPath;\r\n\r\n        // Infer locale and relative path from file\r\n        const autoMarker = `${path.sep}auto${path.sep}`;\r\n        const autoIndex = normalizedPath.indexOf(autoMarker);\r\n\r\n        let sourceLocale = baseLocale;\r\n        let relativeFilePath = '';\r\n\r\n        if (autoIndex >= 0) {\r\n            const afterAuto = normalizedPath.substring(autoIndex + autoMarker.length);\r\n            const parts = afterAuto.split(path.sep);\r\n            if (parts.length >= 1) {\r\n                sourceLocale = parts[0].replace(/\\.json$/i, '');\r\n                relativeFilePath = parts.slice(1).join(path.sep);\r\n            }\r\n        } else {\r\n            sourceLocale = path.basename(fileUri.fsPath, '.json');\r\n        }\r\n\r\n        // Only sync from base locale\r\n        if (sourceLocale !== baseLocale) {\r\n            if (verbose) {\r\n                this.log(`[granular-sync] Skipping non-base locale file: ${fileUri.fsPath}`);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        const sourceData = await readJsonFile(fileUri);\r\n        if (!sourceData) return result;\r\n\r\n        // Collect all keys from source file\r\n        const keys: string[] = [];\r\n        const collectKeys = (obj: unknown, prefix = ''): void => {\r\n            if (!obj || typeof obj !== 'object' || Array.isArray(obj)) return;\r\n            for (const [key, value] of Object.entries(obj as Record<string, unknown>)) {\r\n                const fullKey = prefix ? `${prefix}.${key}` : key;\r\n                if (typeof value === 'string') {\r\n                    keys.push(fullKey);\r\n                } else if (value && typeof value === 'object') {\r\n                    collectKeys(value, fullKey);\r\n                }\r\n            }\r\n        };\r\n        collectKeys(sourceData);\r\n\r\n        if (!keys.length) return result;\r\n\r\n        // Determine target locales\r\n        const configuredLocales = await this.getConfiguredLocales(folder);\r\n        let locales = new Set(configuredLocales.filter(l => l !== baseLocale));\r\n\r\n        if (locales.size === 0) {\r\n            locales = await this.discoverLocales(autoDir, baseLocale);\r\n        }\r\n\r\n        if (locales.size === 0) return result;\r\n\r\n        const baseGroupedDir = vscode.Uri.joinPath(autoDir, baseLocale);\r\n        const useGrouped = (await fileExists(baseGroupedDir)) && relativeFilePath;\r\n\r\n        if (useGrouped && relativeFilePath) {\r\n            for (const locale of locales) {\r\n                const targetFileUri = vscode.Uri.joinPath(autoDir, locale, relativeFilePath);\r\n                const targetData = (await readJsonFile(targetFileUri)) || {};\r\n                let modified = false;\r\n\r\n                for (const key of keys) {\r\n                    const sourceValue = getKeyValue(sourceData, key);\r\n                    if (sourceValue === undefined) continue;\r\n\r\n                    if (!hasKeyPath(targetData, key)) {\r\n                        setKeyValue(targetData, key, sourceValue);\r\n                        modified = true;\r\n                    }\r\n                }\r\n\r\n                if (modified) {\r\n                    const targetDir = vscode.Uri.file(path.dirname(targetFileUri.fsPath));\r\n                    await ensureDir(targetDir);\r\n                    await writeJsonFile(targetFileUri, targetData);\r\n                    result.updated++;\r\n                    result.files.push(targetFileUri.fsPath);\r\n                    if (verbose) {\r\n                        this.log(`[granular-sync] Synced ${locale}/${relativeFilePath}`);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            for (const locale of locales) {\r\n                const targetFileUri = vscode.Uri.joinPath(autoDir, `${locale}.json`);\r\n                const targetData = (await readJsonFile(targetFileUri)) || {};\r\n                let modified = false;\r\n\r\n                for (const key of keys) {\r\n                    const sourceValue = getKeyValue(sourceData, key);\r\n                    if (sourceValue === undefined) continue;\r\n\r\n                    if (!hasKeyPath(targetData, key)) {\r\n                        setKeyValue(targetData, key, sourceValue);\r\n                        modified = true;\r\n                    }\r\n                }\r\n\r\n                if (modified) {\r\n                    await writeJsonFile(targetFileUri, targetData);\r\n                    result.updated++;\r\n                    result.files.push(targetFileUri.fsPath);\r\n                    if (verbose) {\r\n                        this.log(`[granular-sync] Synced ${locale}.json`);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (verbose) {\r\n            this.log(`[granular-sync] File sync completed, updated ${result.updated} file(s)`);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Ensure specific keys exist in all locales, creating them with base locale values.\r\n     * Unlike syncKeys, this also creates missing keys in the base locale using provided values.\r\n     */\r\n    async ensureKeys(\r\n        folder: vscode.WorkspaceFolder,\r\n        keys: string[],\r\n        values: Record<string, string> = {},\r\n        options: GranularSyncOptions = {}\r\n    ): Promise<SyncResult> {\r\n        const { baseLocale = 'en', verbose = false, forceUpdate = false } = options;\r\n        const result: SyncResult = { updated: 0, files: [], mode: 'keys' };\r\n\r\n        if (!keys.length) {\r\n            return result;\r\n        }\r\n\r\n        const autoDir = await this.getAutoDir(folder);\r\n        const baseGroupedDir = vscode.Uri.joinPath(autoDir, baseLocale);\r\n        const useGrouped = await fileExists(baseGroupedDir);\r\n\r\n        // First, ensure keys exist in base locale\r\n        if (useGrouped) {\r\n            const keysByFile = new Map<string, string[]>();\r\n            for (const key of keys) {\r\n                const fileName = getFileNameForKey(key);\r\n                if (!keysByFile.has(fileName)) {\r\n                    keysByFile.set(fileName, []);\r\n                }\r\n                keysByFile.get(fileName)!.push(key);\r\n            }\r\n\r\n            for (const [fileName, fileKeys] of keysByFile.entries()) {\r\n                const baseFileUri = vscode.Uri.joinPath(baseGroupedDir, fileName);\r\n                const baseData = (await readJsonFile(baseFileUri)) || {};\r\n                let modified = false;\r\n\r\n                for (const key of fileKeys) {\r\n                    const existingValue = getKeyValue(baseData, key);\r\n                    const providedValue = values[key];\r\n\r\n                    if (existingValue === undefined || (forceUpdate && providedValue !== undefined)) {\r\n                        const valueToSet = providedValue ?? key.split('.').pop() ?? key;\r\n                        setKeyValue(baseData, key, valueToSet);\r\n                        modified = true;\r\n                    }\r\n                }\r\n\r\n                if (modified) {\r\n                    await ensureDir(baseGroupedDir);\r\n                    await writeJsonFile(baseFileUri, baseData);\r\n                    result.updated++;\r\n                    result.files.push(baseFileUri.fsPath);\r\n                    if (verbose) {\r\n                        this.log(`[granular-sync] Updated base locale: ${fileName}`);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const baseFileUri = vscode.Uri.joinPath(autoDir, `${baseLocale}.json`);\r\n            const baseData = (await readJsonFile(baseFileUri)) || {};\r\n            let modified = false;\r\n\r\n            for (const key of keys) {\r\n                const existingValue = getKeyValue(baseData, key);\r\n                const providedValue = values[key];\r\n\r\n                if (existingValue === undefined || (forceUpdate && providedValue !== undefined)) {\r\n                    const valueToSet = providedValue ?? key.split('.').pop() ?? key;\r\n                    setKeyValue(baseData, key, valueToSet);\r\n                    modified = true;\r\n                }\r\n            }\r\n\r\n            if (modified) {\r\n                await ensureDir(autoDir);\r\n                await writeJsonFile(baseFileUri, baseData);\r\n                result.updated++;\r\n                result.files.push(baseFileUri.fsPath);\r\n                if (verbose) {\r\n                    this.log(`[granular-sync] Updated base locale file`);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Now sync to other locales\r\n        const syncResult = await this.syncKeys(folder, keys, options);\r\n        result.updated += syncResult.updated;\r\n        result.files.push(...syncResult.files);\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n// Singleton instance for global access\r\nlet globalSyncService: GranularSyncService | undefined;\r\n\r\nexport function getGranularSyncService(context?: vscode.ExtensionContext): GranularSyncService {\r\n    if (!globalSyncService) {\r\n        globalSyncService = new GranularSyncService(context);\r\n    }\r\n    return globalSyncService;\r\n}\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\services\\projectConfigService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\services\\reviewGeneratedService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\services\\translationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\Son\\CascadeProjects\\windsurf-project\\vscode-ai-assistant\\src\\types\\vue-shim.d.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'T' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":20,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]